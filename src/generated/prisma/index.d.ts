
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model RemunerationSystem
 * 
 */
export type RemunerationSystem = $Result.DefaultSelection<Prisma.$RemunerationSystemPayload>
/**
 * Model FacilityType
 * 
 */
export type FacilityType = $Result.DefaultSelection<Prisma.$FacilityTypePayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model MonthlyHealthData
 * 
 */
export type MonthlyHealthData = $Result.DefaultSelection<Prisma.$MonthlyHealthDataPayload>
/**
 * Model DataUploadSession
 * 
 */
export type DataUploadSession = $Result.DefaultSelection<Prisma.$DataUploadSessionPayload>
/**
 * Model Formula
 * 
 */
export type Formula = $Result.DefaultSelection<Prisma.$FormulaPayload>
/**
 * Model Indicator
 * 
 */
export type Indicator = $Result.DefaultSelection<Prisma.$IndicatorPayload>
/**
 * Model Field
 * 
 */
export type Field = $Result.DefaultSelection<Prisma.$FieldPayload>
/**
 * Model FieldValue
 * 
 */
export type FieldValue = $Result.DefaultSelection<Prisma.$FieldValuePayload>
/**
 * Model FacilityFieldDefaults
 * 
 */
export type FacilityFieldDefaults = $Result.DefaultSelection<Prisma.$FacilityFieldDefaultsPayload>
/**
 * Model FacilityFieldMapping
 * 
 */
export type FacilityFieldMapping = $Result.DefaultSelection<Prisma.$FacilityFieldMappingPayload>
/**
 * Model sub_centre
 * 
 */
export type sub_centre = $Result.DefaultSelection<Prisma.$sub_centrePayload>
/**
 * Model HealthWorker
 * 
 */
export type HealthWorker = $Result.DefaultSelection<Prisma.$HealthWorkerPayload>
/**
 * Model RemunerationCalculation
 * 
 */
export type RemunerationCalculation = $Result.DefaultSelection<Prisma.$RemunerationCalculationPayload>
/**
 * Model WorkerRemuneration
 * 
 */
export type WorkerRemuneration = $Result.DefaultSelection<Prisma.$WorkerRemunerationPayload>
/**
 * Model WorkerAllocationConfig
 * 
 */
export type WorkerAllocationConfig = $Result.DefaultSelection<Prisma.$WorkerAllocationConfigPayload>
/**
 * Model FacilityWorkerAllocation
 * 
 */
export type FacilityWorkerAllocation = $Result.DefaultSelection<Prisma.$FacilityWorkerAllocationPayload>
/**
 * Model FacilityTypeRemuneration
 * 
 */
export type FacilityTypeRemuneration = $Result.DefaultSelection<Prisma.$FacilityTypeRemunerationPayload>
/**
 * Model IndicatorRemuneration
 * 
 */
export type IndicatorRemuneration = $Result.DefaultSelection<Prisma.$IndicatorRemunerationPayload>
/**
 * Model PerformanceCalculation
 * 
 */
export type PerformanceCalculation = $Result.DefaultSelection<Prisma.$PerformanceCalculationPayload>
/**
 * Model FacilityTarget
 * 
 */
export type FacilityTarget = $Result.DefaultSelection<Prisma.$FacilityTargetPayload>
/**
 * Model IndicatorWorkerAllocation
 * 
 */
export type IndicatorWorkerAllocation = $Result.DefaultSelection<Prisma.$IndicatorWorkerAllocationPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  facility: 'facility'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserType: {
  ADMIN: 'ADMIN',
  FACILITY: 'FACILITY'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const FieldType: {
  CONSTANT: 'CONSTANT',
  FACILITY_SPECIFIC: 'FACILITY_SPECIFIC',
  MONTHLY_COUNT: 'MONTHLY_COUNT',
  BINARY: 'BINARY',
  PERCENTAGE: 'PERCENTAGE',
  CALCULATED: 'CALCULATED',
  INDICATOR_REFERENCE: 'INDICATOR_REFERENCE',
  FACILITY_TYPE_SPECIFIC: 'FACILITY_TYPE_SPECIFIC'
};

export type FieldType = (typeof FieldType)[keyof typeof FieldType]


export const ValidationRule: {
  REQUIRED: 'REQUIRED',
  POSITIVE_NUMBER: 'POSITIVE_NUMBER',
  PERCENTAGE_RANGE: 'PERCENTAGE_RANGE',
  DATE_RANGE: 'DATE_RANGE',
  CUSTOM_FORMULA: 'CUSTOM_FORMULA',
  BINARY_ONLY: 'BINARY_ONLY',
  MIN_VALUE: 'MIN_VALUE',
  MAX_VALUE: 'MAX_VALUE'
};

export type ValidationRule = (typeof ValidationRule)[keyof typeof ValidationRule]


export const CalculationType: {
  DIRECT_INPUT: 'DIRECT_INPUT',
  CALCULATED: 'CALCULATED',
  AGGREGATED: 'AGGREGATED',
  PERCENTAGE: 'PERCENTAGE'
};

export type CalculationType = (typeof CalculationType)[keyof typeof CalculationType]


export const DataQuality: {
  PENDING: 'PENDING',
  VALIDATED: 'VALIDATED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type DataQuality = (typeof DataQuality)[keyof typeof DataQuality]


export const UploadStatus: {
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type UploadStatus = (typeof UploadStatus)[keyof typeof UploadStatus]


export const TargetType: {
  BINARY: 'BINARY',
  RANGE: 'RANGE',
  PERCENTAGE_RANGE: 'PERCENTAGE_RANGE'
};

export type TargetType = (typeof TargetType)[keyof typeof TargetType]


export const FieldCategory: {
  DATA_FIELD: 'DATA_FIELD',
  TARGET_FIELD: 'TARGET_FIELD'
};

export type FieldCategory = (typeof FieldCategory)[keyof typeof FieldCategory]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type FieldType = $Enums.FieldType

export const FieldType: typeof $Enums.FieldType

export type ValidationRule = $Enums.ValidationRule

export const ValidationRule: typeof $Enums.ValidationRule

export type CalculationType = $Enums.CalculationType

export const CalculationType: typeof $Enums.CalculationType

export type DataQuality = $Enums.DataQuality

export const DataQuality: typeof $Enums.DataQuality

export type UploadStatus = $Enums.UploadStatus

export const UploadStatus: typeof $Enums.UploadStatus

export type TargetType = $Enums.TargetType

export const TargetType: typeof $Enums.TargetType

export type FieldCategory = $Enums.FieldCategory

export const FieldCategory: typeof $Enums.FieldCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.remunerationSystem`: Exposes CRUD operations for the **RemunerationSystem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RemunerationSystems
    * const remunerationSystems = await prisma.remunerationSystem.findMany()
    * ```
    */
  get remunerationSystem(): Prisma.RemunerationSystemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityType`: Exposes CRUD operations for the **FacilityType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityTypes
    * const facilityTypes = await prisma.facilityType.findMany()
    * ```
    */
  get facilityType(): Prisma.FacilityTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monthlyHealthData`: Exposes CRUD operations for the **MonthlyHealthData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthlyHealthData
    * const monthlyHealthData = await prisma.monthlyHealthData.findMany()
    * ```
    */
  get monthlyHealthData(): Prisma.MonthlyHealthDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataUploadSession`: Exposes CRUD operations for the **DataUploadSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataUploadSessions
    * const dataUploadSessions = await prisma.dataUploadSession.findMany()
    * ```
    */
  get dataUploadSession(): Prisma.DataUploadSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formula`: Exposes CRUD operations for the **Formula** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formulas
    * const formulas = await prisma.formula.findMany()
    * ```
    */
  get formula(): Prisma.FormulaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicator`: Exposes CRUD operations for the **Indicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicators
    * const indicators = await prisma.indicator.findMany()
    * ```
    */
  get indicator(): Prisma.IndicatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.field`: Exposes CRUD operations for the **Field** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fields
    * const fields = await prisma.field.findMany()
    * ```
    */
  get field(): Prisma.FieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fieldValue`: Exposes CRUD operations for the **FieldValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FieldValues
    * const fieldValues = await prisma.fieldValue.findMany()
    * ```
    */
  get fieldValue(): Prisma.FieldValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityFieldDefaults`: Exposes CRUD operations for the **FacilityFieldDefaults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityFieldDefaults
    * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findMany()
    * ```
    */
  get facilityFieldDefaults(): Prisma.FacilityFieldDefaultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityFieldMapping`: Exposes CRUD operations for the **FacilityFieldMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityFieldMappings
    * const facilityFieldMappings = await prisma.facilityFieldMapping.findMany()
    * ```
    */
  get facilityFieldMapping(): Prisma.FacilityFieldMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sub_centre`: Exposes CRUD operations for the **sub_centre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sub_centres
    * const sub_centres = await prisma.sub_centre.findMany()
    * ```
    */
  get sub_centre(): Prisma.sub_centreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.healthWorker`: Exposes CRUD operations for the **HealthWorker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthWorkers
    * const healthWorkers = await prisma.healthWorker.findMany()
    * ```
    */
  get healthWorker(): Prisma.HealthWorkerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.remunerationCalculation`: Exposes CRUD operations for the **RemunerationCalculation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RemunerationCalculations
    * const remunerationCalculations = await prisma.remunerationCalculation.findMany()
    * ```
    */
  get remunerationCalculation(): Prisma.RemunerationCalculationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workerRemuneration`: Exposes CRUD operations for the **WorkerRemuneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerRemunerations
    * const workerRemunerations = await prisma.workerRemuneration.findMany()
    * ```
    */
  get workerRemuneration(): Prisma.WorkerRemunerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workerAllocationConfig`: Exposes CRUD operations for the **WorkerAllocationConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerAllocationConfigs
    * const workerAllocationConfigs = await prisma.workerAllocationConfig.findMany()
    * ```
    */
  get workerAllocationConfig(): Prisma.WorkerAllocationConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityWorkerAllocation`: Exposes CRUD operations for the **FacilityWorkerAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityWorkerAllocations
    * const facilityWorkerAllocations = await prisma.facilityWorkerAllocation.findMany()
    * ```
    */
  get facilityWorkerAllocation(): Prisma.FacilityWorkerAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityTypeRemuneration`: Exposes CRUD operations for the **FacilityTypeRemuneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityTypeRemunerations
    * const facilityTypeRemunerations = await prisma.facilityTypeRemuneration.findMany()
    * ```
    */
  get facilityTypeRemuneration(): Prisma.FacilityTypeRemunerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicatorRemuneration`: Exposes CRUD operations for the **IndicatorRemuneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicatorRemunerations
    * const indicatorRemunerations = await prisma.indicatorRemuneration.findMany()
    * ```
    */
  get indicatorRemuneration(): Prisma.IndicatorRemunerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceCalculation`: Exposes CRUD operations for the **PerformanceCalculation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceCalculations
    * const performanceCalculations = await prisma.performanceCalculation.findMany()
    * ```
    */
  get performanceCalculation(): Prisma.PerformanceCalculationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityTarget`: Exposes CRUD operations for the **FacilityTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityTargets
    * const facilityTargets = await prisma.facilityTarget.findMany()
    * ```
    */
  get facilityTarget(): Prisma.FacilityTargetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicatorWorkerAllocation`: Exposes CRUD operations for the **IndicatorWorkerAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicatorWorkerAllocations
    * const indicatorWorkerAllocations = await prisma.indicatorWorkerAllocation.findMany()
    * ```
    */
  get indicatorWorkerAllocation(): Prisma.IndicatorWorkerAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    District: 'District',
    RemunerationSystem: 'RemunerationSystem',
    FacilityType: 'FacilityType',
    Facility: 'Facility',
    MonthlyHealthData: 'MonthlyHealthData',
    DataUploadSession: 'DataUploadSession',
    Formula: 'Formula',
    Indicator: 'Indicator',
    Field: 'Field',
    FieldValue: 'FieldValue',
    FacilityFieldDefaults: 'FacilityFieldDefaults',
    FacilityFieldMapping: 'FacilityFieldMapping',
    sub_centre: 'sub_centre',
    HealthWorker: 'HealthWorker',
    RemunerationCalculation: 'RemunerationCalculation',
    WorkerRemuneration: 'WorkerRemuneration',
    WorkerAllocationConfig: 'WorkerAllocationConfig',
    FacilityWorkerAllocation: 'FacilityWorkerAllocation',
    FacilityTypeRemuneration: 'FacilityTypeRemuneration',
    IndicatorRemuneration: 'IndicatorRemuneration',
    PerformanceCalculation: 'PerformanceCalculation',
    FacilityTarget: 'FacilityTarget',
    IndicatorWorkerAllocation: 'IndicatorWorkerAllocation',
    SystemSetting: 'SystemSetting'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "district" | "remunerationSystem" | "facilityType" | "facility" | "monthlyHealthData" | "dataUploadSession" | "formula" | "indicator" | "field" | "fieldValue" | "facilityFieldDefaults" | "facilityFieldMapping" | "sub_centre" | "healthWorker" | "remunerationCalculation" | "workerRemuneration" | "workerAllocationConfig" | "facilityWorkerAllocation" | "facilityTypeRemuneration" | "indicatorRemuneration" | "performanceCalculation" | "facilityTarget" | "indicatorWorkerAllocation" | "systemSetting"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DistrictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      RemunerationSystem: {
        payload: Prisma.$RemunerationSystemPayload<ExtArgs>
        fields: Prisma.RemunerationSystemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemunerationSystemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemunerationSystemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>
          }
          findFirst: {
            args: Prisma.RemunerationSystemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemunerationSystemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>
          }
          findMany: {
            args: Prisma.RemunerationSystemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>[]
          }
          create: {
            args: Prisma.RemunerationSystemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>
          }
          createMany: {
            args: Prisma.RemunerationSystemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RemunerationSystemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>[]
          }
          delete: {
            args: Prisma.RemunerationSystemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>
          }
          update: {
            args: Prisma.RemunerationSystemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>
          }
          deleteMany: {
            args: Prisma.RemunerationSystemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemunerationSystemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RemunerationSystemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>[]
          }
          upsert: {
            args: Prisma.RemunerationSystemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationSystemPayload>
          }
          aggregate: {
            args: Prisma.RemunerationSystemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemunerationSystem>
          }
          groupBy: {
            args: Prisma.RemunerationSystemGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemunerationSystemGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemunerationSystemCountArgs<ExtArgs>
            result: $Utils.Optional<RemunerationSystemCountAggregateOutputType> | number
          }
        }
      }
      FacilityType: {
        payload: Prisma.$FacilityTypePayload<ExtArgs>
        fields: Prisma.FacilityTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>
          }
          findFirst: {
            args: Prisma.FacilityTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>
          }
          findMany: {
            args: Prisma.FacilityTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>[]
          }
          create: {
            args: Prisma.FacilityTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>
          }
          createMany: {
            args: Prisma.FacilityTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>[]
          }
          delete: {
            args: Prisma.FacilityTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>
          }
          update: {
            args: Prisma.FacilityTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>
          }
          deleteMany: {
            args: Prisma.FacilityTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>[]
          }
          upsert: {
            args: Prisma.FacilityTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypePayload>
          }
          aggregate: {
            args: Prisma.FacilityTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityType>
          }
          groupBy: {
            args: Prisma.FacilityTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityTypeCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityTypeCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      MonthlyHealthData: {
        payload: Prisma.$MonthlyHealthDataPayload<ExtArgs>
        fields: Prisma.MonthlyHealthDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthlyHealthDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthlyHealthDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>
          }
          findFirst: {
            args: Prisma.MonthlyHealthDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthlyHealthDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>
          }
          findMany: {
            args: Prisma.MonthlyHealthDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>[]
          }
          create: {
            args: Prisma.MonthlyHealthDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>
          }
          createMany: {
            args: Prisma.MonthlyHealthDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthlyHealthDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>[]
          }
          delete: {
            args: Prisma.MonthlyHealthDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>
          }
          update: {
            args: Prisma.MonthlyHealthDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>
          }
          deleteMany: {
            args: Prisma.MonthlyHealthDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthlyHealthDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonthlyHealthDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>[]
          }
          upsert: {
            args: Prisma.MonthlyHealthDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyHealthDataPayload>
          }
          aggregate: {
            args: Prisma.MonthlyHealthDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthlyHealthData>
          }
          groupBy: {
            args: Prisma.MonthlyHealthDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthlyHealthDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthlyHealthDataCountArgs<ExtArgs>
            result: $Utils.Optional<MonthlyHealthDataCountAggregateOutputType> | number
          }
        }
      }
      DataUploadSession: {
        payload: Prisma.$DataUploadSessionPayload<ExtArgs>
        fields: Prisma.DataUploadSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataUploadSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataUploadSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>
          }
          findFirst: {
            args: Prisma.DataUploadSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataUploadSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>
          }
          findMany: {
            args: Prisma.DataUploadSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>[]
          }
          create: {
            args: Prisma.DataUploadSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>
          }
          createMany: {
            args: Prisma.DataUploadSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataUploadSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>[]
          }
          delete: {
            args: Prisma.DataUploadSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>
          }
          update: {
            args: Prisma.DataUploadSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>
          }
          deleteMany: {
            args: Prisma.DataUploadSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataUploadSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataUploadSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>[]
          }
          upsert: {
            args: Prisma.DataUploadSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataUploadSessionPayload>
          }
          aggregate: {
            args: Prisma.DataUploadSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataUploadSession>
          }
          groupBy: {
            args: Prisma.DataUploadSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataUploadSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataUploadSessionCountArgs<ExtArgs>
            result: $Utils.Optional<DataUploadSessionCountAggregateOutputType> | number
          }
        }
      }
      Formula: {
        payload: Prisma.$FormulaPayload<ExtArgs>
        fields: Prisma.FormulaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormulaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormulaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>
          }
          findFirst: {
            args: Prisma.FormulaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormulaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>
          }
          findMany: {
            args: Prisma.FormulaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>[]
          }
          create: {
            args: Prisma.FormulaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>
          }
          createMany: {
            args: Prisma.FormulaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormulaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>[]
          }
          delete: {
            args: Prisma.FormulaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>
          }
          update: {
            args: Prisma.FormulaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>
          }
          deleteMany: {
            args: Prisma.FormulaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormulaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormulaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>[]
          }
          upsert: {
            args: Prisma.FormulaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormulaPayload>
          }
          aggregate: {
            args: Prisma.FormulaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormula>
          }
          groupBy: {
            args: Prisma.FormulaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormulaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormulaCountArgs<ExtArgs>
            result: $Utils.Optional<FormulaCountAggregateOutputType> | number
          }
        }
      }
      Indicator: {
        payload: Prisma.$IndicatorPayload<ExtArgs>
        fields: Prisma.IndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findFirst: {
            args: Prisma.IndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          findMany: {
            args: Prisma.IndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          create: {
            args: Prisma.IndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          createMany: {
            args: Prisma.IndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          delete: {
            args: Prisma.IndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          update: {
            args: Prisma.IndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndicatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>[]
          }
          upsert: {
            args: Prisma.IndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorPayload>
          }
          aggregate: {
            args: Prisma.IndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicator>
          }
          groupBy: {
            args: Prisma.IndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorCountAggregateOutputType> | number
          }
        }
      }
      Field: {
        payload: Prisma.$FieldPayload<ExtArgs>
        fields: Prisma.FieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findFirst: {
            args: Prisma.FieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          findMany: {
            args: Prisma.FieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          create: {
            args: Prisma.FieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          createMany: {
            args: Prisma.FieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          delete: {
            args: Prisma.FieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          update: {
            args: Prisma.FieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          deleteMany: {
            args: Prisma.FieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>[]
          }
          upsert: {
            args: Prisma.FieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldPayload>
          }
          aggregate: {
            args: Prisma.FieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateField>
          }
          groupBy: {
            args: Prisma.FieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldCountArgs<ExtArgs>
            result: $Utils.Optional<FieldCountAggregateOutputType> | number
          }
        }
      }
      FieldValue: {
        payload: Prisma.$FieldValuePayload<ExtArgs>
        fields: Prisma.FieldValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FieldValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FieldValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>
          }
          findFirst: {
            args: Prisma.FieldValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FieldValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>
          }
          findMany: {
            args: Prisma.FieldValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>[]
          }
          create: {
            args: Prisma.FieldValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>
          }
          createMany: {
            args: Prisma.FieldValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FieldValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>[]
          }
          delete: {
            args: Prisma.FieldValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>
          }
          update: {
            args: Prisma.FieldValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>
          }
          deleteMany: {
            args: Prisma.FieldValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FieldValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FieldValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>[]
          }
          upsert: {
            args: Prisma.FieldValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FieldValuePayload>
          }
          aggregate: {
            args: Prisma.FieldValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFieldValue>
          }
          groupBy: {
            args: Prisma.FieldValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.FieldValueCountArgs<ExtArgs>
            result: $Utils.Optional<FieldValueCountAggregateOutputType> | number
          }
        }
      }
      FacilityFieldDefaults: {
        payload: Prisma.$FacilityFieldDefaultsPayload<ExtArgs>
        fields: Prisma.FacilityFieldDefaultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFieldDefaultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFieldDefaultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>
          }
          findFirst: {
            args: Prisma.FacilityFieldDefaultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFieldDefaultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>
          }
          findMany: {
            args: Prisma.FacilityFieldDefaultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>[]
          }
          create: {
            args: Prisma.FacilityFieldDefaultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>
          }
          createMany: {
            args: Prisma.FacilityFieldDefaultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityFieldDefaultsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>[]
          }
          delete: {
            args: Prisma.FacilityFieldDefaultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>
          }
          update: {
            args: Prisma.FacilityFieldDefaultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>
          }
          deleteMany: {
            args: Prisma.FacilityFieldDefaultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityFieldDefaultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityFieldDefaultsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>[]
          }
          upsert: {
            args: Prisma.FacilityFieldDefaultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldDefaultsPayload>
          }
          aggregate: {
            args: Prisma.FacilityFieldDefaultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityFieldDefaults>
          }
          groupBy: {
            args: Prisma.FacilityFieldDefaultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityFieldDefaultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityFieldDefaultsCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityFieldDefaultsCountAggregateOutputType> | number
          }
        }
      }
      FacilityFieldMapping: {
        payload: Prisma.$FacilityFieldMappingPayload<ExtArgs>
        fields: Prisma.FacilityFieldMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFieldMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFieldMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>
          }
          findFirst: {
            args: Prisma.FacilityFieldMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFieldMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>
          }
          findMany: {
            args: Prisma.FacilityFieldMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>[]
          }
          create: {
            args: Prisma.FacilityFieldMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>
          }
          createMany: {
            args: Prisma.FacilityFieldMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityFieldMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>[]
          }
          delete: {
            args: Prisma.FacilityFieldMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>
          }
          update: {
            args: Prisma.FacilityFieldMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>
          }
          deleteMany: {
            args: Prisma.FacilityFieldMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityFieldMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityFieldMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>[]
          }
          upsert: {
            args: Prisma.FacilityFieldMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityFieldMappingPayload>
          }
          aggregate: {
            args: Prisma.FacilityFieldMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityFieldMapping>
          }
          groupBy: {
            args: Prisma.FacilityFieldMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityFieldMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityFieldMappingCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityFieldMappingCountAggregateOutputType> | number
          }
        }
      }
      sub_centre: {
        payload: Prisma.$sub_centrePayload<ExtArgs>
        fields: Prisma.sub_centreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sub_centreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sub_centreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>
          }
          findFirst: {
            args: Prisma.sub_centreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sub_centreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>
          }
          findMany: {
            args: Prisma.sub_centreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>[]
          }
          create: {
            args: Prisma.sub_centreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>
          }
          createMany: {
            args: Prisma.sub_centreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sub_centreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>[]
          }
          delete: {
            args: Prisma.sub_centreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>
          }
          update: {
            args: Prisma.sub_centreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>
          }
          deleteMany: {
            args: Prisma.sub_centreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sub_centreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sub_centreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>[]
          }
          upsert: {
            args: Prisma.sub_centreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sub_centrePayload>
          }
          aggregate: {
            args: Prisma.Sub_centreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSub_centre>
          }
          groupBy: {
            args: Prisma.sub_centreGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sub_centreGroupByOutputType>[]
          }
          count: {
            args: Prisma.sub_centreCountArgs<ExtArgs>
            result: $Utils.Optional<Sub_centreCountAggregateOutputType> | number
          }
        }
      }
      HealthWorker: {
        payload: Prisma.$HealthWorkerPayload<ExtArgs>
        fields: Prisma.HealthWorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthWorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthWorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          findFirst: {
            args: Prisma.HealthWorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthWorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          findMany: {
            args: Prisma.HealthWorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>[]
          }
          create: {
            args: Prisma.HealthWorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          createMany: {
            args: Prisma.HealthWorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthWorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>[]
          }
          delete: {
            args: Prisma.HealthWorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          update: {
            args: Prisma.HealthWorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          deleteMany: {
            args: Prisma.HealthWorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthWorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HealthWorkerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>[]
          }
          upsert: {
            args: Prisma.HealthWorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          aggregate: {
            args: Prisma.HealthWorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthWorker>
          }
          groupBy: {
            args: Prisma.HealthWorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthWorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthWorkerCountArgs<ExtArgs>
            result: $Utils.Optional<HealthWorkerCountAggregateOutputType> | number
          }
        }
      }
      RemunerationCalculation: {
        payload: Prisma.$RemunerationCalculationPayload<ExtArgs>
        fields: Prisma.RemunerationCalculationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemunerationCalculationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemunerationCalculationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>
          }
          findFirst: {
            args: Prisma.RemunerationCalculationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemunerationCalculationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>
          }
          findMany: {
            args: Prisma.RemunerationCalculationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>[]
          }
          create: {
            args: Prisma.RemunerationCalculationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>
          }
          createMany: {
            args: Prisma.RemunerationCalculationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RemunerationCalculationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>[]
          }
          delete: {
            args: Prisma.RemunerationCalculationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>
          }
          update: {
            args: Prisma.RemunerationCalculationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>
          }
          deleteMany: {
            args: Prisma.RemunerationCalculationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemunerationCalculationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RemunerationCalculationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>[]
          }
          upsert: {
            args: Prisma.RemunerationCalculationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemunerationCalculationPayload>
          }
          aggregate: {
            args: Prisma.RemunerationCalculationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemunerationCalculation>
          }
          groupBy: {
            args: Prisma.RemunerationCalculationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemunerationCalculationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemunerationCalculationCountArgs<ExtArgs>
            result: $Utils.Optional<RemunerationCalculationCountAggregateOutputType> | number
          }
        }
      }
      WorkerRemuneration: {
        payload: Prisma.$WorkerRemunerationPayload<ExtArgs>
        fields: Prisma.WorkerRemunerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerRemunerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerRemunerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>
          }
          findFirst: {
            args: Prisma.WorkerRemunerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerRemunerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>
          }
          findMany: {
            args: Prisma.WorkerRemunerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>[]
          }
          create: {
            args: Prisma.WorkerRemunerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>
          }
          createMany: {
            args: Prisma.WorkerRemunerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerRemunerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>[]
          }
          delete: {
            args: Prisma.WorkerRemunerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>
          }
          update: {
            args: Prisma.WorkerRemunerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>
          }
          deleteMany: {
            args: Prisma.WorkerRemunerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerRemunerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerRemunerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>[]
          }
          upsert: {
            args: Prisma.WorkerRemunerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerRemunerationPayload>
          }
          aggregate: {
            args: Prisma.WorkerRemunerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerRemuneration>
          }
          groupBy: {
            args: Prisma.WorkerRemunerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerRemunerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerRemunerationCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerRemunerationCountAggregateOutputType> | number
          }
        }
      }
      WorkerAllocationConfig: {
        payload: Prisma.$WorkerAllocationConfigPayload<ExtArgs>
        fields: Prisma.WorkerAllocationConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerAllocationConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerAllocationConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>
          }
          findFirst: {
            args: Prisma.WorkerAllocationConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerAllocationConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>
          }
          findMany: {
            args: Prisma.WorkerAllocationConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>[]
          }
          create: {
            args: Prisma.WorkerAllocationConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>
          }
          createMany: {
            args: Prisma.WorkerAllocationConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerAllocationConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>[]
          }
          delete: {
            args: Prisma.WorkerAllocationConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>
          }
          update: {
            args: Prisma.WorkerAllocationConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>
          }
          deleteMany: {
            args: Prisma.WorkerAllocationConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerAllocationConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerAllocationConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>[]
          }
          upsert: {
            args: Prisma.WorkerAllocationConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerAllocationConfigPayload>
          }
          aggregate: {
            args: Prisma.WorkerAllocationConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkerAllocationConfig>
          }
          groupBy: {
            args: Prisma.WorkerAllocationConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerAllocationConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerAllocationConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerAllocationConfigCountAggregateOutputType> | number
          }
        }
      }
      FacilityWorkerAllocation: {
        payload: Prisma.$FacilityWorkerAllocationPayload<ExtArgs>
        fields: Prisma.FacilityWorkerAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityWorkerAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityWorkerAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>
          }
          findFirst: {
            args: Prisma.FacilityWorkerAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityWorkerAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>
          }
          findMany: {
            args: Prisma.FacilityWorkerAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>[]
          }
          create: {
            args: Prisma.FacilityWorkerAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>
          }
          createMany: {
            args: Prisma.FacilityWorkerAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityWorkerAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>[]
          }
          delete: {
            args: Prisma.FacilityWorkerAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>
          }
          update: {
            args: Prisma.FacilityWorkerAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>
          }
          deleteMany: {
            args: Prisma.FacilityWorkerAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityWorkerAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityWorkerAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>[]
          }
          upsert: {
            args: Prisma.FacilityWorkerAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityWorkerAllocationPayload>
          }
          aggregate: {
            args: Prisma.FacilityWorkerAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityWorkerAllocation>
          }
          groupBy: {
            args: Prisma.FacilityWorkerAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityWorkerAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityWorkerAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityWorkerAllocationCountAggregateOutputType> | number
          }
        }
      }
      FacilityTypeRemuneration: {
        payload: Prisma.$FacilityTypeRemunerationPayload<ExtArgs>
        fields: Prisma.FacilityTypeRemunerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityTypeRemunerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityTypeRemunerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>
          }
          findFirst: {
            args: Prisma.FacilityTypeRemunerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityTypeRemunerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>
          }
          findMany: {
            args: Prisma.FacilityTypeRemunerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>[]
          }
          create: {
            args: Prisma.FacilityTypeRemunerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>
          }
          createMany: {
            args: Prisma.FacilityTypeRemunerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityTypeRemunerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>[]
          }
          delete: {
            args: Prisma.FacilityTypeRemunerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>
          }
          update: {
            args: Prisma.FacilityTypeRemunerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>
          }
          deleteMany: {
            args: Prisma.FacilityTypeRemunerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityTypeRemunerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityTypeRemunerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>[]
          }
          upsert: {
            args: Prisma.FacilityTypeRemunerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTypeRemunerationPayload>
          }
          aggregate: {
            args: Prisma.FacilityTypeRemunerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityTypeRemuneration>
          }
          groupBy: {
            args: Prisma.FacilityTypeRemunerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityTypeRemunerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityTypeRemunerationCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityTypeRemunerationCountAggregateOutputType> | number
          }
        }
      }
      IndicatorRemuneration: {
        payload: Prisma.$IndicatorRemunerationPayload<ExtArgs>
        fields: Prisma.IndicatorRemunerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorRemunerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorRemunerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>
          }
          findFirst: {
            args: Prisma.IndicatorRemunerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorRemunerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>
          }
          findMany: {
            args: Prisma.IndicatorRemunerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>[]
          }
          create: {
            args: Prisma.IndicatorRemunerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>
          }
          createMany: {
            args: Prisma.IndicatorRemunerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorRemunerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>[]
          }
          delete: {
            args: Prisma.IndicatorRemunerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>
          }
          update: {
            args: Prisma.IndicatorRemunerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorRemunerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorRemunerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndicatorRemunerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>[]
          }
          upsert: {
            args: Prisma.IndicatorRemunerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorRemunerationPayload>
          }
          aggregate: {
            args: Prisma.IndicatorRemunerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicatorRemuneration>
          }
          groupBy: {
            args: Prisma.IndicatorRemunerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorRemunerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorRemunerationCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorRemunerationCountAggregateOutputType> | number
          }
        }
      }
      PerformanceCalculation: {
        payload: Prisma.$PerformanceCalculationPayload<ExtArgs>
        fields: Prisma.PerformanceCalculationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceCalculationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceCalculationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>
          }
          findFirst: {
            args: Prisma.PerformanceCalculationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceCalculationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>
          }
          findMany: {
            args: Prisma.PerformanceCalculationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>[]
          }
          create: {
            args: Prisma.PerformanceCalculationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>
          }
          createMany: {
            args: Prisma.PerformanceCalculationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceCalculationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>[]
          }
          delete: {
            args: Prisma.PerformanceCalculationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>
          }
          update: {
            args: Prisma.PerformanceCalculationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceCalculationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceCalculationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceCalculationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceCalculationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceCalculationPayload>
          }
          aggregate: {
            args: Prisma.PerformanceCalculationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceCalculation>
          }
          groupBy: {
            args: Prisma.PerformanceCalculationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceCalculationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceCalculationCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceCalculationCountAggregateOutputType> | number
          }
        }
      }
      FacilityTarget: {
        payload: Prisma.$FacilityTargetPayload<ExtArgs>
        fields: Prisma.FacilityTargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityTargetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityTargetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>
          }
          findFirst: {
            args: Prisma.FacilityTargetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityTargetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>
          }
          findMany: {
            args: Prisma.FacilityTargetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>[]
          }
          create: {
            args: Prisma.FacilityTargetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>
          }
          createMany: {
            args: Prisma.FacilityTargetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityTargetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>[]
          }
          delete: {
            args: Prisma.FacilityTargetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>
          }
          update: {
            args: Prisma.FacilityTargetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>
          }
          deleteMany: {
            args: Prisma.FacilityTargetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityTargetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityTargetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>[]
          }
          upsert: {
            args: Prisma.FacilityTargetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityTargetPayload>
          }
          aggregate: {
            args: Prisma.FacilityTargetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityTarget>
          }
          groupBy: {
            args: Prisma.FacilityTargetGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityTargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityTargetCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityTargetCountAggregateOutputType> | number
          }
        }
      }
      IndicatorWorkerAllocation: {
        payload: Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>
        fields: Prisma.IndicatorWorkerAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicatorWorkerAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicatorWorkerAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>
          }
          findFirst: {
            args: Prisma.IndicatorWorkerAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicatorWorkerAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>
          }
          findMany: {
            args: Prisma.IndicatorWorkerAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>[]
          }
          create: {
            args: Prisma.IndicatorWorkerAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>
          }
          createMany: {
            args: Prisma.IndicatorWorkerAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicatorWorkerAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>[]
          }
          delete: {
            args: Prisma.IndicatorWorkerAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>
          }
          update: {
            args: Prisma.IndicatorWorkerAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>
          }
          deleteMany: {
            args: Prisma.IndicatorWorkerAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicatorWorkerAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndicatorWorkerAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>[]
          }
          upsert: {
            args: Prisma.IndicatorWorkerAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicatorWorkerAllocationPayload>
          }
          aggregate: {
            args: Prisma.IndicatorWorkerAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicatorWorkerAllocation>
          }
          groupBy: {
            args: Prisma.IndicatorWorkerAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicatorWorkerAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicatorWorkerAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<IndicatorWorkerAllocationCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    district?: DistrictOmit
    remunerationSystem?: RemunerationSystemOmit
    facilityType?: FacilityTypeOmit
    facility?: FacilityOmit
    monthlyHealthData?: MonthlyHealthDataOmit
    dataUploadSession?: DataUploadSessionOmit
    formula?: FormulaOmit
    indicator?: IndicatorOmit
    field?: FieldOmit
    fieldValue?: FieldValueOmit
    facilityFieldDefaults?: FacilityFieldDefaultsOmit
    facilityFieldMapping?: FacilityFieldMappingOmit
    sub_centre?: sub_centreOmit
    healthWorker?: HealthWorkerOmit
    remunerationCalculation?: RemunerationCalculationOmit
    workerRemuneration?: WorkerRemunerationOmit
    workerAllocationConfig?: WorkerAllocationConfigOmit
    facilityWorkerAllocation?: FacilityWorkerAllocationOmit
    facilityTypeRemuneration?: FacilityTypeRemunerationOmit
    indicatorRemuneration?: IndicatorRemunerationOmit
    performanceCalculation?: PerformanceCalculationOmit
    facilityTarget?: FacilityTargetOmit
    indicatorWorkerAllocation?: IndicatorWorkerAllocationOmit
    systemSetting?: SystemSettingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    upload_sessions: number
    field_values: number
    approved_data: number
    uploaded_data: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload_sessions?: boolean | UserCountOutputTypeCountUpload_sessionsArgs
    field_values?: boolean | UserCountOutputTypeCountField_valuesArgs
    approved_data?: boolean | UserCountOutputTypeCountApproved_dataArgs
    uploaded_data?: boolean | UserCountOutputTypeCountUploaded_dataArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpload_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataUploadSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountField_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldValueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApproved_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploaded_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    facilities: number
    monthly_data: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | DistrictCountOutputTypeCountFacilitiesArgs
    monthly_data?: boolean | DistrictCountOutputTypeCountMonthly_dataArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountMonthly_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
  }


  /**
   * Count Type RemunerationSystemCountOutputType
   */

  export type RemunerationSystemCountOutputType = {
    indicator_remunerations: number
  }

  export type RemunerationSystemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator_remunerations?: boolean | RemunerationSystemCountOutputTypeCountIndicator_remunerationsArgs
  }

  // Custom InputTypes
  /**
   * RemunerationSystemCountOutputType without action
   */
  export type RemunerationSystemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystemCountOutputType
     */
    select?: RemunerationSystemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RemunerationSystemCountOutputType without action
   */
  export type RemunerationSystemCountOutputTypeCountIndicator_remunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorRemunerationWhereInput
  }


  /**
   * Count Type FacilityTypeCountOutputType
   */

  export type FacilityTypeCountOutputType = {
    facilities: number
    field_mappings: number
    worker_allocations: number
  }

  export type FacilityTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | FacilityTypeCountOutputTypeCountFacilitiesArgs
    field_mappings?: boolean | FacilityTypeCountOutputTypeCountField_mappingsArgs
    worker_allocations?: boolean | FacilityTypeCountOutputTypeCountWorker_allocationsArgs
  }

  // Custom InputTypes
  /**
   * FacilityTypeCountOutputType without action
   */
  export type FacilityTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeCountOutputType
     */
    select?: FacilityTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityTypeCountOutputType without action
   */
  export type FacilityTypeCountOutputTypeCountFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
  }

  /**
   * FacilityTypeCountOutputType without action
   */
  export type FacilityTypeCountOutputTypeCountField_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityFieldMappingWhereInput
  }

  /**
   * FacilityTypeCountOutputType without action
   */
  export type FacilityTypeCountOutputTypeCountWorker_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerAllocationConfigWhereInput
  }


  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    facility_field_defaults: number
    facility_targets: number
    worker_allocations: number
    field_values: number
    health_workers: number
    monthly_data: number
    performance_calculations: number
    remuneration_calculations: number
    sub_centres: number
    users: number
  }

  export type FacilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_field_defaults?: boolean | FacilityCountOutputTypeCountFacility_field_defaultsArgs
    facility_targets?: boolean | FacilityCountOutputTypeCountFacility_targetsArgs
    worker_allocations?: boolean | FacilityCountOutputTypeCountWorker_allocationsArgs
    field_values?: boolean | FacilityCountOutputTypeCountField_valuesArgs
    health_workers?: boolean | FacilityCountOutputTypeCountHealth_workersArgs
    monthly_data?: boolean | FacilityCountOutputTypeCountMonthly_dataArgs
    performance_calculations?: boolean | FacilityCountOutputTypeCountPerformance_calculationsArgs
    remuneration_calculations?: boolean | FacilityCountOutputTypeCountRemuneration_calculationsArgs
    sub_centres?: boolean | FacilityCountOutputTypeCountSub_centresArgs
    users?: boolean | FacilityCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountFacility_field_defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityFieldDefaultsWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountFacility_targetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityTargetWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountWorker_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWorkerAllocationWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountField_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldValueWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountHealth_workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthWorkerWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountMonthly_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountPerformance_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceCalculationWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountRemuneration_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemunerationCalculationWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountSub_centresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_centreWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type IndicatorCountOutputType
   */

  export type IndicatorCountOutputType = {
    facility_targets: number
    remunerations: number
    worker_allocations: number
    monthly_data: number
    performance_calculations: number
  }

  export type IndicatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_targets?: boolean | IndicatorCountOutputTypeCountFacility_targetsArgs
    remunerations?: boolean | IndicatorCountOutputTypeCountRemunerationsArgs
    worker_allocations?: boolean | IndicatorCountOutputTypeCountWorker_allocationsArgs
    monthly_data?: boolean | IndicatorCountOutputTypeCountMonthly_dataArgs
    performance_calculations?: boolean | IndicatorCountOutputTypeCountPerformance_calculationsArgs
  }

  // Custom InputTypes
  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorCountOutputType
     */
    select?: IndicatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountFacility_targetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityTargetWhereInput
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountRemunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorRemunerationWhereInput
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountWorker_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWorkerAllocationWhereInput
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountMonthly_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
  }

  /**
   * IndicatorCountOutputType without action
   */
  export type IndicatorCountOutputTypeCountPerformance_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceCalculationWhereInput
  }


  /**
   * Count Type FieldCountOutputType
   */

  export type FieldCountOutputType = {
    facility_field_defaults: number
    facility_field_mappings: number
    field_values: number
    denominator_for_indicators: number
    numerator_for_indicators: number
    target_for_indicators: number
  }

  export type FieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_field_defaults?: boolean | FieldCountOutputTypeCountFacility_field_defaultsArgs
    facility_field_mappings?: boolean | FieldCountOutputTypeCountFacility_field_mappingsArgs
    field_values?: boolean | FieldCountOutputTypeCountField_valuesArgs
    denominator_for_indicators?: boolean | FieldCountOutputTypeCountDenominator_for_indicatorsArgs
    numerator_for_indicators?: boolean | FieldCountOutputTypeCountNumerator_for_indicatorsArgs
    target_for_indicators?: boolean | FieldCountOutputTypeCountTarget_for_indicatorsArgs
  }

  // Custom InputTypes
  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldCountOutputType
     */
    select?: FieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFacility_field_defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityFieldDefaultsWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountFacility_field_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityFieldMappingWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountField_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldValueWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountDenominator_for_indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountNumerator_for_indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
  }

  /**
   * FieldCountOutputType without action
   */
  export type FieldCountOutputTypeCountTarget_for_indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
  }


  /**
   * Count Type Sub_centreCountOutputType
   */

  export type Sub_centreCountOutputType = {
    monthly_health_data: number
    performance_calculations: number
  }

  export type Sub_centreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthly_health_data?: boolean | Sub_centreCountOutputTypeCountMonthly_health_dataArgs
    performance_calculations?: boolean | Sub_centreCountOutputTypeCountPerformance_calculationsArgs
  }

  // Custom InputTypes
  /**
   * Sub_centreCountOutputType without action
   */
  export type Sub_centreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_centreCountOutputType
     */
    select?: Sub_centreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Sub_centreCountOutputType without action
   */
  export type Sub_centreCountOutputTypeCountMonthly_health_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
  }

  /**
   * Sub_centreCountOutputType without action
   */
  export type Sub_centreCountOutputTypeCountPerformance_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceCalculationWhereInput
  }


  /**
   * Count Type HealthWorkerCountOutputType
   */

  export type HealthWorkerCountOutputType = {
    remuneration_calculations: number
  }

  export type HealthWorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    remuneration_calculations?: boolean | HealthWorkerCountOutputTypeCountRemuneration_calculationsArgs
  }

  // Custom InputTypes
  /**
   * HealthWorkerCountOutputType without action
   */
  export type HealthWorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorkerCountOutputType
     */
    select?: HealthWorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthWorkerCountOutputType without action
   */
  export type HealthWorkerCountOutputTypeCountRemuneration_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerRemunerationWhereInput
  }


  /**
   * Count Type WorkerAllocationConfigCountOutputType
   */

  export type WorkerAllocationConfigCountOutputType = {
    facility_allocations: number
  }

  export type WorkerAllocationConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_allocations?: boolean | WorkerAllocationConfigCountOutputTypeCountFacility_allocationsArgs
  }

  // Custom InputTypes
  /**
   * WorkerAllocationConfigCountOutputType without action
   */
  export type WorkerAllocationConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfigCountOutputType
     */
    select?: WorkerAllocationConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerAllocationConfigCountOutputType without action
   */
  export type WorkerAllocationConfigCountOutputTypeCountFacility_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWorkerAllocationWhereInput
  }


  /**
   * Count Type FacilityTypeRemunerationCountOutputType
   */

  export type FacilityTypeRemunerationCountOutputType = {
    indicator_remunerations: number
  }

  export type FacilityTypeRemunerationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator_remunerations?: boolean | FacilityTypeRemunerationCountOutputTypeCountIndicator_remunerationsArgs
  }

  // Custom InputTypes
  /**
   * FacilityTypeRemunerationCountOutputType without action
   */
  export type FacilityTypeRemunerationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemunerationCountOutputType
     */
    select?: FacilityTypeRemunerationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityTypeRemunerationCountOutputType without action
   */
  export type FacilityTypeRemunerationCountOutputTypeCountIndicator_remunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorRemunerationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password_hash: string | null
    role: $Enums.UserRole | null
    is_active: boolean | null
    last_login: Date | null
    created_at: Date | null
    email: string | null
    facility_id: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password_hash: string | null
    role: $Enums.UserRole | null
    is_active: boolean | null
    last_login: Date | null
    created_at: Date | null
    email: string | null
    facility_id: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password_hash: number
    role: number
    is_active: number
    last_login: number
    created_at: number
    email: number
    facility_id: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    created_at?: true
    email?: true
    facility_id?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    created_at?: true
    email?: true
    facility_id?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    role?: true
    is_active?: true
    last_login?: true
    created_at?: true
    email?: true
    facility_id?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password_hash: string
    role: $Enums.UserRole
    is_active: boolean | null
    last_login: Date | null
    created_at: Date | null
    email: string | null
    facility_id: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
    facility_id?: boolean
    upload_sessions?: boolean | User$upload_sessionsArgs<ExtArgs>
    field_values?: boolean | User$field_valuesArgs<ExtArgs>
    approved_data?: boolean | User$approved_dataArgs<ExtArgs>
    uploaded_data?: boolean | User$uploaded_dataArgs<ExtArgs>
    facility?: boolean | User$facilityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
    facility_id?: boolean
    facility?: boolean | User$facilityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
    facility_id?: boolean
    facility?: boolean | User$facilityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password_hash?: boolean
    role?: boolean
    is_active?: boolean
    last_login?: boolean
    created_at?: boolean
    email?: boolean
    facility_id?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password_hash" | "role" | "is_active" | "last_login" | "created_at" | "email" | "facility_id", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upload_sessions?: boolean | User$upload_sessionsArgs<ExtArgs>
    field_values?: boolean | User$field_valuesArgs<ExtArgs>
    approved_data?: boolean | User$approved_dataArgs<ExtArgs>
    uploaded_data?: boolean | User$uploaded_dataArgs<ExtArgs>
    facility?: boolean | User$facilityArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | User$facilityArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | User$facilityArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      upload_sessions: Prisma.$DataUploadSessionPayload<ExtArgs>[]
      field_values: Prisma.$FieldValuePayload<ExtArgs>[]
      approved_data: Prisma.$MonthlyHealthDataPayload<ExtArgs>[]
      uploaded_data: Prisma.$MonthlyHealthDataPayload<ExtArgs>[]
      facility: Prisma.$FacilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password_hash: string
      role: $Enums.UserRole
      is_active: boolean | null
      last_login: Date | null
      created_at: Date | null
      email: string | null
      facility_id: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    upload_sessions<T extends User$upload_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$upload_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    field_values<T extends User$field_valuesArgs<ExtArgs> = {}>(args?: Subset<T, User$field_valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approved_data<T extends User$approved_dataArgs<ExtArgs> = {}>(args?: Subset<T, User$approved_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploaded_data<T extends User$uploaded_dataArgs<ExtArgs> = {}>(args?: Subset<T, User$uploaded_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facility<T extends User$facilityArgs<ExtArgs> = {}>(args?: Subset<T, User$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly last_login: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly facility_id: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.upload_sessions
   */
  export type User$upload_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    where?: DataUploadSessionWhereInput
    orderBy?: DataUploadSessionOrderByWithRelationInput | DataUploadSessionOrderByWithRelationInput[]
    cursor?: DataUploadSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataUploadSessionScalarFieldEnum | DataUploadSessionScalarFieldEnum[]
  }

  /**
   * User.field_values
   */
  export type User$field_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    where?: FieldValueWhereInput
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    cursor?: FieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldValueScalarFieldEnum | FieldValueScalarFieldEnum[]
  }

  /**
   * User.approved_data
   */
  export type User$approved_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    cursor?: MonthlyHealthDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * User.uploaded_data
   */
  export type User$uploaded_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    cursor?: MonthlyHealthDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * User.facility
   */
  export type User$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DistrictMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    updated_at: Date
    _count: DistrictCountAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    facilities?: boolean | District$facilitiesArgs<ExtArgs>
    monthly_data?: boolean | District$monthly_dataArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["district"]>

  export type DistrictSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DistrictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "updated_at", ExtArgs["result"]["district"]>
  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | District$facilitiesArgs<ExtArgs>
    monthly_data?: boolean | District$monthly_dataArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DistrictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      facilities: Prisma.$FacilityPayload<ExtArgs>[]
      monthly_data: Prisma.$MonthlyHealthDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["district"]>
    composites: {}
  }

  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistrictFindUniqueArgs>(args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistrictFindFirstArgs>(args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistrictFindManyArgs>(args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
     */
    create<T extends DistrictCreateArgs>(args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Districts.
     * @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistrictCreateManyArgs>(args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Districts and returns the data saved in the database.
     * @param {DistrictCreateManyAndReturnArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, DistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
     */
    delete<T extends DistrictDeleteArgs>(args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistrictUpdateArgs>(args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistrictDeleteManyArgs>(args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistrictUpdateManyArgs>(args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts and returns the data updated in the database.
     * @param {DistrictUpdateManyAndReturnArgs} args - Arguments to update many Districts.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Districts and only return the `id`
     * const districtWithIdOnly = await prisma.district.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DistrictUpdateManyAndReturnArgs>(args: SelectSubset<T, DistrictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
     */
    upsert<T extends DistrictUpsertArgs>(args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facilities<T extends District$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, District$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthly_data<T extends District$monthly_dataArgs<ExtArgs> = {}>(args?: Subset<T, District$monthly_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the District model
   */
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'String'>
    readonly name: FieldRef<"District", 'String'>
    readonly created_at: FieldRef<"District", 'DateTime'>
    readonly updated_at: FieldRef<"District", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District createManyAndReturn
   */
  export type DistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to update.
     */
    limit?: number
  }

  /**
   * District updateManyAndReturn
   */
  export type DistrictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to update.
     */
    limit?: number
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
    /**
     * Limit how many Districts to delete.
     */
    limit?: number
  }

  /**
   * District.facilities
   */
  export type District$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * District.monthly_data
   */
  export type District$monthly_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    cursor?: MonthlyHealthDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the District
     */
    omit?: DistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model RemunerationSystem
   */

  export type AggregateRemunerationSystem = {
    _count: RemunerationSystemCountAggregateOutputType | null
    _min: RemunerationSystemMinAggregateOutputType | null
    _max: RemunerationSystemMaxAggregateOutputType | null
  }

  export type RemunerationSystemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RemunerationSystemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RemunerationSystemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RemunerationSystemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type RemunerationSystemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type RemunerationSystemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RemunerationSystemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemunerationSystem to aggregate.
     */
    where?: RemunerationSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationSystems to fetch.
     */
    orderBy?: RemunerationSystemOrderByWithRelationInput | RemunerationSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemunerationSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RemunerationSystems
    **/
    _count?: true | RemunerationSystemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemunerationSystemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemunerationSystemMaxAggregateInputType
  }

  export type GetRemunerationSystemAggregateType<T extends RemunerationSystemAggregateArgs> = {
        [P in keyof T & keyof AggregateRemunerationSystem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemunerationSystem[P]>
      : GetScalarType<T[P], AggregateRemunerationSystem[P]>
  }




  export type RemunerationSystemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemunerationSystemWhereInput
    orderBy?: RemunerationSystemOrderByWithAggregationInput | RemunerationSystemOrderByWithAggregationInput[]
    by: RemunerationSystemScalarFieldEnum[] | RemunerationSystemScalarFieldEnum
    having?: RemunerationSystemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemunerationSystemCountAggregateInputType | true
    _min?: RemunerationSystemMinAggregateInputType
    _max?: RemunerationSystemMaxAggregateInputType
  }

  export type RemunerationSystemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: RemunerationSystemCountAggregateOutputType | null
    _min: RemunerationSystemMinAggregateOutputType | null
    _max: RemunerationSystemMaxAggregateOutputType | null
  }

  type GetRemunerationSystemGroupByPayload<T extends RemunerationSystemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemunerationSystemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemunerationSystemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemunerationSystemGroupByOutputType[P]>
            : GetScalarType<T[P], RemunerationSystemGroupByOutputType[P]>
        }
      >
    >


  export type RemunerationSystemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    indicator_remunerations?: boolean | RemunerationSystem$indicator_remunerationsArgs<ExtArgs>
    _count?: boolean | RemunerationSystemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remunerationSystem"]>

  export type RemunerationSystemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["remunerationSystem"]>

  export type RemunerationSystemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["remunerationSystem"]>

  export type RemunerationSystemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RemunerationSystemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["remunerationSystem"]>
  export type RemunerationSystemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator_remunerations?: boolean | RemunerationSystem$indicator_remunerationsArgs<ExtArgs>
    _count?: boolean | RemunerationSystemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RemunerationSystemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RemunerationSystemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RemunerationSystemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RemunerationSystem"
    objects: {
      indicator_remunerations: Prisma.$IndicatorRemunerationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["remunerationSystem"]>
    composites: {}
  }

  type RemunerationSystemGetPayload<S extends boolean | null | undefined | RemunerationSystemDefaultArgs> = $Result.GetResult<Prisma.$RemunerationSystemPayload, S>

  type RemunerationSystemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RemunerationSystemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemunerationSystemCountAggregateInputType | true
    }

  export interface RemunerationSystemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RemunerationSystem'], meta: { name: 'RemunerationSystem' } }
    /**
     * Find zero or one RemunerationSystem that matches the filter.
     * @param {RemunerationSystemFindUniqueArgs} args - Arguments to find a RemunerationSystem
     * @example
     * // Get one RemunerationSystem
     * const remunerationSystem = await prisma.remunerationSystem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemunerationSystemFindUniqueArgs>(args: SelectSubset<T, RemunerationSystemFindUniqueArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RemunerationSystem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RemunerationSystemFindUniqueOrThrowArgs} args - Arguments to find a RemunerationSystem
     * @example
     * // Get one RemunerationSystem
     * const remunerationSystem = await prisma.remunerationSystem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemunerationSystemFindUniqueOrThrowArgs>(args: SelectSubset<T, RemunerationSystemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemunerationSystem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemFindFirstArgs} args - Arguments to find a RemunerationSystem
     * @example
     * // Get one RemunerationSystem
     * const remunerationSystem = await prisma.remunerationSystem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemunerationSystemFindFirstArgs>(args?: SelectSubset<T, RemunerationSystemFindFirstArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemunerationSystem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemFindFirstOrThrowArgs} args - Arguments to find a RemunerationSystem
     * @example
     * // Get one RemunerationSystem
     * const remunerationSystem = await prisma.remunerationSystem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemunerationSystemFindFirstOrThrowArgs>(args?: SelectSubset<T, RemunerationSystemFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RemunerationSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RemunerationSystems
     * const remunerationSystems = await prisma.remunerationSystem.findMany()
     * 
     * // Get first 10 RemunerationSystems
     * const remunerationSystems = await prisma.remunerationSystem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remunerationSystemWithIdOnly = await prisma.remunerationSystem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RemunerationSystemFindManyArgs>(args?: SelectSubset<T, RemunerationSystemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RemunerationSystem.
     * @param {RemunerationSystemCreateArgs} args - Arguments to create a RemunerationSystem.
     * @example
     * // Create one RemunerationSystem
     * const RemunerationSystem = await prisma.remunerationSystem.create({
     *   data: {
     *     // ... data to create a RemunerationSystem
     *   }
     * })
     * 
     */
    create<T extends RemunerationSystemCreateArgs>(args: SelectSubset<T, RemunerationSystemCreateArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RemunerationSystems.
     * @param {RemunerationSystemCreateManyArgs} args - Arguments to create many RemunerationSystems.
     * @example
     * // Create many RemunerationSystems
     * const remunerationSystem = await prisma.remunerationSystem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemunerationSystemCreateManyArgs>(args?: SelectSubset<T, RemunerationSystemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RemunerationSystems and returns the data saved in the database.
     * @param {RemunerationSystemCreateManyAndReturnArgs} args - Arguments to create many RemunerationSystems.
     * @example
     * // Create many RemunerationSystems
     * const remunerationSystem = await prisma.remunerationSystem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RemunerationSystems and only return the `id`
     * const remunerationSystemWithIdOnly = await prisma.remunerationSystem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RemunerationSystemCreateManyAndReturnArgs>(args?: SelectSubset<T, RemunerationSystemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RemunerationSystem.
     * @param {RemunerationSystemDeleteArgs} args - Arguments to delete one RemunerationSystem.
     * @example
     * // Delete one RemunerationSystem
     * const RemunerationSystem = await prisma.remunerationSystem.delete({
     *   where: {
     *     // ... filter to delete one RemunerationSystem
     *   }
     * })
     * 
     */
    delete<T extends RemunerationSystemDeleteArgs>(args: SelectSubset<T, RemunerationSystemDeleteArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RemunerationSystem.
     * @param {RemunerationSystemUpdateArgs} args - Arguments to update one RemunerationSystem.
     * @example
     * // Update one RemunerationSystem
     * const remunerationSystem = await prisma.remunerationSystem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemunerationSystemUpdateArgs>(args: SelectSubset<T, RemunerationSystemUpdateArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RemunerationSystems.
     * @param {RemunerationSystemDeleteManyArgs} args - Arguments to filter RemunerationSystems to delete.
     * @example
     * // Delete a few RemunerationSystems
     * const { count } = await prisma.remunerationSystem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemunerationSystemDeleteManyArgs>(args?: SelectSubset<T, RemunerationSystemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemunerationSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RemunerationSystems
     * const remunerationSystem = await prisma.remunerationSystem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemunerationSystemUpdateManyArgs>(args: SelectSubset<T, RemunerationSystemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemunerationSystems and returns the data updated in the database.
     * @param {RemunerationSystemUpdateManyAndReturnArgs} args - Arguments to update many RemunerationSystems.
     * @example
     * // Update many RemunerationSystems
     * const remunerationSystem = await prisma.remunerationSystem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RemunerationSystems and only return the `id`
     * const remunerationSystemWithIdOnly = await prisma.remunerationSystem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RemunerationSystemUpdateManyAndReturnArgs>(args: SelectSubset<T, RemunerationSystemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RemunerationSystem.
     * @param {RemunerationSystemUpsertArgs} args - Arguments to update or create a RemunerationSystem.
     * @example
     * // Update or create a RemunerationSystem
     * const remunerationSystem = await prisma.remunerationSystem.upsert({
     *   create: {
     *     // ... data to create a RemunerationSystem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RemunerationSystem we want to update
     *   }
     * })
     */
    upsert<T extends RemunerationSystemUpsertArgs>(args: SelectSubset<T, RemunerationSystemUpsertArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RemunerationSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemCountArgs} args - Arguments to filter RemunerationSystems to count.
     * @example
     * // Count the number of RemunerationSystems
     * const count = await prisma.remunerationSystem.count({
     *   where: {
     *     // ... the filter for the RemunerationSystems we want to count
     *   }
     * })
    **/
    count<T extends RemunerationSystemCountArgs>(
      args?: Subset<T, RemunerationSystemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemunerationSystemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RemunerationSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemunerationSystemAggregateArgs>(args: Subset<T, RemunerationSystemAggregateArgs>): Prisma.PrismaPromise<GetRemunerationSystemAggregateType<T>>

    /**
     * Group by RemunerationSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationSystemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemunerationSystemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemunerationSystemGroupByArgs['orderBy'] }
        : { orderBy?: RemunerationSystemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemunerationSystemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemunerationSystemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RemunerationSystem model
   */
  readonly fields: RemunerationSystemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RemunerationSystem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemunerationSystemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicator_remunerations<T extends RemunerationSystem$indicator_remunerationsArgs<ExtArgs> = {}>(args?: Subset<T, RemunerationSystem$indicator_remunerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RemunerationSystem model
   */
  interface RemunerationSystemFieldRefs {
    readonly id: FieldRef<"RemunerationSystem", 'String'>
    readonly name: FieldRef<"RemunerationSystem", 'String'>
    readonly description: FieldRef<"RemunerationSystem", 'String'>
    readonly is_active: FieldRef<"RemunerationSystem", 'Boolean'>
    readonly created_at: FieldRef<"RemunerationSystem", 'DateTime'>
    readonly updated_at: FieldRef<"RemunerationSystem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RemunerationSystem findUnique
   */
  export type RemunerationSystemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationSystem to fetch.
     */
    where: RemunerationSystemWhereUniqueInput
  }

  /**
   * RemunerationSystem findUniqueOrThrow
   */
  export type RemunerationSystemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationSystem to fetch.
     */
    where: RemunerationSystemWhereUniqueInput
  }

  /**
   * RemunerationSystem findFirst
   */
  export type RemunerationSystemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationSystem to fetch.
     */
    where?: RemunerationSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationSystems to fetch.
     */
    orderBy?: RemunerationSystemOrderByWithRelationInput | RemunerationSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemunerationSystems.
     */
    cursor?: RemunerationSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemunerationSystems.
     */
    distinct?: RemunerationSystemScalarFieldEnum | RemunerationSystemScalarFieldEnum[]
  }

  /**
   * RemunerationSystem findFirstOrThrow
   */
  export type RemunerationSystemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationSystem to fetch.
     */
    where?: RemunerationSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationSystems to fetch.
     */
    orderBy?: RemunerationSystemOrderByWithRelationInput | RemunerationSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemunerationSystems.
     */
    cursor?: RemunerationSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemunerationSystems.
     */
    distinct?: RemunerationSystemScalarFieldEnum | RemunerationSystemScalarFieldEnum[]
  }

  /**
   * RemunerationSystem findMany
   */
  export type RemunerationSystemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationSystems to fetch.
     */
    where?: RemunerationSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationSystems to fetch.
     */
    orderBy?: RemunerationSystemOrderByWithRelationInput | RemunerationSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RemunerationSystems.
     */
    cursor?: RemunerationSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationSystems.
     */
    skip?: number
    distinct?: RemunerationSystemScalarFieldEnum | RemunerationSystemScalarFieldEnum[]
  }

  /**
   * RemunerationSystem create
   */
  export type RemunerationSystemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * The data needed to create a RemunerationSystem.
     */
    data: XOR<RemunerationSystemCreateInput, RemunerationSystemUncheckedCreateInput>
  }

  /**
   * RemunerationSystem createMany
   */
  export type RemunerationSystemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RemunerationSystems.
     */
    data: RemunerationSystemCreateManyInput | RemunerationSystemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemunerationSystem createManyAndReturn
   */
  export type RemunerationSystemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * The data used to create many RemunerationSystems.
     */
    data: RemunerationSystemCreateManyInput | RemunerationSystemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemunerationSystem update
   */
  export type RemunerationSystemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * The data needed to update a RemunerationSystem.
     */
    data: XOR<RemunerationSystemUpdateInput, RemunerationSystemUncheckedUpdateInput>
    /**
     * Choose, which RemunerationSystem to update.
     */
    where: RemunerationSystemWhereUniqueInput
  }

  /**
   * RemunerationSystem updateMany
   */
  export type RemunerationSystemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RemunerationSystems.
     */
    data: XOR<RemunerationSystemUpdateManyMutationInput, RemunerationSystemUncheckedUpdateManyInput>
    /**
     * Filter which RemunerationSystems to update
     */
    where?: RemunerationSystemWhereInput
    /**
     * Limit how many RemunerationSystems to update.
     */
    limit?: number
  }

  /**
   * RemunerationSystem updateManyAndReturn
   */
  export type RemunerationSystemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * The data used to update RemunerationSystems.
     */
    data: XOR<RemunerationSystemUpdateManyMutationInput, RemunerationSystemUncheckedUpdateManyInput>
    /**
     * Filter which RemunerationSystems to update
     */
    where?: RemunerationSystemWhereInput
    /**
     * Limit how many RemunerationSystems to update.
     */
    limit?: number
  }

  /**
   * RemunerationSystem upsert
   */
  export type RemunerationSystemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * The filter to search for the RemunerationSystem to update in case it exists.
     */
    where: RemunerationSystemWhereUniqueInput
    /**
     * In case the RemunerationSystem found by the `where` argument doesn't exist, create a new RemunerationSystem with this data.
     */
    create: XOR<RemunerationSystemCreateInput, RemunerationSystemUncheckedCreateInput>
    /**
     * In case the RemunerationSystem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemunerationSystemUpdateInput, RemunerationSystemUncheckedUpdateInput>
  }

  /**
   * RemunerationSystem delete
   */
  export type RemunerationSystemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    /**
     * Filter which RemunerationSystem to delete.
     */
    where: RemunerationSystemWhereUniqueInput
  }

  /**
   * RemunerationSystem deleteMany
   */
  export type RemunerationSystemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemunerationSystems to delete
     */
    where?: RemunerationSystemWhereInput
    /**
     * Limit how many RemunerationSystems to delete.
     */
    limit?: number
  }

  /**
   * RemunerationSystem.indicator_remunerations
   */
  export type RemunerationSystem$indicator_remunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    where?: IndicatorRemunerationWhereInput
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    cursor?: IndicatorRemunerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorRemunerationScalarFieldEnum | IndicatorRemunerationScalarFieldEnum[]
  }

  /**
   * RemunerationSystem without action
   */
  export type RemunerationSystemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
  }


  /**
   * Model FacilityType
   */

  export type AggregateFacilityType = {
    _count: FacilityTypeCountAggregateOutputType | null
    _min: FacilityTypeMinAggregateOutputType | null
    _max: FacilityTypeMaxAggregateOutputType | null
  }

  export type FacilityTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    description: string | null
    display_name: string | null
    is_active: boolean | null
    updated_at: Date | null
  }

  export type FacilityTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    description: string | null
    display_name: string | null
    is_active: boolean | null
    updated_at: Date | null
  }

  export type FacilityTypeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    description: number
    display_name: number
    is_active: number
    updated_at: number
    _all: number
  }


  export type FacilityTypeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    description?: true
    display_name?: true
    is_active?: true
    updated_at?: true
  }

  export type FacilityTypeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    description?: true
    display_name?: true
    is_active?: true
    updated_at?: true
  }

  export type FacilityTypeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    description?: true
    display_name?: true
    is_active?: true
    updated_at?: true
    _all?: true
  }

  export type FacilityTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityType to aggregate.
     */
    where?: FacilityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypes to fetch.
     */
    orderBy?: FacilityTypeOrderByWithRelationInput | FacilityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityTypes
    **/
    _count?: true | FacilityTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityTypeMaxAggregateInputType
  }

  export type GetFacilityTypeAggregateType<T extends FacilityTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityType[P]>
      : GetScalarType<T[P], AggregateFacilityType[P]>
  }




  export type FacilityTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityTypeWhereInput
    orderBy?: FacilityTypeOrderByWithAggregationInput | FacilityTypeOrderByWithAggregationInput[]
    by: FacilityTypeScalarFieldEnum[] | FacilityTypeScalarFieldEnum
    having?: FacilityTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityTypeCountAggregateInputType | true
    _min?: FacilityTypeMinAggregateInputType
    _max?: FacilityTypeMaxAggregateInputType
  }

  export type FacilityTypeGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    description: string | null
    display_name: string
    is_active: boolean
    updated_at: Date
    _count: FacilityTypeCountAggregateOutputType | null
    _min: FacilityTypeMinAggregateOutputType | null
    _max: FacilityTypeMaxAggregateOutputType | null
  }

  type GetFacilityTypeGroupByPayload<T extends FacilityTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityTypeGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityTypeGroupByOutputType[P]>
        }
      >
    >


  export type FacilityTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    is_active?: boolean
    updated_at?: boolean
    facilities?: boolean | FacilityType$facilitiesArgs<ExtArgs>
    field_mappings?: boolean | FacilityType$field_mappingsArgs<ExtArgs>
    remunerations?: boolean | FacilityType$remunerationsArgs<ExtArgs>
    worker_allocations?: boolean | FacilityType$worker_allocationsArgs<ExtArgs>
    _count?: boolean | FacilityTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityType"]>

  export type FacilityTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    is_active?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["facilityType"]>

  export type FacilityTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    is_active?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["facilityType"]>

  export type FacilityTypeSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    is_active?: boolean
    updated_at?: boolean
  }

  export type FacilityTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "description" | "display_name" | "is_active" | "updated_at", ExtArgs["result"]["facilityType"]>
  export type FacilityTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilities?: boolean | FacilityType$facilitiesArgs<ExtArgs>
    field_mappings?: boolean | FacilityType$field_mappingsArgs<ExtArgs>
    remunerations?: boolean | FacilityType$remunerationsArgs<ExtArgs>
    worker_allocations?: boolean | FacilityType$worker_allocationsArgs<ExtArgs>
    _count?: boolean | FacilityTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FacilityTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FacilityTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityType"
    objects: {
      facilities: Prisma.$FacilityPayload<ExtArgs>[]
      field_mappings: Prisma.$FacilityFieldMappingPayload<ExtArgs>[]
      remunerations: Prisma.$FacilityTypeRemunerationPayload<ExtArgs> | null
      worker_allocations: Prisma.$WorkerAllocationConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      description: string | null
      display_name: string
      is_active: boolean
      updated_at: Date
    }, ExtArgs["result"]["facilityType"]>
    composites: {}
  }

  type FacilityTypeGetPayload<S extends boolean | null | undefined | FacilityTypeDefaultArgs> = $Result.GetResult<Prisma.$FacilityTypePayload, S>

  type FacilityTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityTypeCountAggregateInputType | true
    }

  export interface FacilityTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityType'], meta: { name: 'FacilityType' } }
    /**
     * Find zero or one FacilityType that matches the filter.
     * @param {FacilityTypeFindUniqueArgs} args - Arguments to find a FacilityType
     * @example
     * // Get one FacilityType
     * const facilityType = await prisma.facilityType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityTypeFindUniqueArgs>(args: SelectSubset<T, FacilityTypeFindUniqueArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacilityType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityTypeFindUniqueOrThrowArgs} args - Arguments to find a FacilityType
     * @example
     * // Get one FacilityType
     * const facilityType = await prisma.facilityType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeFindFirstArgs} args - Arguments to find a FacilityType
     * @example
     * // Get one FacilityType
     * const facilityType = await prisma.facilityType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityTypeFindFirstArgs>(args?: SelectSubset<T, FacilityTypeFindFirstArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeFindFirstOrThrowArgs} args - Arguments to find a FacilityType
     * @example
     * // Get one FacilityType
     * const facilityType = await prisma.facilityType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacilityTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityTypes
     * const facilityTypes = await prisma.facilityType.findMany()
     * 
     * // Get first 10 FacilityTypes
     * const facilityTypes = await prisma.facilityType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityTypeWithIdOnly = await prisma.facilityType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityTypeFindManyArgs>(args?: SelectSubset<T, FacilityTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacilityType.
     * @param {FacilityTypeCreateArgs} args - Arguments to create a FacilityType.
     * @example
     * // Create one FacilityType
     * const FacilityType = await prisma.facilityType.create({
     *   data: {
     *     // ... data to create a FacilityType
     *   }
     * })
     * 
     */
    create<T extends FacilityTypeCreateArgs>(args: SelectSubset<T, FacilityTypeCreateArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacilityTypes.
     * @param {FacilityTypeCreateManyArgs} args - Arguments to create many FacilityTypes.
     * @example
     * // Create many FacilityTypes
     * const facilityType = await prisma.facilityType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityTypeCreateManyArgs>(args?: SelectSubset<T, FacilityTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityTypes and returns the data saved in the database.
     * @param {FacilityTypeCreateManyAndReturnArgs} args - Arguments to create many FacilityTypes.
     * @example
     * // Create many FacilityTypes
     * const facilityType = await prisma.facilityType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityTypes and only return the `id`
     * const facilityTypeWithIdOnly = await prisma.facilityType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacilityType.
     * @param {FacilityTypeDeleteArgs} args - Arguments to delete one FacilityType.
     * @example
     * // Delete one FacilityType
     * const FacilityType = await prisma.facilityType.delete({
     *   where: {
     *     // ... filter to delete one FacilityType
     *   }
     * })
     * 
     */
    delete<T extends FacilityTypeDeleteArgs>(args: SelectSubset<T, FacilityTypeDeleteArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacilityType.
     * @param {FacilityTypeUpdateArgs} args - Arguments to update one FacilityType.
     * @example
     * // Update one FacilityType
     * const facilityType = await prisma.facilityType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityTypeUpdateArgs>(args: SelectSubset<T, FacilityTypeUpdateArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacilityTypes.
     * @param {FacilityTypeDeleteManyArgs} args - Arguments to filter FacilityTypes to delete.
     * @example
     * // Delete a few FacilityTypes
     * const { count } = await prisma.facilityType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityTypeDeleteManyArgs>(args?: SelectSubset<T, FacilityTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityTypes
     * const facilityType = await prisma.facilityType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityTypeUpdateManyArgs>(args: SelectSubset<T, FacilityTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityTypes and returns the data updated in the database.
     * @param {FacilityTypeUpdateManyAndReturnArgs} args - Arguments to update many FacilityTypes.
     * @example
     * // Update many FacilityTypes
     * const facilityType = await prisma.facilityType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacilityTypes and only return the `id`
     * const facilityTypeWithIdOnly = await prisma.facilityType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacilityType.
     * @param {FacilityTypeUpsertArgs} args - Arguments to update or create a FacilityType.
     * @example
     * // Update or create a FacilityType
     * const facilityType = await prisma.facilityType.upsert({
     *   create: {
     *     // ... data to create a FacilityType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityType we want to update
     *   }
     * })
     */
    upsert<T extends FacilityTypeUpsertArgs>(args: SelectSubset<T, FacilityTypeUpsertArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacilityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeCountArgs} args - Arguments to filter FacilityTypes to count.
     * @example
     * // Count the number of FacilityTypes
     * const count = await prisma.facilityType.count({
     *   where: {
     *     // ... the filter for the FacilityTypes we want to count
     *   }
     * })
    **/
    count<T extends FacilityTypeCountArgs>(
      args?: Subset<T, FacilityTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityTypeAggregateArgs>(args: Subset<T, FacilityTypeAggregateArgs>): Prisma.PrismaPromise<GetFacilityTypeAggregateType<T>>

    /**
     * Group by FacilityType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityTypeGroupByArgs['orderBy'] }
        : { orderBy?: FacilityTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityType model
   */
  readonly fields: FacilityTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facilities<T extends FacilityType$facilitiesArgs<ExtArgs> = {}>(args?: Subset<T, FacilityType$facilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    field_mappings<T extends FacilityType$field_mappingsArgs<ExtArgs> = {}>(args?: Subset<T, FacilityType$field_mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    remunerations<T extends FacilityType$remunerationsArgs<ExtArgs> = {}>(args?: Subset<T, FacilityType$remunerationsArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker_allocations<T extends FacilityType$worker_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, FacilityType$worker_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityType model
   */
  interface FacilityTypeFieldRefs {
    readonly id: FieldRef<"FacilityType", 'String'>
    readonly name: FieldRef<"FacilityType", 'String'>
    readonly created_at: FieldRef<"FacilityType", 'DateTime'>
    readonly description: FieldRef<"FacilityType", 'String'>
    readonly display_name: FieldRef<"FacilityType", 'String'>
    readonly is_active: FieldRef<"FacilityType", 'Boolean'>
    readonly updated_at: FieldRef<"FacilityType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacilityType findUnique
   */
  export type FacilityTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * Filter, which FacilityType to fetch.
     */
    where: FacilityTypeWhereUniqueInput
  }

  /**
   * FacilityType findUniqueOrThrow
   */
  export type FacilityTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * Filter, which FacilityType to fetch.
     */
    where: FacilityTypeWhereUniqueInput
  }

  /**
   * FacilityType findFirst
   */
  export type FacilityTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * Filter, which FacilityType to fetch.
     */
    where?: FacilityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypes to fetch.
     */
    orderBy?: FacilityTypeOrderByWithRelationInput | FacilityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityTypes.
     */
    cursor?: FacilityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityTypes.
     */
    distinct?: FacilityTypeScalarFieldEnum | FacilityTypeScalarFieldEnum[]
  }

  /**
   * FacilityType findFirstOrThrow
   */
  export type FacilityTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * Filter, which FacilityType to fetch.
     */
    where?: FacilityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypes to fetch.
     */
    orderBy?: FacilityTypeOrderByWithRelationInput | FacilityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityTypes.
     */
    cursor?: FacilityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityTypes.
     */
    distinct?: FacilityTypeScalarFieldEnum | FacilityTypeScalarFieldEnum[]
  }

  /**
   * FacilityType findMany
   */
  export type FacilityTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTypes to fetch.
     */
    where?: FacilityTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypes to fetch.
     */
    orderBy?: FacilityTypeOrderByWithRelationInput | FacilityTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityTypes.
     */
    cursor?: FacilityTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypes.
     */
    skip?: number
    distinct?: FacilityTypeScalarFieldEnum | FacilityTypeScalarFieldEnum[]
  }

  /**
   * FacilityType create
   */
  export type FacilityTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityType.
     */
    data: XOR<FacilityTypeCreateInput, FacilityTypeUncheckedCreateInput>
  }

  /**
   * FacilityType createMany
   */
  export type FacilityTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityTypes.
     */
    data: FacilityTypeCreateManyInput | FacilityTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityType createManyAndReturn
   */
  export type FacilityTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * The data used to create many FacilityTypes.
     */
    data: FacilityTypeCreateManyInput | FacilityTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityType update
   */
  export type FacilityTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityType.
     */
    data: XOR<FacilityTypeUpdateInput, FacilityTypeUncheckedUpdateInput>
    /**
     * Choose, which FacilityType to update.
     */
    where: FacilityTypeWhereUniqueInput
  }

  /**
   * FacilityType updateMany
   */
  export type FacilityTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityTypes.
     */
    data: XOR<FacilityTypeUpdateManyMutationInput, FacilityTypeUncheckedUpdateManyInput>
    /**
     * Filter which FacilityTypes to update
     */
    where?: FacilityTypeWhereInput
    /**
     * Limit how many FacilityTypes to update.
     */
    limit?: number
  }

  /**
   * FacilityType updateManyAndReturn
   */
  export type FacilityTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * The data used to update FacilityTypes.
     */
    data: XOR<FacilityTypeUpdateManyMutationInput, FacilityTypeUncheckedUpdateManyInput>
    /**
     * Filter which FacilityTypes to update
     */
    where?: FacilityTypeWhereInput
    /**
     * Limit how many FacilityTypes to update.
     */
    limit?: number
  }

  /**
   * FacilityType upsert
   */
  export type FacilityTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityType to update in case it exists.
     */
    where: FacilityTypeWhereUniqueInput
    /**
     * In case the FacilityType found by the `where` argument doesn't exist, create a new FacilityType with this data.
     */
    create: XOR<FacilityTypeCreateInput, FacilityTypeUncheckedCreateInput>
    /**
     * In case the FacilityType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityTypeUpdateInput, FacilityTypeUncheckedUpdateInput>
  }

  /**
   * FacilityType delete
   */
  export type FacilityTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
    /**
     * Filter which FacilityType to delete.
     */
    where: FacilityTypeWhereUniqueInput
  }

  /**
   * FacilityType deleteMany
   */
  export type FacilityTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityTypes to delete
     */
    where?: FacilityTypeWhereInput
    /**
     * Limit how many FacilityTypes to delete.
     */
    limit?: number
  }

  /**
   * FacilityType.facilities
   */
  export type FacilityType$facilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    cursor?: FacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * FacilityType.field_mappings
   */
  export type FacilityType$field_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    where?: FacilityFieldMappingWhereInput
    orderBy?: FacilityFieldMappingOrderByWithRelationInput | FacilityFieldMappingOrderByWithRelationInput[]
    cursor?: FacilityFieldMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityFieldMappingScalarFieldEnum | FacilityFieldMappingScalarFieldEnum[]
  }

  /**
   * FacilityType.remunerations
   */
  export type FacilityType$remunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    where?: FacilityTypeRemunerationWhereInput
  }

  /**
   * FacilityType.worker_allocations
   */
  export type FacilityType$worker_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    where?: WorkerAllocationConfigWhereInput
    orderBy?: WorkerAllocationConfigOrderByWithRelationInput | WorkerAllocationConfigOrderByWithRelationInput[]
    cursor?: WorkerAllocationConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerAllocationConfigScalarFieldEnum | WorkerAllocationConfigScalarFieldEnum[]
  }

  /**
   * FacilityType without action
   */
  export type FacilityTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityType
     */
    select?: FacilityTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityType
     */
    omit?: FacilityTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    description: string | null
    display_name: string | null
    district_id: string | null
    facility_type_id: string | null
    is_active: boolean | null
    updated_at: Date | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    description: string | null
    display_name: string | null
    district_id: string | null
    facility_type_id: string | null
    is_active: boolean | null
    updated_at: Date | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    description: number
    display_name: number
    district_id: number
    facility_type_id: number
    is_active: number
    updated_at: number
    _all: number
  }


  export type FacilityMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    description?: true
    display_name?: true
    district_id?: true
    facility_type_id?: true
    is_active?: true
    updated_at?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    description?: true
    display_name?: true
    district_id?: true
    facility_type_id?: true
    is_active?: true
    updated_at?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    description?: true
    display_name?: true
    district_id?: true
    facility_type_id?: true
    is_active?: true
    updated_at?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    description: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active: boolean
    updated_at: Date
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    district_id?: boolean
    facility_type_id?: boolean
    is_active?: boolean
    updated_at?: boolean
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    facility_field_defaults?: boolean | Facility$facility_field_defaultsArgs<ExtArgs>
    facility_targets?: boolean | Facility$facility_targetsArgs<ExtArgs>
    worker_allocations?: boolean | Facility$worker_allocationsArgs<ExtArgs>
    field_values?: boolean | Facility$field_valuesArgs<ExtArgs>
    health_workers?: boolean | Facility$health_workersArgs<ExtArgs>
    monthly_data?: boolean | Facility$monthly_dataArgs<ExtArgs>
    performance_calculations?: boolean | Facility$performance_calculationsArgs<ExtArgs>
    remuneration_calculations?: boolean | Facility$remuneration_calculationsArgs<ExtArgs>
    sub_centres?: boolean | Facility$sub_centresArgs<ExtArgs>
    users?: boolean | Facility$usersArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    district_id?: boolean
    facility_type_id?: boolean
    is_active?: boolean
    updated_at?: boolean
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    district_id?: boolean
    facility_type_id?: boolean
    is_active?: boolean
    updated_at?: boolean
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    description?: boolean
    display_name?: boolean
    district_id?: boolean
    facility_type_id?: boolean
    is_active?: boolean
    updated_at?: boolean
  }

  export type FacilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "description" | "display_name" | "district_id" | "facility_type_id" | "is_active" | "updated_at", ExtArgs["result"]["facility"]>
  export type FacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    facility_field_defaults?: boolean | Facility$facility_field_defaultsArgs<ExtArgs>
    facility_targets?: boolean | Facility$facility_targetsArgs<ExtArgs>
    worker_allocations?: boolean | Facility$worker_allocationsArgs<ExtArgs>
    field_values?: boolean | Facility$field_valuesArgs<ExtArgs>
    health_workers?: boolean | Facility$health_workersArgs<ExtArgs>
    monthly_data?: boolean | Facility$monthly_dataArgs<ExtArgs>
    performance_calculations?: boolean | Facility$performance_calculationsArgs<ExtArgs>
    remuneration_calculations?: boolean | Facility$remuneration_calculationsArgs<ExtArgs>
    sub_centres?: boolean | Facility$sub_centresArgs<ExtArgs>
    users?: boolean | Facility$usersArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }
  export type FacilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }

  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {
      district: Prisma.$DistrictPayload<ExtArgs>
      facility_type: Prisma.$FacilityTypePayload<ExtArgs>
      facility_field_defaults: Prisma.$FacilityFieldDefaultsPayload<ExtArgs>[]
      facility_targets: Prisma.$FacilityTargetPayload<ExtArgs>[]
      worker_allocations: Prisma.$FacilityWorkerAllocationPayload<ExtArgs>[]
      field_values: Prisma.$FieldValuePayload<ExtArgs>[]
      health_workers: Prisma.$HealthWorkerPayload<ExtArgs>[]
      monthly_data: Prisma.$MonthlyHealthDataPayload<ExtArgs>[]
      performance_calculations: Prisma.$PerformanceCalculationPayload<ExtArgs>[]
      remuneration_calculations: Prisma.$RemunerationCalculationPayload<ExtArgs>[]
      sub_centres: Prisma.$sub_centrePayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      description: string | null
      display_name: string
      district_id: string
      facility_type_id: string
      is_active: boolean
      updated_at: Date
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }

  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityFindManyArgs>(args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
     */
    create<T extends FacilityCreateArgs>(args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCreateManyArgs>(args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
     */
    delete<T extends FacilityDeleteArgs>(args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityUpdateArgs>(args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityDeleteManyArgs>(args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityUpdateManyArgs>(args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities and returns the data updated in the database.
     * @param {FacilityUpdateManyAndReturnArgs} args - Arguments to update many Facilities.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Facilities and only return the `id`
     * const facilityWithIdOnly = await prisma.facility.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    district<T extends DistrictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistrictDefaultArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    facility_type<T extends FacilityTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityTypeDefaultArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    facility_field_defaults<T extends Facility$facility_field_defaultsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$facility_field_defaultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facility_targets<T extends Facility$facility_targetsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$facility_targetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    worker_allocations<T extends Facility$worker_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$worker_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    field_values<T extends Facility$field_valuesArgs<ExtArgs> = {}>(args?: Subset<T, Facility$field_valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    health_workers<T extends Facility$health_workersArgs<ExtArgs> = {}>(args?: Subset<T, Facility$health_workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthly_data<T extends Facility$monthly_dataArgs<ExtArgs> = {}>(args?: Subset<T, Facility$monthly_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performance_calculations<T extends Facility$performance_calculationsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$performance_calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    remuneration_calculations<T extends Facility$remuneration_calculationsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$remuneration_calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sub_centres<T extends Facility$sub_centresArgs<ExtArgs> = {}>(args?: Subset<T, Facility$sub_centresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Facility$usersArgs<ExtArgs> = {}>(args?: Subset<T, Facility$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facility model
   */
  interface FacilityFieldRefs {
    readonly id: FieldRef<"Facility", 'String'>
    readonly name: FieldRef<"Facility", 'String'>
    readonly created_at: FieldRef<"Facility", 'DateTime'>
    readonly description: FieldRef<"Facility", 'String'>
    readonly display_name: FieldRef<"Facility", 'String'>
    readonly district_id: FieldRef<"Facility", 'String'>
    readonly facility_type_id: FieldRef<"Facility", 'String'>
    readonly is_active: FieldRef<"Facility", 'Boolean'>
    readonly updated_at: FieldRef<"Facility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
  }

  /**
   * Facility updateManyAndReturn
   */
  export type FacilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to delete.
     */
    limit?: number
  }

  /**
   * Facility.facility_field_defaults
   */
  export type Facility$facility_field_defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    where?: FacilityFieldDefaultsWhereInput
    orderBy?: FacilityFieldDefaultsOrderByWithRelationInput | FacilityFieldDefaultsOrderByWithRelationInput[]
    cursor?: FacilityFieldDefaultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityFieldDefaultsScalarFieldEnum | FacilityFieldDefaultsScalarFieldEnum[]
  }

  /**
   * Facility.facility_targets
   */
  export type Facility$facility_targetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    where?: FacilityTargetWhereInput
    orderBy?: FacilityTargetOrderByWithRelationInput | FacilityTargetOrderByWithRelationInput[]
    cursor?: FacilityTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityTargetScalarFieldEnum | FacilityTargetScalarFieldEnum[]
  }

  /**
   * Facility.worker_allocations
   */
  export type Facility$worker_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    where?: FacilityWorkerAllocationWhereInput
    orderBy?: FacilityWorkerAllocationOrderByWithRelationInput | FacilityWorkerAllocationOrderByWithRelationInput[]
    cursor?: FacilityWorkerAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityWorkerAllocationScalarFieldEnum | FacilityWorkerAllocationScalarFieldEnum[]
  }

  /**
   * Facility.field_values
   */
  export type Facility$field_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    where?: FieldValueWhereInput
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    cursor?: FieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldValueScalarFieldEnum | FieldValueScalarFieldEnum[]
  }

  /**
   * Facility.health_workers
   */
  export type Facility$health_workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    where?: HealthWorkerWhereInput
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    cursor?: HealthWorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * Facility.monthly_data
   */
  export type Facility$monthly_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    cursor?: MonthlyHealthDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * Facility.performance_calculations
   */
  export type Facility$performance_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    where?: PerformanceCalculationWhereInput
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    cursor?: PerformanceCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceCalculationScalarFieldEnum | PerformanceCalculationScalarFieldEnum[]
  }

  /**
   * Facility.remuneration_calculations
   */
  export type Facility$remuneration_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    where?: RemunerationCalculationWhereInput
    orderBy?: RemunerationCalculationOrderByWithRelationInput | RemunerationCalculationOrderByWithRelationInput[]
    cursor?: RemunerationCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemunerationCalculationScalarFieldEnum | RemunerationCalculationScalarFieldEnum[]
  }

  /**
   * Facility.sub_centres
   */
  export type Facility$sub_centresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    where?: sub_centreWhereInput
    orderBy?: sub_centreOrderByWithRelationInput | sub_centreOrderByWithRelationInput[]
    cursor?: sub_centreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sub_centreScalarFieldEnum | Sub_centreScalarFieldEnum[]
  }

  /**
   * Facility.users
   */
  export type Facility$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
  }


  /**
   * Model MonthlyHealthData
   */

  export type AggregateMonthlyHealthData = {
    _count: MonthlyHealthDataCountAggregateOutputType | null
    _avg: MonthlyHealthDataAvgAggregateOutputType | null
    _sum: MonthlyHealthDataSumAggregateOutputType | null
    _min: MonthlyHealthDataMinAggregateOutputType | null
    _max: MonthlyHealthDataMaxAggregateOutputType | null
  }

  export type MonthlyHealthDataAvgAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    value: Decimal | null
    uploaded_by: number | null
    approved_by: number | null
    achievement: Decimal | null
    denominator: Decimal | null
    numerator: Decimal | null
    target_value: Decimal | null
    indicator_id: number | null
  }

  export type MonthlyHealthDataSumAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    value: Decimal | null
    uploaded_by: number | null
    approved_by: number | null
    achievement: Decimal | null
    denominator: Decimal | null
    numerator: Decimal | null
    target_value: Decimal | null
    indicator_id: number | null
  }

  export type MonthlyHealthDataMinAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    report_month: string | null
    value: Decimal | null
    data_quality: $Enums.DataQuality | null
    remarks: string | null
    uploaded_by: number | null
    approved_by: number | null
    approved_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    achievement: Decimal | null
    denominator: Decimal | null
    numerator: Decimal | null
    target_value: Decimal | null
    indicator_id: number | null
    district_id: string | null
    facility_id: string | null
  }

  export type MonthlyHealthDataMaxAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    report_month: string | null
    value: Decimal | null
    data_quality: $Enums.DataQuality | null
    remarks: string | null
    uploaded_by: number | null
    approved_by: number | null
    approved_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    achievement: Decimal | null
    denominator: Decimal | null
    numerator: Decimal | null
    target_value: Decimal | null
    indicator_id: number | null
    district_id: string | null
    facility_id: string | null
  }

  export type MonthlyHealthDataCountAggregateOutputType = {
    id: number
    sub_centre_id: number
    report_month: number
    value: number
    data_quality: number
    remarks: number
    uploaded_by: number
    approved_by: number
    approved_at: number
    created_at: number
    updated_at: number
    achievement: number
    denominator: number
    numerator: number
    target_value: number
    indicator_id: number
    district_id: number
    facility_id: number
    _all: number
  }


  export type MonthlyHealthDataAvgAggregateInputType = {
    id?: true
    sub_centre_id?: true
    value?: true
    uploaded_by?: true
    approved_by?: true
    achievement?: true
    denominator?: true
    numerator?: true
    target_value?: true
    indicator_id?: true
  }

  export type MonthlyHealthDataSumAggregateInputType = {
    id?: true
    sub_centre_id?: true
    value?: true
    uploaded_by?: true
    approved_by?: true
    achievement?: true
    denominator?: true
    numerator?: true
    target_value?: true
    indicator_id?: true
  }

  export type MonthlyHealthDataMinAggregateInputType = {
    id?: true
    sub_centre_id?: true
    report_month?: true
    value?: true
    data_quality?: true
    remarks?: true
    uploaded_by?: true
    approved_by?: true
    approved_at?: true
    created_at?: true
    updated_at?: true
    achievement?: true
    denominator?: true
    numerator?: true
    target_value?: true
    indicator_id?: true
    district_id?: true
    facility_id?: true
  }

  export type MonthlyHealthDataMaxAggregateInputType = {
    id?: true
    sub_centre_id?: true
    report_month?: true
    value?: true
    data_quality?: true
    remarks?: true
    uploaded_by?: true
    approved_by?: true
    approved_at?: true
    created_at?: true
    updated_at?: true
    achievement?: true
    denominator?: true
    numerator?: true
    target_value?: true
    indicator_id?: true
    district_id?: true
    facility_id?: true
  }

  export type MonthlyHealthDataCountAggregateInputType = {
    id?: true
    sub_centre_id?: true
    report_month?: true
    value?: true
    data_quality?: true
    remarks?: true
    uploaded_by?: true
    approved_by?: true
    approved_at?: true
    created_at?: true
    updated_at?: true
    achievement?: true
    denominator?: true
    numerator?: true
    target_value?: true
    indicator_id?: true
    district_id?: true
    facility_id?: true
    _all?: true
  }

  export type MonthlyHealthDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyHealthData to aggregate.
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyHealthData to fetch.
     */
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthlyHealthDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyHealthData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyHealthData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthlyHealthData
    **/
    _count?: true | MonthlyHealthDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthlyHealthDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthlyHealthDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthlyHealthDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthlyHealthDataMaxAggregateInputType
  }

  export type GetMonthlyHealthDataAggregateType<T extends MonthlyHealthDataAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthlyHealthData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthlyHealthData[P]>
      : GetScalarType<T[P], AggregateMonthlyHealthData[P]>
  }




  export type MonthlyHealthDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithAggregationInput | MonthlyHealthDataOrderByWithAggregationInput[]
    by: MonthlyHealthDataScalarFieldEnum[] | MonthlyHealthDataScalarFieldEnum
    having?: MonthlyHealthDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthlyHealthDataCountAggregateInputType | true
    _avg?: MonthlyHealthDataAvgAggregateInputType
    _sum?: MonthlyHealthDataSumAggregateInputType
    _min?: MonthlyHealthDataMinAggregateInputType
    _max?: MonthlyHealthDataMaxAggregateInputType
  }

  export type MonthlyHealthDataGroupByOutputType = {
    id: number
    sub_centre_id: number | null
    report_month: string
    value: Decimal | null
    data_quality: $Enums.DataQuality
    remarks: string | null
    uploaded_by: number
    approved_by: number | null
    approved_at: Date | null
    created_at: Date
    updated_at: Date
    achievement: Decimal | null
    denominator: Decimal | null
    numerator: Decimal | null
    target_value: Decimal | null
    indicator_id: number | null
    district_id: string
    facility_id: string | null
    _count: MonthlyHealthDataCountAggregateOutputType | null
    _avg: MonthlyHealthDataAvgAggregateOutputType | null
    _sum: MonthlyHealthDataSumAggregateOutputType | null
    _min: MonthlyHealthDataMinAggregateOutputType | null
    _max: MonthlyHealthDataMaxAggregateOutputType | null
  }

  type GetMonthlyHealthDataGroupByPayload<T extends MonthlyHealthDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthlyHealthDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthlyHealthDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthlyHealthDataGroupByOutputType[P]>
            : GetScalarType<T[P], MonthlyHealthDataGroupByOutputType[P]>
        }
      >
    >


  export type MonthlyHealthDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_centre_id?: boolean
    report_month?: boolean
    value?: boolean
    data_quality?: boolean
    remarks?: boolean
    uploaded_by?: boolean
    approved_by?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    achievement?: boolean
    denominator?: boolean
    numerator?: boolean
    target_value?: boolean
    indicator_id?: boolean
    district_id?: boolean
    facility_id?: boolean
    approver?: boolean | MonthlyHealthData$approverArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility?: boolean | MonthlyHealthData$facilityArgs<ExtArgs>
    indicator?: boolean | MonthlyHealthData$indicatorArgs<ExtArgs>
    sub_centre?: boolean | MonthlyHealthData$sub_centreArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyHealthData"]>

  export type MonthlyHealthDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_centre_id?: boolean
    report_month?: boolean
    value?: boolean
    data_quality?: boolean
    remarks?: boolean
    uploaded_by?: boolean
    approved_by?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    achievement?: boolean
    denominator?: boolean
    numerator?: boolean
    target_value?: boolean
    indicator_id?: boolean
    district_id?: boolean
    facility_id?: boolean
    approver?: boolean | MonthlyHealthData$approverArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility?: boolean | MonthlyHealthData$facilityArgs<ExtArgs>
    indicator?: boolean | MonthlyHealthData$indicatorArgs<ExtArgs>
    sub_centre?: boolean | MonthlyHealthData$sub_centreArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyHealthData"]>

  export type MonthlyHealthDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_centre_id?: boolean
    report_month?: boolean
    value?: boolean
    data_quality?: boolean
    remarks?: boolean
    uploaded_by?: boolean
    approved_by?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    achievement?: boolean
    denominator?: boolean
    numerator?: boolean
    target_value?: boolean
    indicator_id?: boolean
    district_id?: boolean
    facility_id?: boolean
    approver?: boolean | MonthlyHealthData$approverArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility?: boolean | MonthlyHealthData$facilityArgs<ExtArgs>
    indicator?: boolean | MonthlyHealthData$indicatorArgs<ExtArgs>
    sub_centre?: boolean | MonthlyHealthData$sub_centreArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyHealthData"]>

  export type MonthlyHealthDataSelectScalar = {
    id?: boolean
    sub_centre_id?: boolean
    report_month?: boolean
    value?: boolean
    data_quality?: boolean
    remarks?: boolean
    uploaded_by?: boolean
    approved_by?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    achievement?: boolean
    denominator?: boolean
    numerator?: boolean
    target_value?: boolean
    indicator_id?: boolean
    district_id?: boolean
    facility_id?: boolean
  }

  export type MonthlyHealthDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sub_centre_id" | "report_month" | "value" | "data_quality" | "remarks" | "uploaded_by" | "approved_by" | "approved_at" | "created_at" | "updated_at" | "achievement" | "denominator" | "numerator" | "target_value" | "indicator_id" | "district_id" | "facility_id", ExtArgs["result"]["monthlyHealthData"]>
  export type MonthlyHealthDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | MonthlyHealthData$approverArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility?: boolean | MonthlyHealthData$facilityArgs<ExtArgs>
    indicator?: boolean | MonthlyHealthData$indicatorArgs<ExtArgs>
    sub_centre?: boolean | MonthlyHealthData$sub_centreArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MonthlyHealthDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | MonthlyHealthData$approverArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility?: boolean | MonthlyHealthData$facilityArgs<ExtArgs>
    indicator?: boolean | MonthlyHealthData$indicatorArgs<ExtArgs>
    sub_centre?: boolean | MonthlyHealthData$sub_centreArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MonthlyHealthDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | MonthlyHealthData$approverArgs<ExtArgs>
    district?: boolean | DistrictDefaultArgs<ExtArgs>
    facility?: boolean | MonthlyHealthData$facilityArgs<ExtArgs>
    indicator?: boolean | MonthlyHealthData$indicatorArgs<ExtArgs>
    sub_centre?: boolean | MonthlyHealthData$sub_centreArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MonthlyHealthDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthlyHealthData"
    objects: {
      approver: Prisma.$UserPayload<ExtArgs> | null
      district: Prisma.$DistrictPayload<ExtArgs>
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      indicator: Prisma.$IndicatorPayload<ExtArgs> | null
      sub_centre: Prisma.$sub_centrePayload<ExtArgs> | null
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sub_centre_id: number | null
      report_month: string
      value: Prisma.Decimal | null
      data_quality: $Enums.DataQuality
      remarks: string | null
      uploaded_by: number
      approved_by: number | null
      approved_at: Date | null
      created_at: Date
      updated_at: Date
      achievement: Prisma.Decimal | null
      denominator: Prisma.Decimal | null
      numerator: Prisma.Decimal | null
      target_value: Prisma.Decimal | null
      indicator_id: number | null
      district_id: string
      facility_id: string | null
    }, ExtArgs["result"]["monthlyHealthData"]>
    composites: {}
  }

  type MonthlyHealthDataGetPayload<S extends boolean | null | undefined | MonthlyHealthDataDefaultArgs> = $Result.GetResult<Prisma.$MonthlyHealthDataPayload, S>

  type MonthlyHealthDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonthlyHealthDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonthlyHealthDataCountAggregateInputType | true
    }

  export interface MonthlyHealthDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthlyHealthData'], meta: { name: 'MonthlyHealthData' } }
    /**
     * Find zero or one MonthlyHealthData that matches the filter.
     * @param {MonthlyHealthDataFindUniqueArgs} args - Arguments to find a MonthlyHealthData
     * @example
     * // Get one MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthlyHealthDataFindUniqueArgs>(args: SelectSubset<T, MonthlyHealthDataFindUniqueArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonthlyHealthData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonthlyHealthDataFindUniqueOrThrowArgs} args - Arguments to find a MonthlyHealthData
     * @example
     * // Get one MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthlyHealthDataFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthlyHealthDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthlyHealthData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataFindFirstArgs} args - Arguments to find a MonthlyHealthData
     * @example
     * // Get one MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthlyHealthDataFindFirstArgs>(args?: SelectSubset<T, MonthlyHealthDataFindFirstArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonthlyHealthData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataFindFirstOrThrowArgs} args - Arguments to find a MonthlyHealthData
     * @example
     * // Get one MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthlyHealthDataFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthlyHealthDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonthlyHealthData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.findMany()
     * 
     * // Get first 10 MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthlyHealthDataWithIdOnly = await prisma.monthlyHealthData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonthlyHealthDataFindManyArgs>(args?: SelectSubset<T, MonthlyHealthDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonthlyHealthData.
     * @param {MonthlyHealthDataCreateArgs} args - Arguments to create a MonthlyHealthData.
     * @example
     * // Create one MonthlyHealthData
     * const MonthlyHealthData = await prisma.monthlyHealthData.create({
     *   data: {
     *     // ... data to create a MonthlyHealthData
     *   }
     * })
     * 
     */
    create<T extends MonthlyHealthDataCreateArgs>(args: SelectSubset<T, MonthlyHealthDataCreateArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonthlyHealthData.
     * @param {MonthlyHealthDataCreateManyArgs} args - Arguments to create many MonthlyHealthData.
     * @example
     * // Create many MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthlyHealthDataCreateManyArgs>(args?: SelectSubset<T, MonthlyHealthDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthlyHealthData and returns the data saved in the database.
     * @param {MonthlyHealthDataCreateManyAndReturnArgs} args - Arguments to create many MonthlyHealthData.
     * @example
     * // Create many MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthlyHealthData and only return the `id`
     * const monthlyHealthDataWithIdOnly = await prisma.monthlyHealthData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthlyHealthDataCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthlyHealthDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonthlyHealthData.
     * @param {MonthlyHealthDataDeleteArgs} args - Arguments to delete one MonthlyHealthData.
     * @example
     * // Delete one MonthlyHealthData
     * const MonthlyHealthData = await prisma.monthlyHealthData.delete({
     *   where: {
     *     // ... filter to delete one MonthlyHealthData
     *   }
     * })
     * 
     */
    delete<T extends MonthlyHealthDataDeleteArgs>(args: SelectSubset<T, MonthlyHealthDataDeleteArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonthlyHealthData.
     * @param {MonthlyHealthDataUpdateArgs} args - Arguments to update one MonthlyHealthData.
     * @example
     * // Update one MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthlyHealthDataUpdateArgs>(args: SelectSubset<T, MonthlyHealthDataUpdateArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonthlyHealthData.
     * @param {MonthlyHealthDataDeleteManyArgs} args - Arguments to filter MonthlyHealthData to delete.
     * @example
     * // Delete a few MonthlyHealthData
     * const { count } = await prisma.monthlyHealthData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthlyHealthDataDeleteManyArgs>(args?: SelectSubset<T, MonthlyHealthDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlyHealthData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthlyHealthDataUpdateManyArgs>(args: SelectSubset<T, MonthlyHealthDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlyHealthData and returns the data updated in the database.
     * @param {MonthlyHealthDataUpdateManyAndReturnArgs} args - Arguments to update many MonthlyHealthData.
     * @example
     * // Update many MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonthlyHealthData and only return the `id`
     * const monthlyHealthDataWithIdOnly = await prisma.monthlyHealthData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonthlyHealthDataUpdateManyAndReturnArgs>(args: SelectSubset<T, MonthlyHealthDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonthlyHealthData.
     * @param {MonthlyHealthDataUpsertArgs} args - Arguments to update or create a MonthlyHealthData.
     * @example
     * // Update or create a MonthlyHealthData
     * const monthlyHealthData = await prisma.monthlyHealthData.upsert({
     *   create: {
     *     // ... data to create a MonthlyHealthData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthlyHealthData we want to update
     *   }
     * })
     */
    upsert<T extends MonthlyHealthDataUpsertArgs>(args: SelectSubset<T, MonthlyHealthDataUpsertArgs<ExtArgs>>): Prisma__MonthlyHealthDataClient<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonthlyHealthData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataCountArgs} args - Arguments to filter MonthlyHealthData to count.
     * @example
     * // Count the number of MonthlyHealthData
     * const count = await prisma.monthlyHealthData.count({
     *   where: {
     *     // ... the filter for the MonthlyHealthData we want to count
     *   }
     * })
    **/
    count<T extends MonthlyHealthDataCountArgs>(
      args?: Subset<T, MonthlyHealthDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthlyHealthDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthlyHealthData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthlyHealthDataAggregateArgs>(args: Subset<T, MonthlyHealthDataAggregateArgs>): Prisma.PrismaPromise<GetMonthlyHealthDataAggregateType<T>>

    /**
     * Group by MonthlyHealthData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyHealthDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthlyHealthDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthlyHealthDataGroupByArgs['orderBy'] }
        : { orderBy?: MonthlyHealthDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthlyHealthDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthlyHealthDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthlyHealthData model
   */
  readonly fields: MonthlyHealthDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthlyHealthData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthlyHealthDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approver<T extends MonthlyHealthData$approverArgs<ExtArgs> = {}>(args?: Subset<T, MonthlyHealthData$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    district<T extends DistrictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistrictDefaultArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    facility<T extends MonthlyHealthData$facilityArgs<ExtArgs> = {}>(args?: Subset<T, MonthlyHealthData$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    indicator<T extends MonthlyHealthData$indicatorArgs<ExtArgs> = {}>(args?: Subset<T, MonthlyHealthData$indicatorArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sub_centre<T extends MonthlyHealthData$sub_centreArgs<ExtArgs> = {}>(args?: Subset<T, MonthlyHealthData$sub_centreArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthlyHealthData model
   */
  interface MonthlyHealthDataFieldRefs {
    readonly id: FieldRef<"MonthlyHealthData", 'Int'>
    readonly sub_centre_id: FieldRef<"MonthlyHealthData", 'Int'>
    readonly report_month: FieldRef<"MonthlyHealthData", 'String'>
    readonly value: FieldRef<"MonthlyHealthData", 'Decimal'>
    readonly data_quality: FieldRef<"MonthlyHealthData", 'DataQuality'>
    readonly remarks: FieldRef<"MonthlyHealthData", 'String'>
    readonly uploaded_by: FieldRef<"MonthlyHealthData", 'Int'>
    readonly approved_by: FieldRef<"MonthlyHealthData", 'Int'>
    readonly approved_at: FieldRef<"MonthlyHealthData", 'DateTime'>
    readonly created_at: FieldRef<"MonthlyHealthData", 'DateTime'>
    readonly updated_at: FieldRef<"MonthlyHealthData", 'DateTime'>
    readonly achievement: FieldRef<"MonthlyHealthData", 'Decimal'>
    readonly denominator: FieldRef<"MonthlyHealthData", 'Decimal'>
    readonly numerator: FieldRef<"MonthlyHealthData", 'Decimal'>
    readonly target_value: FieldRef<"MonthlyHealthData", 'Decimal'>
    readonly indicator_id: FieldRef<"MonthlyHealthData", 'Int'>
    readonly district_id: FieldRef<"MonthlyHealthData", 'String'>
    readonly facility_id: FieldRef<"MonthlyHealthData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MonthlyHealthData findUnique
   */
  export type MonthlyHealthDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyHealthData to fetch.
     */
    where: MonthlyHealthDataWhereUniqueInput
  }

  /**
   * MonthlyHealthData findUniqueOrThrow
   */
  export type MonthlyHealthDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyHealthData to fetch.
     */
    where: MonthlyHealthDataWhereUniqueInput
  }

  /**
   * MonthlyHealthData findFirst
   */
  export type MonthlyHealthDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyHealthData to fetch.
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyHealthData to fetch.
     */
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyHealthData.
     */
    cursor?: MonthlyHealthDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyHealthData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyHealthData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyHealthData.
     */
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * MonthlyHealthData findFirstOrThrow
   */
  export type MonthlyHealthDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyHealthData to fetch.
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyHealthData to fetch.
     */
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyHealthData.
     */
    cursor?: MonthlyHealthDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyHealthData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyHealthData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyHealthData.
     */
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * MonthlyHealthData findMany
   */
  export type MonthlyHealthDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyHealthData to fetch.
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyHealthData to fetch.
     */
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthlyHealthData.
     */
    cursor?: MonthlyHealthDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyHealthData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyHealthData.
     */
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * MonthlyHealthData create
   */
  export type MonthlyHealthDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * The data needed to create a MonthlyHealthData.
     */
    data: XOR<MonthlyHealthDataCreateInput, MonthlyHealthDataUncheckedCreateInput>
  }

  /**
   * MonthlyHealthData createMany
   */
  export type MonthlyHealthDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthlyHealthData.
     */
    data: MonthlyHealthDataCreateManyInput | MonthlyHealthDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthlyHealthData createManyAndReturn
   */
  export type MonthlyHealthDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * The data used to create many MonthlyHealthData.
     */
    data: MonthlyHealthDataCreateManyInput | MonthlyHealthDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthlyHealthData update
   */
  export type MonthlyHealthDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * The data needed to update a MonthlyHealthData.
     */
    data: XOR<MonthlyHealthDataUpdateInput, MonthlyHealthDataUncheckedUpdateInput>
    /**
     * Choose, which MonthlyHealthData to update.
     */
    where: MonthlyHealthDataWhereUniqueInput
  }

  /**
   * MonthlyHealthData updateMany
   */
  export type MonthlyHealthDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthlyHealthData.
     */
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyInput>
    /**
     * Filter which MonthlyHealthData to update
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * Limit how many MonthlyHealthData to update.
     */
    limit?: number
  }

  /**
   * MonthlyHealthData updateManyAndReturn
   */
  export type MonthlyHealthDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * The data used to update MonthlyHealthData.
     */
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyInput>
    /**
     * Filter which MonthlyHealthData to update
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * Limit how many MonthlyHealthData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthlyHealthData upsert
   */
  export type MonthlyHealthDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * The filter to search for the MonthlyHealthData to update in case it exists.
     */
    where: MonthlyHealthDataWhereUniqueInput
    /**
     * In case the MonthlyHealthData found by the `where` argument doesn't exist, create a new MonthlyHealthData with this data.
     */
    create: XOR<MonthlyHealthDataCreateInput, MonthlyHealthDataUncheckedCreateInput>
    /**
     * In case the MonthlyHealthData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthlyHealthDataUpdateInput, MonthlyHealthDataUncheckedUpdateInput>
  }

  /**
   * MonthlyHealthData delete
   */
  export type MonthlyHealthDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    /**
     * Filter which MonthlyHealthData to delete.
     */
    where: MonthlyHealthDataWhereUniqueInput
  }

  /**
   * MonthlyHealthData deleteMany
   */
  export type MonthlyHealthDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyHealthData to delete
     */
    where?: MonthlyHealthDataWhereInput
    /**
     * Limit how many MonthlyHealthData to delete.
     */
    limit?: number
  }

  /**
   * MonthlyHealthData.approver
   */
  export type MonthlyHealthData$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MonthlyHealthData.facility
   */
  export type MonthlyHealthData$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * MonthlyHealthData.indicator
   */
  export type MonthlyHealthData$indicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    where?: IndicatorWhereInput
  }

  /**
   * MonthlyHealthData.sub_centre
   */
  export type MonthlyHealthData$sub_centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    where?: sub_centreWhereInput
  }

  /**
   * MonthlyHealthData without action
   */
  export type MonthlyHealthDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
  }


  /**
   * Model DataUploadSession
   */

  export type AggregateDataUploadSession = {
    _count: DataUploadSessionCountAggregateOutputType | null
    _avg: DataUploadSessionAvgAggregateOutputType | null
    _sum: DataUploadSessionSumAggregateOutputType | null
    _min: DataUploadSessionMinAggregateOutputType | null
    _max: DataUploadSessionMaxAggregateOutputType | null
  }

  export type DataUploadSessionAvgAggregateOutputType = {
    id: number | null
    total_records: number | null
    success_count: number | null
    error_count: number | null
    uploaded_by: number | null
  }

  export type DataUploadSessionSumAggregateOutputType = {
    id: number | null
    total_records: number | null
    success_count: number | null
    error_count: number | null
    uploaded_by: number | null
  }

  export type DataUploadSessionMinAggregateOutputType = {
    id: number | null
    file_name: string | null
    report_month: string | null
    total_records: number | null
    success_count: number | null
    error_count: number | null
    status: $Enums.UploadStatus | null
    uploaded_by: number | null
    created_at: Date | null
    completed_at: Date | null
    file_path: string | null
  }

  export type DataUploadSessionMaxAggregateOutputType = {
    id: number | null
    file_name: string | null
    report_month: string | null
    total_records: number | null
    success_count: number | null
    error_count: number | null
    status: $Enums.UploadStatus | null
    uploaded_by: number | null
    created_at: Date | null
    completed_at: Date | null
    file_path: string | null
  }

  export type DataUploadSessionCountAggregateOutputType = {
    id: number
    file_name: number
    report_month: number
    total_records: number
    success_count: number
    error_count: number
    status: number
    upload_summary: number
    uploaded_by: number
    created_at: number
    completed_at: number
    file_path: number
    _all: number
  }


  export type DataUploadSessionAvgAggregateInputType = {
    id?: true
    total_records?: true
    success_count?: true
    error_count?: true
    uploaded_by?: true
  }

  export type DataUploadSessionSumAggregateInputType = {
    id?: true
    total_records?: true
    success_count?: true
    error_count?: true
    uploaded_by?: true
  }

  export type DataUploadSessionMinAggregateInputType = {
    id?: true
    file_name?: true
    report_month?: true
    total_records?: true
    success_count?: true
    error_count?: true
    status?: true
    uploaded_by?: true
    created_at?: true
    completed_at?: true
    file_path?: true
  }

  export type DataUploadSessionMaxAggregateInputType = {
    id?: true
    file_name?: true
    report_month?: true
    total_records?: true
    success_count?: true
    error_count?: true
    status?: true
    uploaded_by?: true
    created_at?: true
    completed_at?: true
    file_path?: true
  }

  export type DataUploadSessionCountAggregateInputType = {
    id?: true
    file_name?: true
    report_month?: true
    total_records?: true
    success_count?: true
    error_count?: true
    status?: true
    upload_summary?: true
    uploaded_by?: true
    created_at?: true
    completed_at?: true
    file_path?: true
    _all?: true
  }

  export type DataUploadSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataUploadSession to aggregate.
     */
    where?: DataUploadSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataUploadSessions to fetch.
     */
    orderBy?: DataUploadSessionOrderByWithRelationInput | DataUploadSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataUploadSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataUploadSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataUploadSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataUploadSessions
    **/
    _count?: true | DataUploadSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataUploadSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataUploadSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataUploadSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataUploadSessionMaxAggregateInputType
  }

  export type GetDataUploadSessionAggregateType<T extends DataUploadSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateDataUploadSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataUploadSession[P]>
      : GetScalarType<T[P], AggregateDataUploadSession[P]>
  }




  export type DataUploadSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataUploadSessionWhereInput
    orderBy?: DataUploadSessionOrderByWithAggregationInput | DataUploadSessionOrderByWithAggregationInput[]
    by: DataUploadSessionScalarFieldEnum[] | DataUploadSessionScalarFieldEnum
    having?: DataUploadSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataUploadSessionCountAggregateInputType | true
    _avg?: DataUploadSessionAvgAggregateInputType
    _sum?: DataUploadSessionSumAggregateInputType
    _min?: DataUploadSessionMinAggregateInputType
    _max?: DataUploadSessionMaxAggregateInputType
  }

  export type DataUploadSessionGroupByOutputType = {
    id: number
    file_name: string
    report_month: string
    total_records: number
    success_count: number
    error_count: number
    status: $Enums.UploadStatus
    upload_summary: JsonValue | null
    uploaded_by: number
    created_at: Date
    completed_at: Date | null
    file_path: string | null
    _count: DataUploadSessionCountAggregateOutputType | null
    _avg: DataUploadSessionAvgAggregateOutputType | null
    _sum: DataUploadSessionSumAggregateOutputType | null
    _min: DataUploadSessionMinAggregateOutputType | null
    _max: DataUploadSessionMaxAggregateOutputType | null
  }

  type GetDataUploadSessionGroupByPayload<T extends DataUploadSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataUploadSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataUploadSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataUploadSessionGroupByOutputType[P]>
            : GetScalarType<T[P], DataUploadSessionGroupByOutputType[P]>
        }
      >
    >


  export type DataUploadSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    report_month?: boolean
    total_records?: boolean
    success_count?: boolean
    error_count?: boolean
    status?: boolean
    upload_summary?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    completed_at?: boolean
    file_path?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataUploadSession"]>

  export type DataUploadSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    report_month?: boolean
    total_records?: boolean
    success_count?: boolean
    error_count?: boolean
    status?: boolean
    upload_summary?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    completed_at?: boolean
    file_path?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataUploadSession"]>

  export type DataUploadSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    report_month?: boolean
    total_records?: boolean
    success_count?: boolean
    error_count?: boolean
    status?: boolean
    upload_summary?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    completed_at?: boolean
    file_path?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataUploadSession"]>

  export type DataUploadSessionSelectScalar = {
    id?: boolean
    file_name?: boolean
    report_month?: boolean
    total_records?: boolean
    success_count?: boolean
    error_count?: boolean
    status?: boolean
    upload_summary?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    completed_at?: boolean
    file_path?: boolean
  }

  export type DataUploadSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "file_name" | "report_month" | "total_records" | "success_count" | "error_count" | "status" | "upload_summary" | "uploaded_by" | "created_at" | "completed_at" | "file_path", ExtArgs["result"]["dataUploadSession"]>
  export type DataUploadSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataUploadSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataUploadSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataUploadSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataUploadSession"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file_name: string
      report_month: string
      total_records: number
      success_count: number
      error_count: number
      status: $Enums.UploadStatus
      upload_summary: Prisma.JsonValue | null
      uploaded_by: number
      created_at: Date
      completed_at: Date | null
      file_path: string | null
    }, ExtArgs["result"]["dataUploadSession"]>
    composites: {}
  }

  type DataUploadSessionGetPayload<S extends boolean | null | undefined | DataUploadSessionDefaultArgs> = $Result.GetResult<Prisma.$DataUploadSessionPayload, S>

  type DataUploadSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataUploadSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataUploadSessionCountAggregateInputType | true
    }

  export interface DataUploadSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataUploadSession'], meta: { name: 'DataUploadSession' } }
    /**
     * Find zero or one DataUploadSession that matches the filter.
     * @param {DataUploadSessionFindUniqueArgs} args - Arguments to find a DataUploadSession
     * @example
     * // Get one DataUploadSession
     * const dataUploadSession = await prisma.dataUploadSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataUploadSessionFindUniqueArgs>(args: SelectSubset<T, DataUploadSessionFindUniqueArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataUploadSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataUploadSessionFindUniqueOrThrowArgs} args - Arguments to find a DataUploadSession
     * @example
     * // Get one DataUploadSession
     * const dataUploadSession = await prisma.dataUploadSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataUploadSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, DataUploadSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataUploadSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionFindFirstArgs} args - Arguments to find a DataUploadSession
     * @example
     * // Get one DataUploadSession
     * const dataUploadSession = await prisma.dataUploadSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataUploadSessionFindFirstArgs>(args?: SelectSubset<T, DataUploadSessionFindFirstArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataUploadSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionFindFirstOrThrowArgs} args - Arguments to find a DataUploadSession
     * @example
     * // Get one DataUploadSession
     * const dataUploadSession = await prisma.dataUploadSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataUploadSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, DataUploadSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataUploadSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataUploadSessions
     * const dataUploadSessions = await prisma.dataUploadSession.findMany()
     * 
     * // Get first 10 DataUploadSessions
     * const dataUploadSessions = await prisma.dataUploadSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataUploadSessionWithIdOnly = await prisma.dataUploadSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataUploadSessionFindManyArgs>(args?: SelectSubset<T, DataUploadSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataUploadSession.
     * @param {DataUploadSessionCreateArgs} args - Arguments to create a DataUploadSession.
     * @example
     * // Create one DataUploadSession
     * const DataUploadSession = await prisma.dataUploadSession.create({
     *   data: {
     *     // ... data to create a DataUploadSession
     *   }
     * })
     * 
     */
    create<T extends DataUploadSessionCreateArgs>(args: SelectSubset<T, DataUploadSessionCreateArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataUploadSessions.
     * @param {DataUploadSessionCreateManyArgs} args - Arguments to create many DataUploadSessions.
     * @example
     * // Create many DataUploadSessions
     * const dataUploadSession = await prisma.dataUploadSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataUploadSessionCreateManyArgs>(args?: SelectSubset<T, DataUploadSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataUploadSessions and returns the data saved in the database.
     * @param {DataUploadSessionCreateManyAndReturnArgs} args - Arguments to create many DataUploadSessions.
     * @example
     * // Create many DataUploadSessions
     * const dataUploadSession = await prisma.dataUploadSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataUploadSessions and only return the `id`
     * const dataUploadSessionWithIdOnly = await prisma.dataUploadSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataUploadSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, DataUploadSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataUploadSession.
     * @param {DataUploadSessionDeleteArgs} args - Arguments to delete one DataUploadSession.
     * @example
     * // Delete one DataUploadSession
     * const DataUploadSession = await prisma.dataUploadSession.delete({
     *   where: {
     *     // ... filter to delete one DataUploadSession
     *   }
     * })
     * 
     */
    delete<T extends DataUploadSessionDeleteArgs>(args: SelectSubset<T, DataUploadSessionDeleteArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataUploadSession.
     * @param {DataUploadSessionUpdateArgs} args - Arguments to update one DataUploadSession.
     * @example
     * // Update one DataUploadSession
     * const dataUploadSession = await prisma.dataUploadSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataUploadSessionUpdateArgs>(args: SelectSubset<T, DataUploadSessionUpdateArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataUploadSessions.
     * @param {DataUploadSessionDeleteManyArgs} args - Arguments to filter DataUploadSessions to delete.
     * @example
     * // Delete a few DataUploadSessions
     * const { count } = await prisma.dataUploadSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataUploadSessionDeleteManyArgs>(args?: SelectSubset<T, DataUploadSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataUploadSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataUploadSessions
     * const dataUploadSession = await prisma.dataUploadSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataUploadSessionUpdateManyArgs>(args: SelectSubset<T, DataUploadSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataUploadSessions and returns the data updated in the database.
     * @param {DataUploadSessionUpdateManyAndReturnArgs} args - Arguments to update many DataUploadSessions.
     * @example
     * // Update many DataUploadSessions
     * const dataUploadSession = await prisma.dataUploadSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataUploadSessions and only return the `id`
     * const dataUploadSessionWithIdOnly = await prisma.dataUploadSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataUploadSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, DataUploadSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataUploadSession.
     * @param {DataUploadSessionUpsertArgs} args - Arguments to update or create a DataUploadSession.
     * @example
     * // Update or create a DataUploadSession
     * const dataUploadSession = await prisma.dataUploadSession.upsert({
     *   create: {
     *     // ... data to create a DataUploadSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataUploadSession we want to update
     *   }
     * })
     */
    upsert<T extends DataUploadSessionUpsertArgs>(args: SelectSubset<T, DataUploadSessionUpsertArgs<ExtArgs>>): Prisma__DataUploadSessionClient<$Result.GetResult<Prisma.$DataUploadSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataUploadSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionCountArgs} args - Arguments to filter DataUploadSessions to count.
     * @example
     * // Count the number of DataUploadSessions
     * const count = await prisma.dataUploadSession.count({
     *   where: {
     *     // ... the filter for the DataUploadSessions we want to count
     *   }
     * })
    **/
    count<T extends DataUploadSessionCountArgs>(
      args?: Subset<T, DataUploadSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataUploadSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataUploadSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataUploadSessionAggregateArgs>(args: Subset<T, DataUploadSessionAggregateArgs>): Prisma.PrismaPromise<GetDataUploadSessionAggregateType<T>>

    /**
     * Group by DataUploadSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataUploadSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataUploadSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataUploadSessionGroupByArgs['orderBy'] }
        : { orderBy?: DataUploadSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataUploadSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataUploadSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataUploadSession model
   */
  readonly fields: DataUploadSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataUploadSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataUploadSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataUploadSession model
   */
  interface DataUploadSessionFieldRefs {
    readonly id: FieldRef<"DataUploadSession", 'Int'>
    readonly file_name: FieldRef<"DataUploadSession", 'String'>
    readonly report_month: FieldRef<"DataUploadSession", 'String'>
    readonly total_records: FieldRef<"DataUploadSession", 'Int'>
    readonly success_count: FieldRef<"DataUploadSession", 'Int'>
    readonly error_count: FieldRef<"DataUploadSession", 'Int'>
    readonly status: FieldRef<"DataUploadSession", 'UploadStatus'>
    readonly upload_summary: FieldRef<"DataUploadSession", 'Json'>
    readonly uploaded_by: FieldRef<"DataUploadSession", 'Int'>
    readonly created_at: FieldRef<"DataUploadSession", 'DateTime'>
    readonly completed_at: FieldRef<"DataUploadSession", 'DateTime'>
    readonly file_path: FieldRef<"DataUploadSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataUploadSession findUnique
   */
  export type DataUploadSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which DataUploadSession to fetch.
     */
    where: DataUploadSessionWhereUniqueInput
  }

  /**
   * DataUploadSession findUniqueOrThrow
   */
  export type DataUploadSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which DataUploadSession to fetch.
     */
    where: DataUploadSessionWhereUniqueInput
  }

  /**
   * DataUploadSession findFirst
   */
  export type DataUploadSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which DataUploadSession to fetch.
     */
    where?: DataUploadSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataUploadSessions to fetch.
     */
    orderBy?: DataUploadSessionOrderByWithRelationInput | DataUploadSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataUploadSessions.
     */
    cursor?: DataUploadSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataUploadSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataUploadSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataUploadSessions.
     */
    distinct?: DataUploadSessionScalarFieldEnum | DataUploadSessionScalarFieldEnum[]
  }

  /**
   * DataUploadSession findFirstOrThrow
   */
  export type DataUploadSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which DataUploadSession to fetch.
     */
    where?: DataUploadSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataUploadSessions to fetch.
     */
    orderBy?: DataUploadSessionOrderByWithRelationInput | DataUploadSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataUploadSessions.
     */
    cursor?: DataUploadSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataUploadSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataUploadSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataUploadSessions.
     */
    distinct?: DataUploadSessionScalarFieldEnum | DataUploadSessionScalarFieldEnum[]
  }

  /**
   * DataUploadSession findMany
   */
  export type DataUploadSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * Filter, which DataUploadSessions to fetch.
     */
    where?: DataUploadSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataUploadSessions to fetch.
     */
    orderBy?: DataUploadSessionOrderByWithRelationInput | DataUploadSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataUploadSessions.
     */
    cursor?: DataUploadSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataUploadSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataUploadSessions.
     */
    skip?: number
    distinct?: DataUploadSessionScalarFieldEnum | DataUploadSessionScalarFieldEnum[]
  }

  /**
   * DataUploadSession create
   */
  export type DataUploadSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a DataUploadSession.
     */
    data: XOR<DataUploadSessionCreateInput, DataUploadSessionUncheckedCreateInput>
  }

  /**
   * DataUploadSession createMany
   */
  export type DataUploadSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataUploadSessions.
     */
    data: DataUploadSessionCreateManyInput | DataUploadSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataUploadSession createManyAndReturn
   */
  export type DataUploadSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * The data used to create many DataUploadSessions.
     */
    data: DataUploadSessionCreateManyInput | DataUploadSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataUploadSession update
   */
  export type DataUploadSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a DataUploadSession.
     */
    data: XOR<DataUploadSessionUpdateInput, DataUploadSessionUncheckedUpdateInput>
    /**
     * Choose, which DataUploadSession to update.
     */
    where: DataUploadSessionWhereUniqueInput
  }

  /**
   * DataUploadSession updateMany
   */
  export type DataUploadSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataUploadSessions.
     */
    data: XOR<DataUploadSessionUpdateManyMutationInput, DataUploadSessionUncheckedUpdateManyInput>
    /**
     * Filter which DataUploadSessions to update
     */
    where?: DataUploadSessionWhereInput
    /**
     * Limit how many DataUploadSessions to update.
     */
    limit?: number
  }

  /**
   * DataUploadSession updateManyAndReturn
   */
  export type DataUploadSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * The data used to update DataUploadSessions.
     */
    data: XOR<DataUploadSessionUpdateManyMutationInput, DataUploadSessionUncheckedUpdateManyInput>
    /**
     * Filter which DataUploadSessions to update
     */
    where?: DataUploadSessionWhereInput
    /**
     * Limit how many DataUploadSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataUploadSession upsert
   */
  export type DataUploadSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the DataUploadSession to update in case it exists.
     */
    where: DataUploadSessionWhereUniqueInput
    /**
     * In case the DataUploadSession found by the `where` argument doesn't exist, create a new DataUploadSession with this data.
     */
    create: XOR<DataUploadSessionCreateInput, DataUploadSessionUncheckedCreateInput>
    /**
     * In case the DataUploadSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataUploadSessionUpdateInput, DataUploadSessionUncheckedUpdateInput>
  }

  /**
   * DataUploadSession delete
   */
  export type DataUploadSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
    /**
     * Filter which DataUploadSession to delete.
     */
    where: DataUploadSessionWhereUniqueInput
  }

  /**
   * DataUploadSession deleteMany
   */
  export type DataUploadSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataUploadSessions to delete
     */
    where?: DataUploadSessionWhereInput
    /**
     * Limit how many DataUploadSessions to delete.
     */
    limit?: number
  }

  /**
   * DataUploadSession without action
   */
  export type DataUploadSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataUploadSession
     */
    select?: DataUploadSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataUploadSession
     */
    omit?: DataUploadSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataUploadSessionInclude<ExtArgs> | null
  }


  /**
   * Model Formula
   */

  export type AggregateFormula = {
    _count: FormulaCountAggregateOutputType | null
    _avg: FormulaAvgAggregateOutputType | null
    _sum: FormulaSumAggregateOutputType | null
    _min: FormulaMinAggregateOutputType | null
    _max: FormulaMaxAggregateOutputType | null
  }

  export type FormulaAvgAggregateOutputType = {
    id: number | null
  }

  export type FormulaSumAggregateOutputType = {
    id: number | null
  }

  export type FormulaMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FormulaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FormulaCountAggregateOutputType = {
    id: number
    name: number
    description: number
    structure: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FormulaAvgAggregateInputType = {
    id?: true
  }

  export type FormulaSumAggregateInputType = {
    id?: true
  }

  export type FormulaMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type FormulaMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type FormulaCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    structure?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FormulaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Formula to aggregate.
     */
    where?: FormulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formulas to fetch.
     */
    orderBy?: FormulaOrderByWithRelationInput | FormulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formulas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Formulas
    **/
    _count?: true | FormulaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormulaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormulaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormulaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormulaMaxAggregateInputType
  }

  export type GetFormulaAggregateType<T extends FormulaAggregateArgs> = {
        [P in keyof T & keyof AggregateFormula]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormula[P]>
      : GetScalarType<T[P], AggregateFormula[P]>
  }




  export type FormulaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormulaWhereInput
    orderBy?: FormulaOrderByWithAggregationInput | FormulaOrderByWithAggregationInput[]
    by: FormulaScalarFieldEnum[] | FormulaScalarFieldEnum
    having?: FormulaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormulaCountAggregateInputType | true
    _avg?: FormulaAvgAggregateInputType
    _sum?: FormulaSumAggregateInputType
    _min?: FormulaMinAggregateInputType
    _max?: FormulaMaxAggregateInputType
  }

  export type FormulaGroupByOutputType = {
    id: number
    name: string
    description: string | null
    structure: JsonValue
    created_at: Date
    updated_at: Date
    _count: FormulaCountAggregateOutputType | null
    _avg: FormulaAvgAggregateOutputType | null
    _sum: FormulaSumAggregateOutputType | null
    _min: FormulaMinAggregateOutputType | null
    _max: FormulaMaxAggregateOutputType | null
  }

  type GetFormulaGroupByPayload<T extends FormulaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormulaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormulaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormulaGroupByOutputType[P]>
            : GetScalarType<T[P], FormulaGroupByOutputType[P]>
        }
      >
    >


  export type FormulaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["formula"]>

  export type FormulaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["formula"]>

  export type FormulaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["formula"]>

  export type FormulaSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FormulaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "structure" | "created_at" | "updated_at", ExtArgs["result"]["formula"]>

  export type $FormulaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Formula"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      structure: Prisma.JsonValue
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["formula"]>
    composites: {}
  }

  type FormulaGetPayload<S extends boolean | null | undefined | FormulaDefaultArgs> = $Result.GetResult<Prisma.$FormulaPayload, S>

  type FormulaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormulaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormulaCountAggregateInputType | true
    }

  export interface FormulaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Formula'], meta: { name: 'Formula' } }
    /**
     * Find zero or one Formula that matches the filter.
     * @param {FormulaFindUniqueArgs} args - Arguments to find a Formula
     * @example
     * // Get one Formula
     * const formula = await prisma.formula.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormulaFindUniqueArgs>(args: SelectSubset<T, FormulaFindUniqueArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Formula that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormulaFindUniqueOrThrowArgs} args - Arguments to find a Formula
     * @example
     * // Get one Formula
     * const formula = await prisma.formula.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormulaFindUniqueOrThrowArgs>(args: SelectSubset<T, FormulaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formula that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaFindFirstArgs} args - Arguments to find a Formula
     * @example
     * // Get one Formula
     * const formula = await prisma.formula.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormulaFindFirstArgs>(args?: SelectSubset<T, FormulaFindFirstArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formula that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaFindFirstOrThrowArgs} args - Arguments to find a Formula
     * @example
     * // Get one Formula
     * const formula = await prisma.formula.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormulaFindFirstOrThrowArgs>(args?: SelectSubset<T, FormulaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formulas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formulas
     * const formulas = await prisma.formula.findMany()
     * 
     * // Get first 10 Formulas
     * const formulas = await prisma.formula.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formulaWithIdOnly = await prisma.formula.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormulaFindManyArgs>(args?: SelectSubset<T, FormulaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Formula.
     * @param {FormulaCreateArgs} args - Arguments to create a Formula.
     * @example
     * // Create one Formula
     * const Formula = await prisma.formula.create({
     *   data: {
     *     // ... data to create a Formula
     *   }
     * })
     * 
     */
    create<T extends FormulaCreateArgs>(args: SelectSubset<T, FormulaCreateArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formulas.
     * @param {FormulaCreateManyArgs} args - Arguments to create many Formulas.
     * @example
     * // Create many Formulas
     * const formula = await prisma.formula.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormulaCreateManyArgs>(args?: SelectSubset<T, FormulaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Formulas and returns the data saved in the database.
     * @param {FormulaCreateManyAndReturnArgs} args - Arguments to create many Formulas.
     * @example
     * // Create many Formulas
     * const formula = await prisma.formula.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Formulas and only return the `id`
     * const formulaWithIdOnly = await prisma.formula.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormulaCreateManyAndReturnArgs>(args?: SelectSubset<T, FormulaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Formula.
     * @param {FormulaDeleteArgs} args - Arguments to delete one Formula.
     * @example
     * // Delete one Formula
     * const Formula = await prisma.formula.delete({
     *   where: {
     *     // ... filter to delete one Formula
     *   }
     * })
     * 
     */
    delete<T extends FormulaDeleteArgs>(args: SelectSubset<T, FormulaDeleteArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Formula.
     * @param {FormulaUpdateArgs} args - Arguments to update one Formula.
     * @example
     * // Update one Formula
     * const formula = await prisma.formula.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormulaUpdateArgs>(args: SelectSubset<T, FormulaUpdateArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formulas.
     * @param {FormulaDeleteManyArgs} args - Arguments to filter Formulas to delete.
     * @example
     * // Delete a few Formulas
     * const { count } = await prisma.formula.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormulaDeleteManyArgs>(args?: SelectSubset<T, FormulaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formulas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formulas
     * const formula = await prisma.formula.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormulaUpdateManyArgs>(args: SelectSubset<T, FormulaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formulas and returns the data updated in the database.
     * @param {FormulaUpdateManyAndReturnArgs} args - Arguments to update many Formulas.
     * @example
     * // Update many Formulas
     * const formula = await prisma.formula.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Formulas and only return the `id`
     * const formulaWithIdOnly = await prisma.formula.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormulaUpdateManyAndReturnArgs>(args: SelectSubset<T, FormulaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Formula.
     * @param {FormulaUpsertArgs} args - Arguments to update or create a Formula.
     * @example
     * // Update or create a Formula
     * const formula = await prisma.formula.upsert({
     *   create: {
     *     // ... data to create a Formula
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formula we want to update
     *   }
     * })
     */
    upsert<T extends FormulaUpsertArgs>(args: SelectSubset<T, FormulaUpsertArgs<ExtArgs>>): Prisma__FormulaClient<$Result.GetResult<Prisma.$FormulaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formulas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaCountArgs} args - Arguments to filter Formulas to count.
     * @example
     * // Count the number of Formulas
     * const count = await prisma.formula.count({
     *   where: {
     *     // ... the filter for the Formulas we want to count
     *   }
     * })
    **/
    count<T extends FormulaCountArgs>(
      args?: Subset<T, FormulaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormulaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormulaAggregateArgs>(args: Subset<T, FormulaAggregateArgs>): Prisma.PrismaPromise<GetFormulaAggregateType<T>>

    /**
     * Group by Formula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormulaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormulaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormulaGroupByArgs['orderBy'] }
        : { orderBy?: FormulaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormulaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormulaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Formula model
   */
  readonly fields: FormulaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Formula.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormulaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Formula model
   */
  interface FormulaFieldRefs {
    readonly id: FieldRef<"Formula", 'Int'>
    readonly name: FieldRef<"Formula", 'String'>
    readonly description: FieldRef<"Formula", 'String'>
    readonly structure: FieldRef<"Formula", 'Json'>
    readonly created_at: FieldRef<"Formula", 'DateTime'>
    readonly updated_at: FieldRef<"Formula", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Formula findUnique
   */
  export type FormulaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * Filter, which Formula to fetch.
     */
    where: FormulaWhereUniqueInput
  }

  /**
   * Formula findUniqueOrThrow
   */
  export type FormulaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * Filter, which Formula to fetch.
     */
    where: FormulaWhereUniqueInput
  }

  /**
   * Formula findFirst
   */
  export type FormulaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * Filter, which Formula to fetch.
     */
    where?: FormulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formulas to fetch.
     */
    orderBy?: FormulaOrderByWithRelationInput | FormulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Formulas.
     */
    cursor?: FormulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formulas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Formulas.
     */
    distinct?: FormulaScalarFieldEnum | FormulaScalarFieldEnum[]
  }

  /**
   * Formula findFirstOrThrow
   */
  export type FormulaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * Filter, which Formula to fetch.
     */
    where?: FormulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formulas to fetch.
     */
    orderBy?: FormulaOrderByWithRelationInput | FormulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Formulas.
     */
    cursor?: FormulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formulas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Formulas.
     */
    distinct?: FormulaScalarFieldEnum | FormulaScalarFieldEnum[]
  }

  /**
   * Formula findMany
   */
  export type FormulaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * Filter, which Formulas to fetch.
     */
    where?: FormulaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formulas to fetch.
     */
    orderBy?: FormulaOrderByWithRelationInput | FormulaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Formulas.
     */
    cursor?: FormulaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formulas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formulas.
     */
    skip?: number
    distinct?: FormulaScalarFieldEnum | FormulaScalarFieldEnum[]
  }

  /**
   * Formula create
   */
  export type FormulaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * The data needed to create a Formula.
     */
    data: XOR<FormulaCreateInput, FormulaUncheckedCreateInput>
  }

  /**
   * Formula createMany
   */
  export type FormulaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Formulas.
     */
    data: FormulaCreateManyInput | FormulaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Formula createManyAndReturn
   */
  export type FormulaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * The data used to create many Formulas.
     */
    data: FormulaCreateManyInput | FormulaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Formula update
   */
  export type FormulaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * The data needed to update a Formula.
     */
    data: XOR<FormulaUpdateInput, FormulaUncheckedUpdateInput>
    /**
     * Choose, which Formula to update.
     */
    where: FormulaWhereUniqueInput
  }

  /**
   * Formula updateMany
   */
  export type FormulaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Formulas.
     */
    data: XOR<FormulaUpdateManyMutationInput, FormulaUncheckedUpdateManyInput>
    /**
     * Filter which Formulas to update
     */
    where?: FormulaWhereInput
    /**
     * Limit how many Formulas to update.
     */
    limit?: number
  }

  /**
   * Formula updateManyAndReturn
   */
  export type FormulaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * The data used to update Formulas.
     */
    data: XOR<FormulaUpdateManyMutationInput, FormulaUncheckedUpdateManyInput>
    /**
     * Filter which Formulas to update
     */
    where?: FormulaWhereInput
    /**
     * Limit how many Formulas to update.
     */
    limit?: number
  }

  /**
   * Formula upsert
   */
  export type FormulaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * The filter to search for the Formula to update in case it exists.
     */
    where: FormulaWhereUniqueInput
    /**
     * In case the Formula found by the `where` argument doesn't exist, create a new Formula with this data.
     */
    create: XOR<FormulaCreateInput, FormulaUncheckedCreateInput>
    /**
     * In case the Formula was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormulaUpdateInput, FormulaUncheckedUpdateInput>
  }

  /**
   * Formula delete
   */
  export type FormulaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
    /**
     * Filter which Formula to delete.
     */
    where: FormulaWhereUniqueInput
  }

  /**
   * Formula deleteMany
   */
  export type FormulaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Formulas to delete
     */
    where?: FormulaWhereInput
    /**
     * Limit how many Formulas to delete.
     */
    limit?: number
  }

  /**
   * Formula without action
   */
  export type FormulaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formula
     */
    select?: FormulaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formula
     */
    omit?: FormulaOmit<ExtArgs> | null
  }


  /**
   * Model Indicator
   */

  export type AggregateIndicator = {
    _count: IndicatorCountAggregateOutputType | null
    _avg: IndicatorAvgAggregateOutputType | null
    _sum: IndicatorSumAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  export type IndicatorAvgAggregateOutputType = {
    id: number | null
    denominator_field_id: number | null
    numerator_field_id: number | null
    target_field_id: number | null
  }

  export type IndicatorSumAggregateOutputType = {
    id: number | null
    denominator_field_id: number | null
    numerator_field_id: number | null
    target_field_id: number | null
  }

  export type IndicatorMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    conditions: string | null
    denominator_field_id: number | null
    denominator_label: string | null
    numerator_field_id: number | null
    numerator_label: string | null
    target_formula: string | null
    target_type: $Enums.TargetType | null
    target_value: string | null
    target_field_id: number | null
    source_of_verification: string | null
  }

  export type IndicatorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    type: string | null
    created_at: Date | null
    updated_at: Date | null
    code: string | null
    conditions: string | null
    denominator_field_id: number | null
    denominator_label: string | null
    numerator_field_id: number | null
    numerator_label: string | null
    target_formula: string | null
    target_type: $Enums.TargetType | null
    target_value: string | null
    target_field_id: number | null
    source_of_verification: string | null
  }

  export type IndicatorCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    structure: number
    created_at: number
    updated_at: number
    code: number
    applicable_facility_types: number
    conditions: number
    denominator_field_id: number
    denominator_label: number
    formula_config: number
    numerator_field_id: number
    numerator_label: number
    target_formula: number
    target_type: number
    target_value: number
    target_field_id: number
    source_of_verification: number
    _all: number
  }


  export type IndicatorAvgAggregateInputType = {
    id?: true
    denominator_field_id?: true
    numerator_field_id?: true
    target_field_id?: true
  }

  export type IndicatorSumAggregateInputType = {
    id?: true
    denominator_field_id?: true
    numerator_field_id?: true
    target_field_id?: true
  }

  export type IndicatorMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    updated_at?: true
    code?: true
    conditions?: true
    denominator_field_id?: true
    denominator_label?: true
    numerator_field_id?: true
    numerator_label?: true
    target_formula?: true
    target_type?: true
    target_value?: true
    target_field_id?: true
    source_of_verification?: true
  }

  export type IndicatorMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    updated_at?: true
    code?: true
    conditions?: true
    denominator_field_id?: true
    denominator_label?: true
    numerator_field_id?: true
    numerator_label?: true
    target_formula?: true
    target_type?: true
    target_value?: true
    target_field_id?: true
    source_of_verification?: true
  }

  export type IndicatorCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    structure?: true
    created_at?: true
    updated_at?: true
    code?: true
    applicable_facility_types?: true
    conditions?: true
    denominator_field_id?: true
    denominator_label?: true
    formula_config?: true
    numerator_field_id?: true
    numerator_label?: true
    target_formula?: true
    target_type?: true
    target_value?: true
    target_field_id?: true
    source_of_verification?: true
    _all?: true
  }

  export type IndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicator to aggregate.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Indicators
    **/
    _count?: true | IndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorMaxAggregateInputType
  }

  export type GetIndicatorAggregateType<T extends IndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicator[P]>
      : GetScalarType<T[P], AggregateIndicator[P]>
  }




  export type IndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithAggregationInput | IndicatorOrderByWithAggregationInput[]
    by: IndicatorScalarFieldEnum[] | IndicatorScalarFieldEnum
    having?: IndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorCountAggregateInputType | true
    _avg?: IndicatorAvgAggregateInputType
    _sum?: IndicatorSumAggregateInputType
    _min?: IndicatorMinAggregateInputType
    _max?: IndicatorMaxAggregateInputType
  }

  export type IndicatorGroupByOutputType = {
    id: number
    name: string
    description: string | null
    type: string
    structure: JsonValue | null
    created_at: Date
    updated_at: Date
    code: string
    applicable_facility_types: JsonValue | null
    conditions: string | null
    denominator_field_id: number | null
    denominator_label: string | null
    formula_config: JsonValue | null
    numerator_field_id: number | null
    numerator_label: string | null
    target_formula: string | null
    target_type: $Enums.TargetType
    target_value: string | null
    target_field_id: number | null
    source_of_verification: string | null
    _count: IndicatorCountAggregateOutputType | null
    _avg: IndicatorAvgAggregateOutputType | null
    _sum: IndicatorSumAggregateOutputType | null
    _min: IndicatorMinAggregateOutputType | null
    _max: IndicatorMaxAggregateOutputType | null
  }

  type GetIndicatorGroupByPayload<T extends IndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    applicable_facility_types?: boolean
    conditions?: boolean
    denominator_field_id?: boolean
    denominator_label?: boolean
    formula_config?: boolean
    numerator_field_id?: boolean
    numerator_label?: boolean
    target_formula?: boolean
    target_type?: boolean
    target_value?: boolean
    target_field_id?: boolean
    source_of_verification?: boolean
    facility_targets?: boolean | Indicator$facility_targetsArgs<ExtArgs>
    denominator_field?: boolean | Indicator$denominator_fieldArgs<ExtArgs>
    numerator_field?: boolean | Indicator$numerator_fieldArgs<ExtArgs>
    target_field?: boolean | Indicator$target_fieldArgs<ExtArgs>
    remunerations?: boolean | Indicator$remunerationsArgs<ExtArgs>
    worker_allocations?: boolean | Indicator$worker_allocationsArgs<ExtArgs>
    monthly_data?: boolean | Indicator$monthly_dataArgs<ExtArgs>
    performance_calculations?: boolean | Indicator$performance_calculationsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    applicable_facility_types?: boolean
    conditions?: boolean
    denominator_field_id?: boolean
    denominator_label?: boolean
    formula_config?: boolean
    numerator_field_id?: boolean
    numerator_label?: boolean
    target_formula?: boolean
    target_type?: boolean
    target_value?: boolean
    target_field_id?: boolean
    source_of_verification?: boolean
    denominator_field?: boolean | Indicator$denominator_fieldArgs<ExtArgs>
    numerator_field?: boolean | Indicator$numerator_fieldArgs<ExtArgs>
    target_field?: boolean | Indicator$target_fieldArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    applicable_facility_types?: boolean
    conditions?: boolean
    denominator_field_id?: boolean
    denominator_label?: boolean
    formula_config?: boolean
    numerator_field_id?: boolean
    numerator_label?: boolean
    target_formula?: boolean
    target_type?: boolean
    target_value?: boolean
    target_field_id?: boolean
    source_of_verification?: boolean
    denominator_field?: boolean | Indicator$denominator_fieldArgs<ExtArgs>
    numerator_field?: boolean | Indicator$numerator_fieldArgs<ExtArgs>
    target_field?: boolean | Indicator$target_fieldArgs<ExtArgs>
  }, ExtArgs["result"]["indicator"]>

  export type IndicatorSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    structure?: boolean
    created_at?: boolean
    updated_at?: boolean
    code?: boolean
    applicable_facility_types?: boolean
    conditions?: boolean
    denominator_field_id?: boolean
    denominator_label?: boolean
    formula_config?: boolean
    numerator_field_id?: boolean
    numerator_label?: boolean
    target_formula?: boolean
    target_type?: boolean
    target_value?: boolean
    target_field_id?: boolean
    source_of_verification?: boolean
  }

  export type IndicatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "structure" | "created_at" | "updated_at" | "code" | "applicable_facility_types" | "conditions" | "denominator_field_id" | "denominator_label" | "formula_config" | "numerator_field_id" | "numerator_label" | "target_formula" | "target_type" | "target_value" | "target_field_id" | "source_of_verification", ExtArgs["result"]["indicator"]>
  export type IndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_targets?: boolean | Indicator$facility_targetsArgs<ExtArgs>
    denominator_field?: boolean | Indicator$denominator_fieldArgs<ExtArgs>
    numerator_field?: boolean | Indicator$numerator_fieldArgs<ExtArgs>
    target_field?: boolean | Indicator$target_fieldArgs<ExtArgs>
    remunerations?: boolean | Indicator$remunerationsArgs<ExtArgs>
    worker_allocations?: boolean | Indicator$worker_allocationsArgs<ExtArgs>
    monthly_data?: boolean | Indicator$monthly_dataArgs<ExtArgs>
    performance_calculations?: boolean | Indicator$performance_calculationsArgs<ExtArgs>
    _count?: boolean | IndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    denominator_field?: boolean | Indicator$denominator_fieldArgs<ExtArgs>
    numerator_field?: boolean | Indicator$numerator_fieldArgs<ExtArgs>
    target_field?: boolean | Indicator$target_fieldArgs<ExtArgs>
  }
  export type IndicatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    denominator_field?: boolean | Indicator$denominator_fieldArgs<ExtArgs>
    numerator_field?: boolean | Indicator$numerator_fieldArgs<ExtArgs>
    target_field?: boolean | Indicator$target_fieldArgs<ExtArgs>
  }

  export type $IndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Indicator"
    objects: {
      facility_targets: Prisma.$FacilityTargetPayload<ExtArgs>[]
      denominator_field: Prisma.$FieldPayload<ExtArgs> | null
      numerator_field: Prisma.$FieldPayload<ExtArgs> | null
      target_field: Prisma.$FieldPayload<ExtArgs> | null
      remunerations: Prisma.$IndicatorRemunerationPayload<ExtArgs>[]
      worker_allocations: Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>[]
      monthly_data: Prisma.$MonthlyHealthDataPayload<ExtArgs>[]
      performance_calculations: Prisma.$PerformanceCalculationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      type: string
      structure: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
      code: string
      applicable_facility_types: Prisma.JsonValue | null
      conditions: string | null
      denominator_field_id: number | null
      denominator_label: string | null
      formula_config: Prisma.JsonValue | null
      numerator_field_id: number | null
      numerator_label: string | null
      target_formula: string | null
      target_type: $Enums.TargetType
      target_value: string | null
      target_field_id: number | null
      source_of_verification: string | null
    }, ExtArgs["result"]["indicator"]>
    composites: {}
  }

  type IndicatorGetPayload<S extends boolean | null | undefined | IndicatorDefaultArgs> = $Result.GetResult<Prisma.$IndicatorPayload, S>

  type IndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicatorCountAggregateInputType | true
    }

  export interface IndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Indicator'], meta: { name: 'Indicator' } }
    /**
     * Find zero or one Indicator that matches the filter.
     * @param {IndicatorFindUniqueArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorFindUniqueArgs>(args: SelectSubset<T, IndicatorFindUniqueArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Indicator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicatorFindUniqueOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorFindFirstArgs>(args?: SelectSubset<T, IndicatorFindFirstArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindFirstOrThrowArgs} args - Arguments to find a Indicator
     * @example
     * // Get one Indicator
     * const indicator = await prisma.indicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Indicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicators
     * const indicators = await prisma.indicator.findMany()
     * 
     * // Get first 10 Indicators
     * const indicators = await prisma.indicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorWithIdOnly = await prisma.indicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorFindManyArgs>(args?: SelectSubset<T, IndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Indicator.
     * @param {IndicatorCreateArgs} args - Arguments to create a Indicator.
     * @example
     * // Create one Indicator
     * const Indicator = await prisma.indicator.create({
     *   data: {
     *     // ... data to create a Indicator
     *   }
     * })
     * 
     */
    create<T extends IndicatorCreateArgs>(args: SelectSubset<T, IndicatorCreateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Indicators.
     * @param {IndicatorCreateManyArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorCreateManyArgs>(args?: SelectSubset<T, IndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicators and returns the data saved in the database.
     * @param {IndicatorCreateManyAndReturnArgs} args - Arguments to create many Indicators.
     * @example
     * // Create many Indicators
     * const indicator = await prisma.indicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicators and only return the `id`
     * const indicatorWithIdOnly = await prisma.indicator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Indicator.
     * @param {IndicatorDeleteArgs} args - Arguments to delete one Indicator.
     * @example
     * // Delete one Indicator
     * const Indicator = await prisma.indicator.delete({
     *   where: {
     *     // ... filter to delete one Indicator
     *   }
     * })
     * 
     */
    delete<T extends IndicatorDeleteArgs>(args: SelectSubset<T, IndicatorDeleteArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Indicator.
     * @param {IndicatorUpdateArgs} args - Arguments to update one Indicator.
     * @example
     * // Update one Indicator
     * const indicator = await prisma.indicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorUpdateArgs>(args: SelectSubset<T, IndicatorUpdateArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Indicators.
     * @param {IndicatorDeleteManyArgs} args - Arguments to filter Indicators to delete.
     * @example
     * // Delete a few Indicators
     * const { count } = await prisma.indicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorDeleteManyArgs>(args?: SelectSubset<T, IndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicators
     * const indicator = await prisma.indicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorUpdateManyArgs>(args: SelectSubset<T, IndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicators and returns the data updated in the database.
     * @param {IndicatorUpdateManyAndReturnArgs} args - Arguments to update many Indicators.
     * @example
     * // Update many Indicators
     * const indicator = await prisma.indicator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Indicators and only return the `id`
     * const indicatorWithIdOnly = await prisma.indicator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndicatorUpdateManyAndReturnArgs>(args: SelectSubset<T, IndicatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Indicator.
     * @param {IndicatorUpsertArgs} args - Arguments to update or create a Indicator.
     * @example
     * // Update or create a Indicator
     * const indicator = await prisma.indicator.upsert({
     *   create: {
     *     // ... data to create a Indicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicator we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorUpsertArgs>(args: SelectSubset<T, IndicatorUpsertArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Indicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorCountArgs} args - Arguments to filter Indicators to count.
     * @example
     * // Count the number of Indicators
     * const count = await prisma.indicator.count({
     *   where: {
     *     // ... the filter for the Indicators we want to count
     *   }
     * })
    **/
    count<T extends IndicatorCountArgs>(
      args?: Subset<T, IndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorAggregateArgs>(args: Subset<T, IndicatorAggregateArgs>): Prisma.PrismaPromise<GetIndicatorAggregateType<T>>

    /**
     * Group by Indicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Indicator model
   */
  readonly fields: IndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Indicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility_targets<T extends Indicator$facility_targetsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$facility_targetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    denominator_field<T extends Indicator$denominator_fieldArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$denominator_fieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    numerator_field<T extends Indicator$numerator_fieldArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$numerator_fieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    target_field<T extends Indicator$target_fieldArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$target_fieldArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    remunerations<T extends Indicator$remunerationsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$remunerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    worker_allocations<T extends Indicator$worker_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$worker_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monthly_data<T extends Indicator$monthly_dataArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$monthly_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performance_calculations<T extends Indicator$performance_calculationsArgs<ExtArgs> = {}>(args?: Subset<T, Indicator$performance_calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Indicator model
   */
  interface IndicatorFieldRefs {
    readonly id: FieldRef<"Indicator", 'Int'>
    readonly name: FieldRef<"Indicator", 'String'>
    readonly description: FieldRef<"Indicator", 'String'>
    readonly type: FieldRef<"Indicator", 'String'>
    readonly structure: FieldRef<"Indicator", 'Json'>
    readonly created_at: FieldRef<"Indicator", 'DateTime'>
    readonly updated_at: FieldRef<"Indicator", 'DateTime'>
    readonly code: FieldRef<"Indicator", 'String'>
    readonly applicable_facility_types: FieldRef<"Indicator", 'Json'>
    readonly conditions: FieldRef<"Indicator", 'String'>
    readonly denominator_field_id: FieldRef<"Indicator", 'Int'>
    readonly denominator_label: FieldRef<"Indicator", 'String'>
    readonly formula_config: FieldRef<"Indicator", 'Json'>
    readonly numerator_field_id: FieldRef<"Indicator", 'Int'>
    readonly numerator_label: FieldRef<"Indicator", 'String'>
    readonly target_formula: FieldRef<"Indicator", 'String'>
    readonly target_type: FieldRef<"Indicator", 'TargetType'>
    readonly target_value: FieldRef<"Indicator", 'String'>
    readonly target_field_id: FieldRef<"Indicator", 'Int'>
    readonly source_of_verification: FieldRef<"Indicator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Indicator findUnique
   */
  export type IndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findUniqueOrThrow
   */
  export type IndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator findFirst
   */
  export type IndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findFirstOrThrow
   */
  export type IndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicator to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Indicators.
     */
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator findMany
   */
  export type IndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter, which Indicators to fetch.
     */
    where?: IndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Indicators to fetch.
     */
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Indicators.
     */
    cursor?: IndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Indicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Indicators.
     */
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Indicator create
   */
  export type IndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Indicator.
     */
    data: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
  }

  /**
   * Indicator createMany
   */
  export type IndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Indicator createManyAndReturn
   */
  export type IndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * The data used to create many Indicators.
     */
    data: IndicatorCreateManyInput | IndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Indicator update
   */
  export type IndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Indicator.
     */
    data: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
    /**
     * Choose, which Indicator to update.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator updateMany
   */
  export type IndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Indicators.
     */
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyInput>
    /**
     * Filter which Indicators to update
     */
    where?: IndicatorWhereInput
    /**
     * Limit how many Indicators to update.
     */
    limit?: number
  }

  /**
   * Indicator updateManyAndReturn
   */
  export type IndicatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * The data used to update Indicators.
     */
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyInput>
    /**
     * Filter which Indicators to update
     */
    where?: IndicatorWhereInput
    /**
     * Limit how many Indicators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Indicator upsert
   */
  export type IndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Indicator to update in case it exists.
     */
    where: IndicatorWhereUniqueInput
    /**
     * In case the Indicator found by the `where` argument doesn't exist, create a new Indicator with this data.
     */
    create: XOR<IndicatorCreateInput, IndicatorUncheckedCreateInput>
    /**
     * In case the Indicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorUpdateInput, IndicatorUncheckedUpdateInput>
  }

  /**
   * Indicator delete
   */
  export type IndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    /**
     * Filter which Indicator to delete.
     */
    where: IndicatorWhereUniqueInput
  }

  /**
   * Indicator deleteMany
   */
  export type IndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Indicators to delete
     */
    where?: IndicatorWhereInput
    /**
     * Limit how many Indicators to delete.
     */
    limit?: number
  }

  /**
   * Indicator.facility_targets
   */
  export type Indicator$facility_targetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    where?: FacilityTargetWhereInput
    orderBy?: FacilityTargetOrderByWithRelationInput | FacilityTargetOrderByWithRelationInput[]
    cursor?: FacilityTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityTargetScalarFieldEnum | FacilityTargetScalarFieldEnum[]
  }

  /**
   * Indicator.denominator_field
   */
  export type Indicator$denominator_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * Indicator.numerator_field
   */
  export type Indicator$numerator_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * Indicator.target_field
   */
  export type Indicator$target_fieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    where?: FieldWhereInput
  }

  /**
   * Indicator.remunerations
   */
  export type Indicator$remunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    where?: IndicatorRemunerationWhereInput
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    cursor?: IndicatorRemunerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorRemunerationScalarFieldEnum | IndicatorRemunerationScalarFieldEnum[]
  }

  /**
   * Indicator.worker_allocations
   */
  export type Indicator$worker_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    where?: IndicatorWorkerAllocationWhereInput
    orderBy?: IndicatorWorkerAllocationOrderByWithRelationInput | IndicatorWorkerAllocationOrderByWithRelationInput[]
    cursor?: IndicatorWorkerAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorWorkerAllocationScalarFieldEnum | IndicatorWorkerAllocationScalarFieldEnum[]
  }

  /**
   * Indicator.monthly_data
   */
  export type Indicator$monthly_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    cursor?: MonthlyHealthDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * Indicator.performance_calculations
   */
  export type Indicator$performance_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    where?: PerformanceCalculationWhereInput
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    cursor?: PerformanceCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceCalculationScalarFieldEnum | PerformanceCalculationScalarFieldEnum[]
  }

  /**
   * Indicator without action
   */
  export type IndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
  }


  /**
   * Model Field
   */

  export type AggregateField = {
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  export type FieldAvgAggregateOutputType = {
    id: number | null
    sort_order: number | null
  }

  export type FieldSumAggregateOutputType = {
    id: number | null
    sort_order: number | null
  }

  export type FieldMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    calculation_formula: string | null
    default_value: string | null
    field_type: $Enums.FieldType | null
    is_active: boolean | null
    sort_order: number | null
    user_type: $Enums.UserType | null
    field_category: $Enums.FieldCategory | null
  }

  export type FieldMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
    calculation_formula: string | null
    default_value: string | null
    field_type: $Enums.FieldType | null
    is_active: boolean | null
    sort_order: number | null
    user_type: $Enums.UserType | null
    field_category: $Enums.FieldCategory | null
  }

  export type FieldCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    created_at: number
    updated_at: number
    calculation_formula: number
    default_value: number
    facility_type_targets: number
    field_type: number
    is_active: number
    sort_order: number
    user_type: number
    validation_rules: number
    field_category: number
    _all: number
  }


  export type FieldAvgAggregateInputType = {
    id?: true
    sort_order?: true
  }

  export type FieldSumAggregateInputType = {
    id?: true
    sort_order?: true
  }

  export type FieldMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    calculation_formula?: true
    default_value?: true
    field_type?: true
    is_active?: true
    sort_order?: true
    user_type?: true
    field_category?: true
  }

  export type FieldMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    calculation_formula?: true
    default_value?: true
    field_type?: true
    is_active?: true
    sort_order?: true
    user_type?: true
    field_category?: true
  }

  export type FieldCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    calculation_formula?: true
    default_value?: true
    facility_type_targets?: true
    field_type?: true
    is_active?: true
    sort_order?: true
    user_type?: true
    validation_rules?: true
    field_category?: true
    _all?: true
  }

  export type FieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Field to aggregate.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fields
    **/
    _count?: true | FieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldMaxAggregateInputType
  }

  export type GetFieldAggregateType<T extends FieldAggregateArgs> = {
        [P in keyof T & keyof AggregateField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateField[P]>
      : GetScalarType<T[P], AggregateField[P]>
  }




  export type FieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldWhereInput
    orderBy?: FieldOrderByWithAggregationInput | FieldOrderByWithAggregationInput[]
    by: FieldScalarFieldEnum[] | FieldScalarFieldEnum
    having?: FieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldCountAggregateInputType | true
    _avg?: FieldAvgAggregateInputType
    _sum?: FieldSumAggregateInputType
    _min?: FieldMinAggregateInputType
    _max?: FieldMaxAggregateInputType
  }

  export type FieldGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string | null
    created_at: Date
    updated_at: Date
    calculation_formula: string | null
    default_value: string | null
    facility_type_targets: JsonValue | null
    field_type: $Enums.FieldType
    is_active: boolean
    sort_order: number
    user_type: $Enums.UserType
    validation_rules: JsonValue | null
    field_category: $Enums.FieldCategory
    _count: FieldCountAggregateOutputType | null
    _avg: FieldAvgAggregateOutputType | null
    _sum: FieldSumAggregateOutputType | null
    _min: FieldMinAggregateOutputType | null
    _max: FieldMaxAggregateOutputType | null
  }

  type GetFieldGroupByPayload<T extends FieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldGroupByOutputType[P]>
            : GetScalarType<T[P], FieldGroupByOutputType[P]>
        }
      >
    >


  export type FieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    calculation_formula?: boolean
    default_value?: boolean
    facility_type_targets?: boolean
    field_type?: boolean
    is_active?: boolean
    sort_order?: boolean
    user_type?: boolean
    validation_rules?: boolean
    field_category?: boolean
    facility_field_defaults?: boolean | Field$facility_field_defaultsArgs<ExtArgs>
    facility_field_mappings?: boolean | Field$facility_field_mappingsArgs<ExtArgs>
    field_values?: boolean | Field$field_valuesArgs<ExtArgs>
    denominator_for_indicators?: boolean | Field$denominator_for_indicatorsArgs<ExtArgs>
    numerator_for_indicators?: boolean | Field$numerator_for_indicatorsArgs<ExtArgs>
    target_for_indicators?: boolean | Field$target_for_indicatorsArgs<ExtArgs>
    _count?: boolean | FieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["field"]>

  export type FieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    calculation_formula?: boolean
    default_value?: boolean
    facility_type_targets?: boolean
    field_type?: boolean
    is_active?: boolean
    sort_order?: boolean
    user_type?: boolean
    validation_rules?: boolean
    field_category?: boolean
  }, ExtArgs["result"]["field"]>

  export type FieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    calculation_formula?: boolean
    default_value?: boolean
    facility_type_targets?: boolean
    field_type?: boolean
    is_active?: boolean
    sort_order?: boolean
    user_type?: boolean
    validation_rules?: boolean
    field_category?: boolean
  }, ExtArgs["result"]["field"]>

  export type FieldSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    calculation_formula?: boolean
    default_value?: boolean
    facility_type_targets?: boolean
    field_type?: boolean
    is_active?: boolean
    sort_order?: boolean
    user_type?: boolean
    validation_rules?: boolean
    field_category?: boolean
  }

  export type FieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "created_at" | "updated_at" | "calculation_formula" | "default_value" | "facility_type_targets" | "field_type" | "is_active" | "sort_order" | "user_type" | "validation_rules" | "field_category", ExtArgs["result"]["field"]>
  export type FieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_field_defaults?: boolean | Field$facility_field_defaultsArgs<ExtArgs>
    facility_field_mappings?: boolean | Field$facility_field_mappingsArgs<ExtArgs>
    field_values?: boolean | Field$field_valuesArgs<ExtArgs>
    denominator_for_indicators?: boolean | Field$denominator_for_indicatorsArgs<ExtArgs>
    numerator_for_indicators?: boolean | Field$numerator_for_indicatorsArgs<ExtArgs>
    target_for_indicators?: boolean | Field$target_for_indicatorsArgs<ExtArgs>
    _count?: boolean | FieldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Field"
    objects: {
      facility_field_defaults: Prisma.$FacilityFieldDefaultsPayload<ExtArgs>[]
      facility_field_mappings: Prisma.$FacilityFieldMappingPayload<ExtArgs>[]
      field_values: Prisma.$FieldValuePayload<ExtArgs>[]
      denominator_for_indicators: Prisma.$IndicatorPayload<ExtArgs>[]
      numerator_for_indicators: Prisma.$IndicatorPayload<ExtArgs>[]
      target_for_indicators: Prisma.$IndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string | null
      created_at: Date
      updated_at: Date
      calculation_formula: string | null
      default_value: string | null
      facility_type_targets: Prisma.JsonValue | null
      field_type: $Enums.FieldType
      is_active: boolean
      sort_order: number
      user_type: $Enums.UserType
      validation_rules: Prisma.JsonValue | null
      field_category: $Enums.FieldCategory
    }, ExtArgs["result"]["field"]>
    composites: {}
  }

  type FieldGetPayload<S extends boolean | null | undefined | FieldDefaultArgs> = $Result.GetResult<Prisma.$FieldPayload, S>

  type FieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldCountAggregateInputType | true
    }

  export interface FieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Field'], meta: { name: 'Field' } }
    /**
     * Find zero or one Field that matches the filter.
     * @param {FieldFindUniqueArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldFindUniqueArgs>(args: SelectSubset<T, FieldFindUniqueArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Field that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldFindUniqueOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Field that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldFindFirstArgs>(args?: SelectSubset<T, FieldFindFirstArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Field that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindFirstOrThrowArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.field.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWithIdOnly = await prisma.field.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldFindManyArgs>(args?: SelectSubset<T, FieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Field.
     * @param {FieldCreateArgs} args - Arguments to create a Field.
     * @example
     * // Create one Field
     * const Field = await prisma.field.create({
     *   data: {
     *     // ... data to create a Field
     *   }
     * })
     * 
     */
    create<T extends FieldCreateArgs>(args: SelectSubset<T, FieldCreateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fields.
     * @param {FieldCreateManyArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldCreateManyArgs>(args?: SelectSubset<T, FieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fields and returns the data saved in the database.
     * @param {FieldCreateManyAndReturnArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const field = await prisma.field.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fields and only return the `id`
     * const fieldWithIdOnly = await prisma.field.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Field.
     * @param {FieldDeleteArgs} args - Arguments to delete one Field.
     * @example
     * // Delete one Field
     * const Field = await prisma.field.delete({
     *   where: {
     *     // ... filter to delete one Field
     *   }
     * })
     * 
     */
    delete<T extends FieldDeleteArgs>(args: SelectSubset<T, FieldDeleteArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Field.
     * @param {FieldUpdateArgs} args - Arguments to update one Field.
     * @example
     * // Update one Field
     * const field = await prisma.field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldUpdateArgs>(args: SelectSubset<T, FieldUpdateArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fields.
     * @param {FieldDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldDeleteManyArgs>(args?: SelectSubset<T, FieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldUpdateManyArgs>(args: SelectSubset<T, FieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields and returns the data updated in the database.
     * @param {FieldUpdateManyAndReturnArgs} args - Arguments to update many Fields.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fields and only return the `id`
     * const fieldWithIdOnly = await prisma.field.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Field.
     * @param {FieldUpsertArgs} args - Arguments to update or create a Field.
     * @example
     * // Update or create a Field
     * const field = await prisma.field.upsert({
     *   create: {
     *     // ... data to create a Field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Field we want to update
     *   }
     * })
     */
    upsert<T extends FieldUpsertArgs>(args: SelectSubset<T, FieldUpsertArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldCountArgs} args - Arguments to filter Fields to count.
     * @example
     * // Count the number of Fields
     * const count = await prisma.field.count({
     *   where: {
     *     // ... the filter for the Fields we want to count
     *   }
     * })
    **/
    count<T extends FieldCountArgs>(
      args?: Subset<T, FieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldAggregateArgs>(args: Subset<T, FieldAggregateArgs>): Prisma.PrismaPromise<GetFieldAggregateType<T>>

    /**
     * Group by Field.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldGroupByArgs['orderBy'] }
        : { orderBy?: FieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Field model
   */
  readonly fields: FieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility_field_defaults<T extends Field$facility_field_defaultsArgs<ExtArgs> = {}>(args?: Subset<T, Field$facility_field_defaultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facility_field_mappings<T extends Field$facility_field_mappingsArgs<ExtArgs> = {}>(args?: Subset<T, Field$facility_field_mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    field_values<T extends Field$field_valuesArgs<ExtArgs> = {}>(args?: Subset<T, Field$field_valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    denominator_for_indicators<T extends Field$denominator_for_indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Field$denominator_for_indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    numerator_for_indicators<T extends Field$numerator_for_indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Field$numerator_for_indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    target_for_indicators<T extends Field$target_for_indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Field$target_for_indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Field model
   */
  interface FieldFieldRefs {
    readonly id: FieldRef<"Field", 'Int'>
    readonly code: FieldRef<"Field", 'String'>
    readonly name: FieldRef<"Field", 'String'>
    readonly description: FieldRef<"Field", 'String'>
    readonly created_at: FieldRef<"Field", 'DateTime'>
    readonly updated_at: FieldRef<"Field", 'DateTime'>
    readonly calculation_formula: FieldRef<"Field", 'String'>
    readonly default_value: FieldRef<"Field", 'String'>
    readonly facility_type_targets: FieldRef<"Field", 'Json'>
    readonly field_type: FieldRef<"Field", 'FieldType'>
    readonly is_active: FieldRef<"Field", 'Boolean'>
    readonly sort_order: FieldRef<"Field", 'Int'>
    readonly user_type: FieldRef<"Field", 'UserType'>
    readonly validation_rules: FieldRef<"Field", 'Json'>
    readonly field_category: FieldRef<"Field", 'FieldCategory'>
  }
    

  // Custom InputTypes
  /**
   * Field findUnique
   */
  export type FieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findUniqueOrThrow
   */
  export type FieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field findFirst
   */
  export type FieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findFirstOrThrow
   */
  export type FieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Field to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fields.
     */
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field findMany
   */
  export type FieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter, which Fields to fetch.
     */
    where?: FieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fields to fetch.
     */
    orderBy?: FieldOrderByWithRelationInput | FieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fields.
     */
    cursor?: FieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fields.
     */
    skip?: number
    distinct?: FieldScalarFieldEnum | FieldScalarFieldEnum[]
  }

  /**
   * Field create
   */
  export type FieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to create a Field.
     */
    data: XOR<FieldCreateInput, FieldUncheckedCreateInput>
  }

  /**
   * Field createMany
   */
  export type FieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Field createManyAndReturn
   */
  export type FieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * The data used to create many Fields.
     */
    data: FieldCreateManyInput | FieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Field update
   */
  export type FieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The data needed to update a Field.
     */
    data: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
    /**
     * Choose, which Field to update.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field updateMany
   */
  export type FieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
  }

  /**
   * Field updateManyAndReturn
   */
  export type FieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * The data used to update Fields.
     */
    data: XOR<FieldUpdateManyMutationInput, FieldUncheckedUpdateManyInput>
    /**
     * Filter which Fields to update
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to update.
     */
    limit?: number
  }

  /**
   * Field upsert
   */
  export type FieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * The filter to search for the Field to update in case it exists.
     */
    where: FieldWhereUniqueInput
    /**
     * In case the Field found by the `where` argument doesn't exist, create a new Field with this data.
     */
    create: XOR<FieldCreateInput, FieldUncheckedCreateInput>
    /**
     * In case the Field was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldUpdateInput, FieldUncheckedUpdateInput>
  }

  /**
   * Field delete
   */
  export type FieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
    /**
     * Filter which Field to delete.
     */
    where: FieldWhereUniqueInput
  }

  /**
   * Field deleteMany
   */
  export type FieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fields to delete
     */
    where?: FieldWhereInput
    /**
     * Limit how many Fields to delete.
     */
    limit?: number
  }

  /**
   * Field.facility_field_defaults
   */
  export type Field$facility_field_defaultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    where?: FacilityFieldDefaultsWhereInput
    orderBy?: FacilityFieldDefaultsOrderByWithRelationInput | FacilityFieldDefaultsOrderByWithRelationInput[]
    cursor?: FacilityFieldDefaultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityFieldDefaultsScalarFieldEnum | FacilityFieldDefaultsScalarFieldEnum[]
  }

  /**
   * Field.facility_field_mappings
   */
  export type Field$facility_field_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    where?: FacilityFieldMappingWhereInput
    orderBy?: FacilityFieldMappingOrderByWithRelationInput | FacilityFieldMappingOrderByWithRelationInput[]
    cursor?: FacilityFieldMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityFieldMappingScalarFieldEnum | FacilityFieldMappingScalarFieldEnum[]
  }

  /**
   * Field.field_values
   */
  export type Field$field_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    where?: FieldValueWhereInput
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    cursor?: FieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FieldValueScalarFieldEnum | FieldValueScalarFieldEnum[]
  }

  /**
   * Field.denominator_for_indicators
   */
  export type Field$denominator_for_indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    cursor?: IndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Field.numerator_for_indicators
   */
  export type Field$numerator_for_indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    cursor?: IndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Field.target_for_indicators
   */
  export type Field$target_for_indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Indicator
     */
    select?: IndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Indicator
     */
    omit?: IndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorInclude<ExtArgs> | null
    where?: IndicatorWhereInput
    orderBy?: IndicatorOrderByWithRelationInput | IndicatorOrderByWithRelationInput[]
    cursor?: IndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorScalarFieldEnum | IndicatorScalarFieldEnum[]
  }

  /**
   * Field without action
   */
  export type FieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Field
     */
    select?: FieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Field
     */
    omit?: FieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldInclude<ExtArgs> | null
  }


  /**
   * Model FieldValue
   */

  export type AggregateFieldValue = {
    _count: FieldValueCountAggregateOutputType | null
    _avg: FieldValueAvgAggregateOutputType | null
    _sum: FieldValueSumAggregateOutputType | null
    _min: FieldValueMinAggregateOutputType | null
    _max: FieldValueMaxAggregateOutputType | null
  }

  export type FieldValueAvgAggregateOutputType = {
    id: number | null
    field_id: number | null
    numeric_value: Decimal | null
    uploaded_by: number | null
  }

  export type FieldValueSumAggregateOutputType = {
    id: number | null
    field_id: number | null
    numeric_value: Decimal | null
    uploaded_by: number | null
  }

  export type FieldValueMinAggregateOutputType = {
    id: number | null
    field_id: number | null
    report_month: string | null
    string_value: string | null
    numeric_value: Decimal | null
    boolean_value: boolean | null
    uploaded_by: number | null
    remarks: string | null
    created_at: Date | null
    updated_at: Date | null
    is_override: boolean | null
    override_reason: string | null
    facility_id: string | null
  }

  export type FieldValueMaxAggregateOutputType = {
    id: number | null
    field_id: number | null
    report_month: string | null
    string_value: string | null
    numeric_value: Decimal | null
    boolean_value: boolean | null
    uploaded_by: number | null
    remarks: string | null
    created_at: Date | null
    updated_at: Date | null
    is_override: boolean | null
    override_reason: string | null
    facility_id: string | null
  }

  export type FieldValueCountAggregateOutputType = {
    id: number
    field_id: number
    report_month: number
    string_value: number
    numeric_value: number
    boolean_value: number
    json_value: number
    uploaded_by: number
    remarks: number
    created_at: number
    updated_at: number
    is_override: number
    override_reason: number
    facility_id: number
    _all: number
  }


  export type FieldValueAvgAggregateInputType = {
    id?: true
    field_id?: true
    numeric_value?: true
    uploaded_by?: true
  }

  export type FieldValueSumAggregateInputType = {
    id?: true
    field_id?: true
    numeric_value?: true
    uploaded_by?: true
  }

  export type FieldValueMinAggregateInputType = {
    id?: true
    field_id?: true
    report_month?: true
    string_value?: true
    numeric_value?: true
    boolean_value?: true
    uploaded_by?: true
    remarks?: true
    created_at?: true
    updated_at?: true
    is_override?: true
    override_reason?: true
    facility_id?: true
  }

  export type FieldValueMaxAggregateInputType = {
    id?: true
    field_id?: true
    report_month?: true
    string_value?: true
    numeric_value?: true
    boolean_value?: true
    uploaded_by?: true
    remarks?: true
    created_at?: true
    updated_at?: true
    is_override?: true
    override_reason?: true
    facility_id?: true
  }

  export type FieldValueCountAggregateInputType = {
    id?: true
    field_id?: true
    report_month?: true
    string_value?: true
    numeric_value?: true
    boolean_value?: true
    json_value?: true
    uploaded_by?: true
    remarks?: true
    created_at?: true
    updated_at?: true
    is_override?: true
    override_reason?: true
    facility_id?: true
    _all?: true
  }

  export type FieldValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldValue to aggregate.
     */
    where?: FieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldValues to fetch.
     */
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FieldValues
    **/
    _count?: true | FieldValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldValueMaxAggregateInputType
  }

  export type GetFieldValueAggregateType<T extends FieldValueAggregateArgs> = {
        [P in keyof T & keyof AggregateFieldValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFieldValue[P]>
      : GetScalarType<T[P], AggregateFieldValue[P]>
  }




  export type FieldValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FieldValueWhereInput
    orderBy?: FieldValueOrderByWithAggregationInput | FieldValueOrderByWithAggregationInput[]
    by: FieldValueScalarFieldEnum[] | FieldValueScalarFieldEnum
    having?: FieldValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldValueCountAggregateInputType | true
    _avg?: FieldValueAvgAggregateInputType
    _sum?: FieldValueSumAggregateInputType
    _min?: FieldValueMinAggregateInputType
    _max?: FieldValueMaxAggregateInputType
  }

  export type FieldValueGroupByOutputType = {
    id: number
    field_id: number
    report_month: string
    string_value: string | null
    numeric_value: Decimal | null
    boolean_value: boolean | null
    json_value: JsonValue | null
    uploaded_by: number
    remarks: string | null
    created_at: Date
    updated_at: Date
    is_override: boolean
    override_reason: string | null
    facility_id: string | null
    _count: FieldValueCountAggregateOutputType | null
    _avg: FieldValueAvgAggregateOutputType | null
    _sum: FieldValueSumAggregateOutputType | null
    _min: FieldValueMinAggregateOutputType | null
    _max: FieldValueMaxAggregateOutputType | null
  }

  type GetFieldValueGroupByPayload<T extends FieldValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldValueGroupByOutputType[P]>
            : GetScalarType<T[P], FieldValueGroupByOutputType[P]>
        }
      >
    >


  export type FieldValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    report_month?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    uploaded_by?: boolean
    remarks?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_override?: boolean
    override_reason?: boolean
    facility_id?: boolean
    facility?: boolean | FieldValue$facilityArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldValue"]>

  export type FieldValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    report_month?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    uploaded_by?: boolean
    remarks?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_override?: boolean
    override_reason?: boolean
    facility_id?: boolean
    facility?: boolean | FieldValue$facilityArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldValue"]>

  export type FieldValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    report_month?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    uploaded_by?: boolean
    remarks?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_override?: boolean
    override_reason?: boolean
    facility_id?: boolean
    facility?: boolean | FieldValue$facilityArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fieldValue"]>

  export type FieldValueSelectScalar = {
    id?: boolean
    field_id?: boolean
    report_month?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    uploaded_by?: boolean
    remarks?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_override?: boolean
    override_reason?: boolean
    facility_id?: boolean
  }

  export type FieldValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "field_id" | "report_month" | "string_value" | "numeric_value" | "boolean_value" | "json_value" | "uploaded_by" | "remarks" | "created_at" | "updated_at" | "is_override" | "override_reason" | "facility_id", ExtArgs["result"]["fieldValue"]>
  export type FieldValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FieldValue$facilityArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FieldValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FieldValue$facilityArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FieldValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FieldValue$facilityArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FieldValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FieldValue"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      field: Prisma.$FieldPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      field_id: number
      report_month: string
      string_value: string | null
      numeric_value: Prisma.Decimal | null
      boolean_value: boolean | null
      json_value: Prisma.JsonValue | null
      uploaded_by: number
      remarks: string | null
      created_at: Date
      updated_at: Date
      is_override: boolean
      override_reason: string | null
      facility_id: string | null
    }, ExtArgs["result"]["fieldValue"]>
    composites: {}
  }

  type FieldValueGetPayload<S extends boolean | null | undefined | FieldValueDefaultArgs> = $Result.GetResult<Prisma.$FieldValuePayload, S>

  type FieldValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FieldValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldValueCountAggregateInputType | true
    }

  export interface FieldValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FieldValue'], meta: { name: 'FieldValue' } }
    /**
     * Find zero or one FieldValue that matches the filter.
     * @param {FieldValueFindUniqueArgs} args - Arguments to find a FieldValue
     * @example
     * // Get one FieldValue
     * const fieldValue = await prisma.fieldValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FieldValueFindUniqueArgs>(args: SelectSubset<T, FieldValueFindUniqueArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FieldValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FieldValueFindUniqueOrThrowArgs} args - Arguments to find a FieldValue
     * @example
     * // Get one FieldValue
     * const fieldValue = await prisma.fieldValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FieldValueFindUniqueOrThrowArgs>(args: SelectSubset<T, FieldValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueFindFirstArgs} args - Arguments to find a FieldValue
     * @example
     * // Get one FieldValue
     * const fieldValue = await prisma.fieldValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FieldValueFindFirstArgs>(args?: SelectSubset<T, FieldValueFindFirstArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FieldValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueFindFirstOrThrowArgs} args - Arguments to find a FieldValue
     * @example
     * // Get one FieldValue
     * const fieldValue = await prisma.fieldValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FieldValueFindFirstOrThrowArgs>(args?: SelectSubset<T, FieldValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FieldValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FieldValues
     * const fieldValues = await prisma.fieldValue.findMany()
     * 
     * // Get first 10 FieldValues
     * const fieldValues = await prisma.fieldValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldValueWithIdOnly = await prisma.fieldValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FieldValueFindManyArgs>(args?: SelectSubset<T, FieldValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FieldValue.
     * @param {FieldValueCreateArgs} args - Arguments to create a FieldValue.
     * @example
     * // Create one FieldValue
     * const FieldValue = await prisma.fieldValue.create({
     *   data: {
     *     // ... data to create a FieldValue
     *   }
     * })
     * 
     */
    create<T extends FieldValueCreateArgs>(args: SelectSubset<T, FieldValueCreateArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FieldValues.
     * @param {FieldValueCreateManyArgs} args - Arguments to create many FieldValues.
     * @example
     * // Create many FieldValues
     * const fieldValue = await prisma.fieldValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FieldValueCreateManyArgs>(args?: SelectSubset<T, FieldValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FieldValues and returns the data saved in the database.
     * @param {FieldValueCreateManyAndReturnArgs} args - Arguments to create many FieldValues.
     * @example
     * // Create many FieldValues
     * const fieldValue = await prisma.fieldValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FieldValues and only return the `id`
     * const fieldValueWithIdOnly = await prisma.fieldValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FieldValueCreateManyAndReturnArgs>(args?: SelectSubset<T, FieldValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FieldValue.
     * @param {FieldValueDeleteArgs} args - Arguments to delete one FieldValue.
     * @example
     * // Delete one FieldValue
     * const FieldValue = await prisma.fieldValue.delete({
     *   where: {
     *     // ... filter to delete one FieldValue
     *   }
     * })
     * 
     */
    delete<T extends FieldValueDeleteArgs>(args: SelectSubset<T, FieldValueDeleteArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FieldValue.
     * @param {FieldValueUpdateArgs} args - Arguments to update one FieldValue.
     * @example
     * // Update one FieldValue
     * const fieldValue = await prisma.fieldValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FieldValueUpdateArgs>(args: SelectSubset<T, FieldValueUpdateArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FieldValues.
     * @param {FieldValueDeleteManyArgs} args - Arguments to filter FieldValues to delete.
     * @example
     * // Delete a few FieldValues
     * const { count } = await prisma.fieldValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FieldValueDeleteManyArgs>(args?: SelectSubset<T, FieldValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FieldValues
     * const fieldValue = await prisma.fieldValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FieldValueUpdateManyArgs>(args: SelectSubset<T, FieldValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FieldValues and returns the data updated in the database.
     * @param {FieldValueUpdateManyAndReturnArgs} args - Arguments to update many FieldValues.
     * @example
     * // Update many FieldValues
     * const fieldValue = await prisma.fieldValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FieldValues and only return the `id`
     * const fieldValueWithIdOnly = await prisma.fieldValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FieldValueUpdateManyAndReturnArgs>(args: SelectSubset<T, FieldValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FieldValue.
     * @param {FieldValueUpsertArgs} args - Arguments to update or create a FieldValue.
     * @example
     * // Update or create a FieldValue
     * const fieldValue = await prisma.fieldValue.upsert({
     *   create: {
     *     // ... data to create a FieldValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FieldValue we want to update
     *   }
     * })
     */
    upsert<T extends FieldValueUpsertArgs>(args: SelectSubset<T, FieldValueUpsertArgs<ExtArgs>>): Prisma__FieldValueClient<$Result.GetResult<Prisma.$FieldValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueCountArgs} args - Arguments to filter FieldValues to count.
     * @example
     * // Count the number of FieldValues
     * const count = await prisma.fieldValue.count({
     *   where: {
     *     // ... the filter for the FieldValues we want to count
     *   }
     * })
    **/
    count<T extends FieldValueCountArgs>(
      args?: Subset<T, FieldValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldValueAggregateArgs>(args: Subset<T, FieldValueAggregateArgs>): Prisma.PrismaPromise<GetFieldValueAggregateType<T>>

    /**
     * Group by FieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FieldValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FieldValueGroupByArgs['orderBy'] }
        : { orderBy?: FieldValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FieldValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FieldValue model
   */
  readonly fields: FieldValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FieldValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FieldValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FieldValue$facilityArgs<ExtArgs> = {}>(args?: Subset<T, FieldValue$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FieldValue model
   */
  interface FieldValueFieldRefs {
    readonly id: FieldRef<"FieldValue", 'Int'>
    readonly field_id: FieldRef<"FieldValue", 'Int'>
    readonly report_month: FieldRef<"FieldValue", 'String'>
    readonly string_value: FieldRef<"FieldValue", 'String'>
    readonly numeric_value: FieldRef<"FieldValue", 'Decimal'>
    readonly boolean_value: FieldRef<"FieldValue", 'Boolean'>
    readonly json_value: FieldRef<"FieldValue", 'Json'>
    readonly uploaded_by: FieldRef<"FieldValue", 'Int'>
    readonly remarks: FieldRef<"FieldValue", 'String'>
    readonly created_at: FieldRef<"FieldValue", 'DateTime'>
    readonly updated_at: FieldRef<"FieldValue", 'DateTime'>
    readonly is_override: FieldRef<"FieldValue", 'Boolean'>
    readonly override_reason: FieldRef<"FieldValue", 'String'>
    readonly facility_id: FieldRef<"FieldValue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FieldValue findUnique
   */
  export type FieldValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * Filter, which FieldValue to fetch.
     */
    where: FieldValueWhereUniqueInput
  }

  /**
   * FieldValue findUniqueOrThrow
   */
  export type FieldValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * Filter, which FieldValue to fetch.
     */
    where: FieldValueWhereUniqueInput
  }

  /**
   * FieldValue findFirst
   */
  export type FieldValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * Filter, which FieldValue to fetch.
     */
    where?: FieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldValues to fetch.
     */
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldValues.
     */
    cursor?: FieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldValues.
     */
    distinct?: FieldValueScalarFieldEnum | FieldValueScalarFieldEnum[]
  }

  /**
   * FieldValue findFirstOrThrow
   */
  export type FieldValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * Filter, which FieldValue to fetch.
     */
    where?: FieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldValues to fetch.
     */
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FieldValues.
     */
    cursor?: FieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FieldValues.
     */
    distinct?: FieldValueScalarFieldEnum | FieldValueScalarFieldEnum[]
  }

  /**
   * FieldValue findMany
   */
  export type FieldValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * Filter, which FieldValues to fetch.
     */
    where?: FieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FieldValues to fetch.
     */
    orderBy?: FieldValueOrderByWithRelationInput | FieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FieldValues.
     */
    cursor?: FieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FieldValues.
     */
    skip?: number
    distinct?: FieldValueScalarFieldEnum | FieldValueScalarFieldEnum[]
  }

  /**
   * FieldValue create
   */
  export type FieldValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * The data needed to create a FieldValue.
     */
    data: XOR<FieldValueCreateInput, FieldValueUncheckedCreateInput>
  }

  /**
   * FieldValue createMany
   */
  export type FieldValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FieldValues.
     */
    data: FieldValueCreateManyInput | FieldValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FieldValue createManyAndReturn
   */
  export type FieldValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * The data used to create many FieldValues.
     */
    data: FieldValueCreateManyInput | FieldValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FieldValue update
   */
  export type FieldValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * The data needed to update a FieldValue.
     */
    data: XOR<FieldValueUpdateInput, FieldValueUncheckedUpdateInput>
    /**
     * Choose, which FieldValue to update.
     */
    where: FieldValueWhereUniqueInput
  }

  /**
   * FieldValue updateMany
   */
  export type FieldValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FieldValues.
     */
    data: XOR<FieldValueUpdateManyMutationInput, FieldValueUncheckedUpdateManyInput>
    /**
     * Filter which FieldValues to update
     */
    where?: FieldValueWhereInput
    /**
     * Limit how many FieldValues to update.
     */
    limit?: number
  }

  /**
   * FieldValue updateManyAndReturn
   */
  export type FieldValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * The data used to update FieldValues.
     */
    data: XOR<FieldValueUpdateManyMutationInput, FieldValueUncheckedUpdateManyInput>
    /**
     * Filter which FieldValues to update
     */
    where?: FieldValueWhereInput
    /**
     * Limit how many FieldValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FieldValue upsert
   */
  export type FieldValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * The filter to search for the FieldValue to update in case it exists.
     */
    where: FieldValueWhereUniqueInput
    /**
     * In case the FieldValue found by the `where` argument doesn't exist, create a new FieldValue with this data.
     */
    create: XOR<FieldValueCreateInput, FieldValueUncheckedCreateInput>
    /**
     * In case the FieldValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FieldValueUpdateInput, FieldValueUncheckedUpdateInput>
  }

  /**
   * FieldValue delete
   */
  export type FieldValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
    /**
     * Filter which FieldValue to delete.
     */
    where: FieldValueWhereUniqueInput
  }

  /**
   * FieldValue deleteMany
   */
  export type FieldValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FieldValues to delete
     */
    where?: FieldValueWhereInput
    /**
     * Limit how many FieldValues to delete.
     */
    limit?: number
  }

  /**
   * FieldValue.facility
   */
  export type FieldValue$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * FieldValue without action
   */
  export type FieldValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldValue
     */
    select?: FieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FieldValue
     */
    omit?: FieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FieldValueInclude<ExtArgs> | null
  }


  /**
   * Model FacilityFieldDefaults
   */

  export type AggregateFacilityFieldDefaults = {
    _count: FacilityFieldDefaultsCountAggregateOutputType | null
    _avg: FacilityFieldDefaultsAvgAggregateOutputType | null
    _sum: FacilityFieldDefaultsSumAggregateOutputType | null
    _min: FacilityFieldDefaultsMinAggregateOutputType | null
    _max: FacilityFieldDefaultsMaxAggregateOutputType | null
  }

  export type FacilityFieldDefaultsAvgAggregateOutputType = {
    id: number | null
    field_id: number | null
    numeric_value: Decimal | null
  }

  export type FacilityFieldDefaultsSumAggregateOutputType = {
    id: number | null
    field_id: number | null
    numeric_value: Decimal | null
  }

  export type FacilityFieldDefaultsMinAggregateOutputType = {
    id: number | null
    field_id: number | null
    string_value: string | null
    numeric_value: Decimal | null
    boolean_value: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    facility_id: string | null
  }

  export type FacilityFieldDefaultsMaxAggregateOutputType = {
    id: number | null
    field_id: number | null
    string_value: string | null
    numeric_value: Decimal | null
    boolean_value: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    facility_id: string | null
  }

  export type FacilityFieldDefaultsCountAggregateOutputType = {
    id: number
    field_id: number
    string_value: number
    numeric_value: number
    boolean_value: number
    json_value: number
    is_active: number
    created_at: number
    updated_at: number
    facility_id: number
    _all: number
  }


  export type FacilityFieldDefaultsAvgAggregateInputType = {
    id?: true
    field_id?: true
    numeric_value?: true
  }

  export type FacilityFieldDefaultsSumAggregateInputType = {
    id?: true
    field_id?: true
    numeric_value?: true
  }

  export type FacilityFieldDefaultsMinAggregateInputType = {
    id?: true
    field_id?: true
    string_value?: true
    numeric_value?: true
    boolean_value?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
  }

  export type FacilityFieldDefaultsMaxAggregateInputType = {
    id?: true
    field_id?: true
    string_value?: true
    numeric_value?: true
    boolean_value?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
  }

  export type FacilityFieldDefaultsCountAggregateInputType = {
    id?: true
    field_id?: true
    string_value?: true
    numeric_value?: true
    boolean_value?: true
    json_value?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
    _all?: true
  }

  export type FacilityFieldDefaultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityFieldDefaults to aggregate.
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldDefaults to fetch.
     */
    orderBy?: FacilityFieldDefaultsOrderByWithRelationInput | FacilityFieldDefaultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityFieldDefaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityFieldDefaults
    **/
    _count?: true | FacilityFieldDefaultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityFieldDefaultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilityFieldDefaultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityFieldDefaultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityFieldDefaultsMaxAggregateInputType
  }

  export type GetFacilityFieldDefaultsAggregateType<T extends FacilityFieldDefaultsAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityFieldDefaults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityFieldDefaults[P]>
      : GetScalarType<T[P], AggregateFacilityFieldDefaults[P]>
  }




  export type FacilityFieldDefaultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityFieldDefaultsWhereInput
    orderBy?: FacilityFieldDefaultsOrderByWithAggregationInput | FacilityFieldDefaultsOrderByWithAggregationInput[]
    by: FacilityFieldDefaultsScalarFieldEnum[] | FacilityFieldDefaultsScalarFieldEnum
    having?: FacilityFieldDefaultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityFieldDefaultsCountAggregateInputType | true
    _avg?: FacilityFieldDefaultsAvgAggregateInputType
    _sum?: FacilityFieldDefaultsSumAggregateInputType
    _min?: FacilityFieldDefaultsMinAggregateInputType
    _max?: FacilityFieldDefaultsMaxAggregateInputType
  }

  export type FacilityFieldDefaultsGroupByOutputType = {
    id: number
    field_id: number
    string_value: string | null
    numeric_value: Decimal | null
    boolean_value: boolean | null
    json_value: JsonValue | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    facility_id: string
    _count: FacilityFieldDefaultsCountAggregateOutputType | null
    _avg: FacilityFieldDefaultsAvgAggregateOutputType | null
    _sum: FacilityFieldDefaultsSumAggregateOutputType | null
    _min: FacilityFieldDefaultsMinAggregateOutputType | null
    _max: FacilityFieldDefaultsMaxAggregateOutputType | null
  }

  type GetFacilityFieldDefaultsGroupByPayload<T extends FacilityFieldDefaultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityFieldDefaultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityFieldDefaultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityFieldDefaultsGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityFieldDefaultsGroupByOutputType[P]>
        }
      >
    >


  export type FacilityFieldDefaultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityFieldDefaults"]>

  export type FacilityFieldDefaultsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityFieldDefaults"]>

  export type FacilityFieldDefaultsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityFieldDefaults"]>

  export type FacilityFieldDefaultsSelectScalar = {
    id?: boolean
    field_id?: boolean
    string_value?: boolean
    numeric_value?: boolean
    boolean_value?: boolean
    json_value?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
  }

  export type FacilityFieldDefaultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "field_id" | "string_value" | "numeric_value" | "boolean_value" | "json_value" | "is_active" | "created_at" | "updated_at" | "facility_id", ExtArgs["result"]["facilityFieldDefaults"]>
  export type FacilityFieldDefaultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }
  export type FacilityFieldDefaultsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }
  export type FacilityFieldDefaultsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }

  export type $FacilityFieldDefaultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityFieldDefaults"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      field_id: number
      string_value: string | null
      numeric_value: Prisma.Decimal | null
      boolean_value: boolean | null
      json_value: Prisma.JsonValue | null
      is_active: boolean
      created_at: Date
      updated_at: Date
      facility_id: string
    }, ExtArgs["result"]["facilityFieldDefaults"]>
    composites: {}
  }

  type FacilityFieldDefaultsGetPayload<S extends boolean | null | undefined | FacilityFieldDefaultsDefaultArgs> = $Result.GetResult<Prisma.$FacilityFieldDefaultsPayload, S>

  type FacilityFieldDefaultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityFieldDefaultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityFieldDefaultsCountAggregateInputType | true
    }

  export interface FacilityFieldDefaultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityFieldDefaults'], meta: { name: 'FacilityFieldDefaults' } }
    /**
     * Find zero or one FacilityFieldDefaults that matches the filter.
     * @param {FacilityFieldDefaultsFindUniqueArgs} args - Arguments to find a FacilityFieldDefaults
     * @example
     * // Get one FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFieldDefaultsFindUniqueArgs>(args: SelectSubset<T, FacilityFieldDefaultsFindUniqueArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacilityFieldDefaults that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFieldDefaultsFindUniqueOrThrowArgs} args - Arguments to find a FacilityFieldDefaults
     * @example
     * // Get one FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFieldDefaultsFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFieldDefaultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityFieldDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsFindFirstArgs} args - Arguments to find a FacilityFieldDefaults
     * @example
     * // Get one FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFieldDefaultsFindFirstArgs>(args?: SelectSubset<T, FacilityFieldDefaultsFindFirstArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityFieldDefaults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsFindFirstOrThrowArgs} args - Arguments to find a FacilityFieldDefaults
     * @example
     * // Get one FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFieldDefaultsFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFieldDefaultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacilityFieldDefaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findMany()
     * 
     * // Get first 10 FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityFieldDefaultsWithIdOnly = await prisma.facilityFieldDefaults.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityFieldDefaultsFindManyArgs>(args?: SelectSubset<T, FacilityFieldDefaultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacilityFieldDefaults.
     * @param {FacilityFieldDefaultsCreateArgs} args - Arguments to create a FacilityFieldDefaults.
     * @example
     * // Create one FacilityFieldDefaults
     * const FacilityFieldDefaults = await prisma.facilityFieldDefaults.create({
     *   data: {
     *     // ... data to create a FacilityFieldDefaults
     *   }
     * })
     * 
     */
    create<T extends FacilityFieldDefaultsCreateArgs>(args: SelectSubset<T, FacilityFieldDefaultsCreateArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacilityFieldDefaults.
     * @param {FacilityFieldDefaultsCreateManyArgs} args - Arguments to create many FacilityFieldDefaults.
     * @example
     * // Create many FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityFieldDefaultsCreateManyArgs>(args?: SelectSubset<T, FacilityFieldDefaultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityFieldDefaults and returns the data saved in the database.
     * @param {FacilityFieldDefaultsCreateManyAndReturnArgs} args - Arguments to create many FacilityFieldDefaults.
     * @example
     * // Create many FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityFieldDefaults and only return the `id`
     * const facilityFieldDefaultsWithIdOnly = await prisma.facilityFieldDefaults.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityFieldDefaultsCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityFieldDefaultsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacilityFieldDefaults.
     * @param {FacilityFieldDefaultsDeleteArgs} args - Arguments to delete one FacilityFieldDefaults.
     * @example
     * // Delete one FacilityFieldDefaults
     * const FacilityFieldDefaults = await prisma.facilityFieldDefaults.delete({
     *   where: {
     *     // ... filter to delete one FacilityFieldDefaults
     *   }
     * })
     * 
     */
    delete<T extends FacilityFieldDefaultsDeleteArgs>(args: SelectSubset<T, FacilityFieldDefaultsDeleteArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacilityFieldDefaults.
     * @param {FacilityFieldDefaultsUpdateArgs} args - Arguments to update one FacilityFieldDefaults.
     * @example
     * // Update one FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityFieldDefaultsUpdateArgs>(args: SelectSubset<T, FacilityFieldDefaultsUpdateArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacilityFieldDefaults.
     * @param {FacilityFieldDefaultsDeleteManyArgs} args - Arguments to filter FacilityFieldDefaults to delete.
     * @example
     * // Delete a few FacilityFieldDefaults
     * const { count } = await prisma.facilityFieldDefaults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityFieldDefaultsDeleteManyArgs>(args?: SelectSubset<T, FacilityFieldDefaultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityFieldDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityFieldDefaultsUpdateManyArgs>(args: SelectSubset<T, FacilityFieldDefaultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityFieldDefaults and returns the data updated in the database.
     * @param {FacilityFieldDefaultsUpdateManyAndReturnArgs} args - Arguments to update many FacilityFieldDefaults.
     * @example
     * // Update many FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacilityFieldDefaults and only return the `id`
     * const facilityFieldDefaultsWithIdOnly = await prisma.facilityFieldDefaults.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityFieldDefaultsUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityFieldDefaultsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacilityFieldDefaults.
     * @param {FacilityFieldDefaultsUpsertArgs} args - Arguments to update or create a FacilityFieldDefaults.
     * @example
     * // Update or create a FacilityFieldDefaults
     * const facilityFieldDefaults = await prisma.facilityFieldDefaults.upsert({
     *   create: {
     *     // ... data to create a FacilityFieldDefaults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityFieldDefaults we want to update
     *   }
     * })
     */
    upsert<T extends FacilityFieldDefaultsUpsertArgs>(args: SelectSubset<T, FacilityFieldDefaultsUpsertArgs<ExtArgs>>): Prisma__FacilityFieldDefaultsClient<$Result.GetResult<Prisma.$FacilityFieldDefaultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacilityFieldDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsCountArgs} args - Arguments to filter FacilityFieldDefaults to count.
     * @example
     * // Count the number of FacilityFieldDefaults
     * const count = await prisma.facilityFieldDefaults.count({
     *   where: {
     *     // ... the filter for the FacilityFieldDefaults we want to count
     *   }
     * })
    **/
    count<T extends FacilityFieldDefaultsCountArgs>(
      args?: Subset<T, FacilityFieldDefaultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityFieldDefaultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityFieldDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityFieldDefaultsAggregateArgs>(args: Subset<T, FacilityFieldDefaultsAggregateArgs>): Prisma.PrismaPromise<GetFacilityFieldDefaultsAggregateType<T>>

    /**
     * Group by FacilityFieldDefaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldDefaultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityFieldDefaultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityFieldDefaultsGroupByArgs['orderBy'] }
        : { orderBy?: FacilityFieldDefaultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityFieldDefaultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityFieldDefaultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityFieldDefaults model
   */
  readonly fields: FacilityFieldDefaultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityFieldDefaults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityFieldDefaultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityFieldDefaults model
   */
  interface FacilityFieldDefaultsFieldRefs {
    readonly id: FieldRef<"FacilityFieldDefaults", 'Int'>
    readonly field_id: FieldRef<"FacilityFieldDefaults", 'Int'>
    readonly string_value: FieldRef<"FacilityFieldDefaults", 'String'>
    readonly numeric_value: FieldRef<"FacilityFieldDefaults", 'Decimal'>
    readonly boolean_value: FieldRef<"FacilityFieldDefaults", 'Boolean'>
    readonly json_value: FieldRef<"FacilityFieldDefaults", 'Json'>
    readonly is_active: FieldRef<"FacilityFieldDefaults", 'Boolean'>
    readonly created_at: FieldRef<"FacilityFieldDefaults", 'DateTime'>
    readonly updated_at: FieldRef<"FacilityFieldDefaults", 'DateTime'>
    readonly facility_id: FieldRef<"FacilityFieldDefaults", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FacilityFieldDefaults findUnique
   */
  export type FacilityFieldDefaultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldDefaults to fetch.
     */
    where: FacilityFieldDefaultsWhereUniqueInput
  }

  /**
   * FacilityFieldDefaults findUniqueOrThrow
   */
  export type FacilityFieldDefaultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldDefaults to fetch.
     */
    where: FacilityFieldDefaultsWhereUniqueInput
  }

  /**
   * FacilityFieldDefaults findFirst
   */
  export type FacilityFieldDefaultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldDefaults to fetch.
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldDefaults to fetch.
     */
    orderBy?: FacilityFieldDefaultsOrderByWithRelationInput | FacilityFieldDefaultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityFieldDefaults.
     */
    cursor?: FacilityFieldDefaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityFieldDefaults.
     */
    distinct?: FacilityFieldDefaultsScalarFieldEnum | FacilityFieldDefaultsScalarFieldEnum[]
  }

  /**
   * FacilityFieldDefaults findFirstOrThrow
   */
  export type FacilityFieldDefaultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldDefaults to fetch.
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldDefaults to fetch.
     */
    orderBy?: FacilityFieldDefaultsOrderByWithRelationInput | FacilityFieldDefaultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityFieldDefaults.
     */
    cursor?: FacilityFieldDefaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldDefaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityFieldDefaults.
     */
    distinct?: FacilityFieldDefaultsScalarFieldEnum | FacilityFieldDefaultsScalarFieldEnum[]
  }

  /**
   * FacilityFieldDefaults findMany
   */
  export type FacilityFieldDefaultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldDefaults to fetch.
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldDefaults to fetch.
     */
    orderBy?: FacilityFieldDefaultsOrderByWithRelationInput | FacilityFieldDefaultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityFieldDefaults.
     */
    cursor?: FacilityFieldDefaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldDefaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldDefaults.
     */
    skip?: number
    distinct?: FacilityFieldDefaultsScalarFieldEnum | FacilityFieldDefaultsScalarFieldEnum[]
  }

  /**
   * FacilityFieldDefaults create
   */
  export type FacilityFieldDefaultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityFieldDefaults.
     */
    data: XOR<FacilityFieldDefaultsCreateInput, FacilityFieldDefaultsUncheckedCreateInput>
  }

  /**
   * FacilityFieldDefaults createMany
   */
  export type FacilityFieldDefaultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityFieldDefaults.
     */
    data: FacilityFieldDefaultsCreateManyInput | FacilityFieldDefaultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityFieldDefaults createManyAndReturn
   */
  export type FacilityFieldDefaultsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * The data used to create many FacilityFieldDefaults.
     */
    data: FacilityFieldDefaultsCreateManyInput | FacilityFieldDefaultsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityFieldDefaults update
   */
  export type FacilityFieldDefaultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityFieldDefaults.
     */
    data: XOR<FacilityFieldDefaultsUpdateInput, FacilityFieldDefaultsUncheckedUpdateInput>
    /**
     * Choose, which FacilityFieldDefaults to update.
     */
    where: FacilityFieldDefaultsWhereUniqueInput
  }

  /**
   * FacilityFieldDefaults updateMany
   */
  export type FacilityFieldDefaultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityFieldDefaults.
     */
    data: XOR<FacilityFieldDefaultsUpdateManyMutationInput, FacilityFieldDefaultsUncheckedUpdateManyInput>
    /**
     * Filter which FacilityFieldDefaults to update
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * Limit how many FacilityFieldDefaults to update.
     */
    limit?: number
  }

  /**
   * FacilityFieldDefaults updateManyAndReturn
   */
  export type FacilityFieldDefaultsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * The data used to update FacilityFieldDefaults.
     */
    data: XOR<FacilityFieldDefaultsUpdateManyMutationInput, FacilityFieldDefaultsUncheckedUpdateManyInput>
    /**
     * Filter which FacilityFieldDefaults to update
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * Limit how many FacilityFieldDefaults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityFieldDefaults upsert
   */
  export type FacilityFieldDefaultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityFieldDefaults to update in case it exists.
     */
    where: FacilityFieldDefaultsWhereUniqueInput
    /**
     * In case the FacilityFieldDefaults found by the `where` argument doesn't exist, create a new FacilityFieldDefaults with this data.
     */
    create: XOR<FacilityFieldDefaultsCreateInput, FacilityFieldDefaultsUncheckedCreateInput>
    /**
     * In case the FacilityFieldDefaults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityFieldDefaultsUpdateInput, FacilityFieldDefaultsUncheckedUpdateInput>
  }

  /**
   * FacilityFieldDefaults delete
   */
  export type FacilityFieldDefaultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
    /**
     * Filter which FacilityFieldDefaults to delete.
     */
    where: FacilityFieldDefaultsWhereUniqueInput
  }

  /**
   * FacilityFieldDefaults deleteMany
   */
  export type FacilityFieldDefaultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityFieldDefaults to delete
     */
    where?: FacilityFieldDefaultsWhereInput
    /**
     * Limit how many FacilityFieldDefaults to delete.
     */
    limit?: number
  }

  /**
   * FacilityFieldDefaults without action
   */
  export type FacilityFieldDefaultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldDefaults
     */
    select?: FacilityFieldDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldDefaults
     */
    omit?: FacilityFieldDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldDefaultsInclude<ExtArgs> | null
  }


  /**
   * Model FacilityFieldMapping
   */

  export type AggregateFacilityFieldMapping = {
    _count: FacilityFieldMappingCountAggregateOutputType | null
    _avg: FacilityFieldMappingAvgAggregateOutputType | null
    _sum: FacilityFieldMappingSumAggregateOutputType | null
    _min: FacilityFieldMappingMinAggregateOutputType | null
    _max: FacilityFieldMappingMaxAggregateOutputType | null
  }

  export type FacilityFieldMappingAvgAggregateOutputType = {
    id: number | null
    field_id: number | null
    display_order: number | null
  }

  export type FacilityFieldMappingSumAggregateOutputType = {
    id: number | null
    field_id: number | null
    display_order: number | null
  }

  export type FacilityFieldMappingMinAggregateOutputType = {
    id: number | null
    field_id: number | null
    is_required: boolean | null
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    facility_type_id: string | null
  }

  export type FacilityFieldMappingMaxAggregateOutputType = {
    id: number | null
    field_id: number | null
    is_required: boolean | null
    display_order: number | null
    created_at: Date | null
    updated_at: Date | null
    facility_type_id: string | null
  }

  export type FacilityFieldMappingCountAggregateOutputType = {
    id: number
    field_id: number
    is_required: number
    display_order: number
    created_at: number
    updated_at: number
    facility_type_id: number
    _all: number
  }


  export type FacilityFieldMappingAvgAggregateInputType = {
    id?: true
    field_id?: true
    display_order?: true
  }

  export type FacilityFieldMappingSumAggregateInputType = {
    id?: true
    field_id?: true
    display_order?: true
  }

  export type FacilityFieldMappingMinAggregateInputType = {
    id?: true
    field_id?: true
    is_required?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    facility_type_id?: true
  }

  export type FacilityFieldMappingMaxAggregateInputType = {
    id?: true
    field_id?: true
    is_required?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    facility_type_id?: true
  }

  export type FacilityFieldMappingCountAggregateInputType = {
    id?: true
    field_id?: true
    is_required?: true
    display_order?: true
    created_at?: true
    updated_at?: true
    facility_type_id?: true
    _all?: true
  }

  export type FacilityFieldMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityFieldMapping to aggregate.
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldMappings to fetch.
     */
    orderBy?: FacilityFieldMappingOrderByWithRelationInput | FacilityFieldMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityFieldMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityFieldMappings
    **/
    _count?: true | FacilityFieldMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityFieldMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilityFieldMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityFieldMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityFieldMappingMaxAggregateInputType
  }

  export type GetFacilityFieldMappingAggregateType<T extends FacilityFieldMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityFieldMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityFieldMapping[P]>
      : GetScalarType<T[P], AggregateFacilityFieldMapping[P]>
  }




  export type FacilityFieldMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityFieldMappingWhereInput
    orderBy?: FacilityFieldMappingOrderByWithAggregationInput | FacilityFieldMappingOrderByWithAggregationInput[]
    by: FacilityFieldMappingScalarFieldEnum[] | FacilityFieldMappingScalarFieldEnum
    having?: FacilityFieldMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityFieldMappingCountAggregateInputType | true
    _avg?: FacilityFieldMappingAvgAggregateInputType
    _sum?: FacilityFieldMappingSumAggregateInputType
    _min?: FacilityFieldMappingMinAggregateInputType
    _max?: FacilityFieldMappingMaxAggregateInputType
  }

  export type FacilityFieldMappingGroupByOutputType = {
    id: number
    field_id: number
    is_required: boolean
    display_order: number
    created_at: Date
    updated_at: Date
    facility_type_id: string
    _count: FacilityFieldMappingCountAggregateOutputType | null
    _avg: FacilityFieldMappingAvgAggregateOutputType | null
    _sum: FacilityFieldMappingSumAggregateOutputType | null
    _min: FacilityFieldMappingMinAggregateOutputType | null
    _max: FacilityFieldMappingMaxAggregateOutputType | null
  }

  type GetFacilityFieldMappingGroupByPayload<T extends FacilityFieldMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityFieldMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityFieldMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityFieldMappingGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityFieldMappingGroupByOutputType[P]>
        }
      >
    >


  export type FacilityFieldMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    is_required?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityFieldMapping"]>

  export type FacilityFieldMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    is_required?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityFieldMapping"]>

  export type FacilityFieldMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_id?: boolean
    is_required?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityFieldMapping"]>

  export type FacilityFieldMappingSelectScalar = {
    id?: boolean
    field_id?: boolean
    is_required?: boolean
    display_order?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
  }

  export type FacilityFieldMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "field_id" | "is_required" | "display_order" | "created_at" | "updated_at" | "facility_type_id", ExtArgs["result"]["facilityFieldMapping"]>
  export type FacilityFieldMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }
  export type FacilityFieldMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }
  export type FacilityFieldMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    field?: boolean | FieldDefaultArgs<ExtArgs>
  }

  export type $FacilityFieldMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityFieldMapping"
    objects: {
      facility_type: Prisma.$FacilityTypePayload<ExtArgs>
      field: Prisma.$FieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      field_id: number
      is_required: boolean
      display_order: number
      created_at: Date
      updated_at: Date
      facility_type_id: string
    }, ExtArgs["result"]["facilityFieldMapping"]>
    composites: {}
  }

  type FacilityFieldMappingGetPayload<S extends boolean | null | undefined | FacilityFieldMappingDefaultArgs> = $Result.GetResult<Prisma.$FacilityFieldMappingPayload, S>

  type FacilityFieldMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityFieldMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityFieldMappingCountAggregateInputType | true
    }

  export interface FacilityFieldMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityFieldMapping'], meta: { name: 'FacilityFieldMapping' } }
    /**
     * Find zero or one FacilityFieldMapping that matches the filter.
     * @param {FacilityFieldMappingFindUniqueArgs} args - Arguments to find a FacilityFieldMapping
     * @example
     * // Get one FacilityFieldMapping
     * const facilityFieldMapping = await prisma.facilityFieldMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFieldMappingFindUniqueArgs>(args: SelectSubset<T, FacilityFieldMappingFindUniqueArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacilityFieldMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFieldMappingFindUniqueOrThrowArgs} args - Arguments to find a FacilityFieldMapping
     * @example
     * // Get one FacilityFieldMapping
     * const facilityFieldMapping = await prisma.facilityFieldMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFieldMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFieldMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityFieldMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingFindFirstArgs} args - Arguments to find a FacilityFieldMapping
     * @example
     * // Get one FacilityFieldMapping
     * const facilityFieldMapping = await prisma.facilityFieldMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFieldMappingFindFirstArgs>(args?: SelectSubset<T, FacilityFieldMappingFindFirstArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityFieldMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingFindFirstOrThrowArgs} args - Arguments to find a FacilityFieldMapping
     * @example
     * // Get one FacilityFieldMapping
     * const facilityFieldMapping = await prisma.facilityFieldMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFieldMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFieldMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacilityFieldMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityFieldMappings
     * const facilityFieldMappings = await prisma.facilityFieldMapping.findMany()
     * 
     * // Get first 10 FacilityFieldMappings
     * const facilityFieldMappings = await prisma.facilityFieldMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityFieldMappingWithIdOnly = await prisma.facilityFieldMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityFieldMappingFindManyArgs>(args?: SelectSubset<T, FacilityFieldMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacilityFieldMapping.
     * @param {FacilityFieldMappingCreateArgs} args - Arguments to create a FacilityFieldMapping.
     * @example
     * // Create one FacilityFieldMapping
     * const FacilityFieldMapping = await prisma.facilityFieldMapping.create({
     *   data: {
     *     // ... data to create a FacilityFieldMapping
     *   }
     * })
     * 
     */
    create<T extends FacilityFieldMappingCreateArgs>(args: SelectSubset<T, FacilityFieldMappingCreateArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacilityFieldMappings.
     * @param {FacilityFieldMappingCreateManyArgs} args - Arguments to create many FacilityFieldMappings.
     * @example
     * // Create many FacilityFieldMappings
     * const facilityFieldMapping = await prisma.facilityFieldMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityFieldMappingCreateManyArgs>(args?: SelectSubset<T, FacilityFieldMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityFieldMappings and returns the data saved in the database.
     * @param {FacilityFieldMappingCreateManyAndReturnArgs} args - Arguments to create many FacilityFieldMappings.
     * @example
     * // Create many FacilityFieldMappings
     * const facilityFieldMapping = await prisma.facilityFieldMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityFieldMappings and only return the `id`
     * const facilityFieldMappingWithIdOnly = await prisma.facilityFieldMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityFieldMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityFieldMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacilityFieldMapping.
     * @param {FacilityFieldMappingDeleteArgs} args - Arguments to delete one FacilityFieldMapping.
     * @example
     * // Delete one FacilityFieldMapping
     * const FacilityFieldMapping = await prisma.facilityFieldMapping.delete({
     *   where: {
     *     // ... filter to delete one FacilityFieldMapping
     *   }
     * })
     * 
     */
    delete<T extends FacilityFieldMappingDeleteArgs>(args: SelectSubset<T, FacilityFieldMappingDeleteArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacilityFieldMapping.
     * @param {FacilityFieldMappingUpdateArgs} args - Arguments to update one FacilityFieldMapping.
     * @example
     * // Update one FacilityFieldMapping
     * const facilityFieldMapping = await prisma.facilityFieldMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityFieldMappingUpdateArgs>(args: SelectSubset<T, FacilityFieldMappingUpdateArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacilityFieldMappings.
     * @param {FacilityFieldMappingDeleteManyArgs} args - Arguments to filter FacilityFieldMappings to delete.
     * @example
     * // Delete a few FacilityFieldMappings
     * const { count } = await prisma.facilityFieldMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityFieldMappingDeleteManyArgs>(args?: SelectSubset<T, FacilityFieldMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityFieldMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityFieldMappings
     * const facilityFieldMapping = await prisma.facilityFieldMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityFieldMappingUpdateManyArgs>(args: SelectSubset<T, FacilityFieldMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityFieldMappings and returns the data updated in the database.
     * @param {FacilityFieldMappingUpdateManyAndReturnArgs} args - Arguments to update many FacilityFieldMappings.
     * @example
     * // Update many FacilityFieldMappings
     * const facilityFieldMapping = await prisma.facilityFieldMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacilityFieldMappings and only return the `id`
     * const facilityFieldMappingWithIdOnly = await prisma.facilityFieldMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityFieldMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityFieldMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacilityFieldMapping.
     * @param {FacilityFieldMappingUpsertArgs} args - Arguments to update or create a FacilityFieldMapping.
     * @example
     * // Update or create a FacilityFieldMapping
     * const facilityFieldMapping = await prisma.facilityFieldMapping.upsert({
     *   create: {
     *     // ... data to create a FacilityFieldMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityFieldMapping we want to update
     *   }
     * })
     */
    upsert<T extends FacilityFieldMappingUpsertArgs>(args: SelectSubset<T, FacilityFieldMappingUpsertArgs<ExtArgs>>): Prisma__FacilityFieldMappingClient<$Result.GetResult<Prisma.$FacilityFieldMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacilityFieldMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingCountArgs} args - Arguments to filter FacilityFieldMappings to count.
     * @example
     * // Count the number of FacilityFieldMappings
     * const count = await prisma.facilityFieldMapping.count({
     *   where: {
     *     // ... the filter for the FacilityFieldMappings we want to count
     *   }
     * })
    **/
    count<T extends FacilityFieldMappingCountArgs>(
      args?: Subset<T, FacilityFieldMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityFieldMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityFieldMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityFieldMappingAggregateArgs>(args: Subset<T, FacilityFieldMappingAggregateArgs>): Prisma.PrismaPromise<GetFacilityFieldMappingAggregateType<T>>

    /**
     * Group by FacilityFieldMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFieldMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityFieldMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityFieldMappingGroupByArgs['orderBy'] }
        : { orderBy?: FacilityFieldMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityFieldMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityFieldMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityFieldMapping model
   */
  readonly fields: FacilityFieldMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityFieldMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityFieldMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility_type<T extends FacilityTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityTypeDefaultArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    field<T extends FieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FieldDefaultArgs<ExtArgs>>): Prisma__FieldClient<$Result.GetResult<Prisma.$FieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityFieldMapping model
   */
  interface FacilityFieldMappingFieldRefs {
    readonly id: FieldRef<"FacilityFieldMapping", 'Int'>
    readonly field_id: FieldRef<"FacilityFieldMapping", 'Int'>
    readonly is_required: FieldRef<"FacilityFieldMapping", 'Boolean'>
    readonly display_order: FieldRef<"FacilityFieldMapping", 'Int'>
    readonly created_at: FieldRef<"FacilityFieldMapping", 'DateTime'>
    readonly updated_at: FieldRef<"FacilityFieldMapping", 'DateTime'>
    readonly facility_type_id: FieldRef<"FacilityFieldMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FacilityFieldMapping findUnique
   */
  export type FacilityFieldMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldMapping to fetch.
     */
    where: FacilityFieldMappingWhereUniqueInput
  }

  /**
   * FacilityFieldMapping findUniqueOrThrow
   */
  export type FacilityFieldMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldMapping to fetch.
     */
    where: FacilityFieldMappingWhereUniqueInput
  }

  /**
   * FacilityFieldMapping findFirst
   */
  export type FacilityFieldMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldMapping to fetch.
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldMappings to fetch.
     */
    orderBy?: FacilityFieldMappingOrderByWithRelationInput | FacilityFieldMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityFieldMappings.
     */
    cursor?: FacilityFieldMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityFieldMappings.
     */
    distinct?: FacilityFieldMappingScalarFieldEnum | FacilityFieldMappingScalarFieldEnum[]
  }

  /**
   * FacilityFieldMapping findFirstOrThrow
   */
  export type FacilityFieldMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldMapping to fetch.
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldMappings to fetch.
     */
    orderBy?: FacilityFieldMappingOrderByWithRelationInput | FacilityFieldMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityFieldMappings.
     */
    cursor?: FacilityFieldMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityFieldMappings.
     */
    distinct?: FacilityFieldMappingScalarFieldEnum | FacilityFieldMappingScalarFieldEnum[]
  }

  /**
   * FacilityFieldMapping findMany
   */
  export type FacilityFieldMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * Filter, which FacilityFieldMappings to fetch.
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityFieldMappings to fetch.
     */
    orderBy?: FacilityFieldMappingOrderByWithRelationInput | FacilityFieldMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityFieldMappings.
     */
    cursor?: FacilityFieldMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityFieldMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityFieldMappings.
     */
    skip?: number
    distinct?: FacilityFieldMappingScalarFieldEnum | FacilityFieldMappingScalarFieldEnum[]
  }

  /**
   * FacilityFieldMapping create
   */
  export type FacilityFieldMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityFieldMapping.
     */
    data: XOR<FacilityFieldMappingCreateInput, FacilityFieldMappingUncheckedCreateInput>
  }

  /**
   * FacilityFieldMapping createMany
   */
  export type FacilityFieldMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityFieldMappings.
     */
    data: FacilityFieldMappingCreateManyInput | FacilityFieldMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityFieldMapping createManyAndReturn
   */
  export type FacilityFieldMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * The data used to create many FacilityFieldMappings.
     */
    data: FacilityFieldMappingCreateManyInput | FacilityFieldMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityFieldMapping update
   */
  export type FacilityFieldMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityFieldMapping.
     */
    data: XOR<FacilityFieldMappingUpdateInput, FacilityFieldMappingUncheckedUpdateInput>
    /**
     * Choose, which FacilityFieldMapping to update.
     */
    where: FacilityFieldMappingWhereUniqueInput
  }

  /**
   * FacilityFieldMapping updateMany
   */
  export type FacilityFieldMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityFieldMappings.
     */
    data: XOR<FacilityFieldMappingUpdateManyMutationInput, FacilityFieldMappingUncheckedUpdateManyInput>
    /**
     * Filter which FacilityFieldMappings to update
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * Limit how many FacilityFieldMappings to update.
     */
    limit?: number
  }

  /**
   * FacilityFieldMapping updateManyAndReturn
   */
  export type FacilityFieldMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * The data used to update FacilityFieldMappings.
     */
    data: XOR<FacilityFieldMappingUpdateManyMutationInput, FacilityFieldMappingUncheckedUpdateManyInput>
    /**
     * Filter which FacilityFieldMappings to update
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * Limit how many FacilityFieldMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityFieldMapping upsert
   */
  export type FacilityFieldMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityFieldMapping to update in case it exists.
     */
    where: FacilityFieldMappingWhereUniqueInput
    /**
     * In case the FacilityFieldMapping found by the `where` argument doesn't exist, create a new FacilityFieldMapping with this data.
     */
    create: XOR<FacilityFieldMappingCreateInput, FacilityFieldMappingUncheckedCreateInput>
    /**
     * In case the FacilityFieldMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityFieldMappingUpdateInput, FacilityFieldMappingUncheckedUpdateInput>
  }

  /**
   * FacilityFieldMapping delete
   */
  export type FacilityFieldMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
    /**
     * Filter which FacilityFieldMapping to delete.
     */
    where: FacilityFieldMappingWhereUniqueInput
  }

  /**
   * FacilityFieldMapping deleteMany
   */
  export type FacilityFieldMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityFieldMappings to delete
     */
    where?: FacilityFieldMappingWhereInput
    /**
     * Limit how many FacilityFieldMappings to delete.
     */
    limit?: number
  }

  /**
   * FacilityFieldMapping without action
   */
  export type FacilityFieldMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityFieldMapping
     */
    select?: FacilityFieldMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityFieldMapping
     */
    omit?: FacilityFieldMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityFieldMappingInclude<ExtArgs> | null
  }


  /**
   * Model sub_centre
   */

  export type AggregateSub_centre = {
    _count: Sub_centreCountAggregateOutputType | null
    _avg: Sub_centreAvgAggregateOutputType | null
    _sum: Sub_centreSumAggregateOutputType | null
    _min: Sub_centreMinAggregateOutputType | null
    _max: Sub_centreMaxAggregateOutputType | null
  }

  export type Sub_centreAvgAggregateOutputType = {
    id: number | null
  }

  export type Sub_centreSumAggregateOutputType = {
    id: number | null
  }

  export type Sub_centreMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    facility_id: string | null
  }

  export type Sub_centreMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    facility_id: string | null
  }

  export type Sub_centreCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    facility_id: number
    _all: number
  }


  export type Sub_centreAvgAggregateInputType = {
    id?: true
  }

  export type Sub_centreSumAggregateInputType = {
    id?: true
  }

  export type Sub_centreMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
  }

  export type Sub_centreMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
  }

  export type Sub_centreCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
    _all?: true
  }

  export type Sub_centreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_centre to aggregate.
     */
    where?: sub_centreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_centres to fetch.
     */
    orderBy?: sub_centreOrderByWithRelationInput | sub_centreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sub_centreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sub_centres
    **/
    _count?: true | Sub_centreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sub_centreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sub_centreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sub_centreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sub_centreMaxAggregateInputType
  }

  export type GetSub_centreAggregateType<T extends Sub_centreAggregateArgs> = {
        [P in keyof T & keyof AggregateSub_centre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSub_centre[P]>
      : GetScalarType<T[P], AggregateSub_centre[P]>
  }




  export type sub_centreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sub_centreWhereInput
    orderBy?: sub_centreOrderByWithAggregationInput | sub_centreOrderByWithAggregationInput[]
    by: Sub_centreScalarFieldEnum[] | Sub_centreScalarFieldEnum
    having?: sub_centreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sub_centreCountAggregateInputType | true
    _avg?: Sub_centreAvgAggregateInputType
    _sum?: Sub_centreSumAggregateInputType
    _min?: Sub_centreMinAggregateInputType
    _max?: Sub_centreMaxAggregateInputType
  }

  export type Sub_centreGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    facility_id: string
    _count: Sub_centreCountAggregateOutputType | null
    _avg: Sub_centreAvgAggregateOutputType | null
    _sum: Sub_centreSumAggregateOutputType | null
    _min: Sub_centreMinAggregateOutputType | null
    _max: Sub_centreMaxAggregateOutputType | null
  }

  type GetSub_centreGroupByPayload<T extends sub_centreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sub_centreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sub_centreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sub_centreGroupByOutputType[P]>
            : GetScalarType<T[P], Sub_centreGroupByOutputType[P]>
        }
      >
    >


  export type sub_centreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    monthly_health_data?: boolean | sub_centre$monthly_health_dataArgs<ExtArgs>
    performance_calculations?: boolean | sub_centre$performance_calculationsArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    _count?: boolean | Sub_centreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sub_centre"]>

  export type sub_centreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sub_centre"]>

  export type sub_centreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sub_centre"]>

  export type sub_centreSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
  }

  export type sub_centreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "updated_at" | "facility_id", ExtArgs["result"]["sub_centre"]>
  export type sub_centreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthly_health_data?: boolean | sub_centre$monthly_health_dataArgs<ExtArgs>
    performance_calculations?: boolean | sub_centre$performance_calculationsArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    _count?: boolean | Sub_centreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sub_centreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type sub_centreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }

  export type $sub_centrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sub_centre"
    objects: {
      monthly_health_data: Prisma.$MonthlyHealthDataPayload<ExtArgs>[]
      performance_calculations: Prisma.$PerformanceCalculationPayload<ExtArgs>[]
      facility: Prisma.$FacilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
      updated_at: Date
      facility_id: string
    }, ExtArgs["result"]["sub_centre"]>
    composites: {}
  }

  type sub_centreGetPayload<S extends boolean | null | undefined | sub_centreDefaultArgs> = $Result.GetResult<Prisma.$sub_centrePayload, S>

  type sub_centreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sub_centreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sub_centreCountAggregateInputType | true
    }

  export interface sub_centreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sub_centre'], meta: { name: 'sub_centre' } }
    /**
     * Find zero or one Sub_centre that matches the filter.
     * @param {sub_centreFindUniqueArgs} args - Arguments to find a Sub_centre
     * @example
     * // Get one Sub_centre
     * const sub_centre = await prisma.sub_centre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sub_centreFindUniqueArgs>(args: SelectSubset<T, sub_centreFindUniqueArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sub_centre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sub_centreFindUniqueOrThrowArgs} args - Arguments to find a Sub_centre
     * @example
     * // Get one Sub_centre
     * const sub_centre = await prisma.sub_centre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sub_centreFindUniqueOrThrowArgs>(args: SelectSubset<T, sub_centreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sub_centre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_centreFindFirstArgs} args - Arguments to find a Sub_centre
     * @example
     * // Get one Sub_centre
     * const sub_centre = await prisma.sub_centre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sub_centreFindFirstArgs>(args?: SelectSubset<T, sub_centreFindFirstArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sub_centre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_centreFindFirstOrThrowArgs} args - Arguments to find a Sub_centre
     * @example
     * // Get one Sub_centre
     * const sub_centre = await prisma.sub_centre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sub_centreFindFirstOrThrowArgs>(args?: SelectSubset<T, sub_centreFindFirstOrThrowArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sub_centres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_centreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sub_centres
     * const sub_centres = await prisma.sub_centre.findMany()
     * 
     * // Get first 10 Sub_centres
     * const sub_centres = await prisma.sub_centre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sub_centreWithIdOnly = await prisma.sub_centre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sub_centreFindManyArgs>(args?: SelectSubset<T, sub_centreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sub_centre.
     * @param {sub_centreCreateArgs} args - Arguments to create a Sub_centre.
     * @example
     * // Create one Sub_centre
     * const Sub_centre = await prisma.sub_centre.create({
     *   data: {
     *     // ... data to create a Sub_centre
     *   }
     * })
     * 
     */
    create<T extends sub_centreCreateArgs>(args: SelectSubset<T, sub_centreCreateArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sub_centres.
     * @param {sub_centreCreateManyArgs} args - Arguments to create many Sub_centres.
     * @example
     * // Create many Sub_centres
     * const sub_centre = await prisma.sub_centre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sub_centreCreateManyArgs>(args?: SelectSubset<T, sub_centreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sub_centres and returns the data saved in the database.
     * @param {sub_centreCreateManyAndReturnArgs} args - Arguments to create many Sub_centres.
     * @example
     * // Create many Sub_centres
     * const sub_centre = await prisma.sub_centre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sub_centres and only return the `id`
     * const sub_centreWithIdOnly = await prisma.sub_centre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sub_centreCreateManyAndReturnArgs>(args?: SelectSubset<T, sub_centreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sub_centre.
     * @param {sub_centreDeleteArgs} args - Arguments to delete one Sub_centre.
     * @example
     * // Delete one Sub_centre
     * const Sub_centre = await prisma.sub_centre.delete({
     *   where: {
     *     // ... filter to delete one Sub_centre
     *   }
     * })
     * 
     */
    delete<T extends sub_centreDeleteArgs>(args: SelectSubset<T, sub_centreDeleteArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sub_centre.
     * @param {sub_centreUpdateArgs} args - Arguments to update one Sub_centre.
     * @example
     * // Update one Sub_centre
     * const sub_centre = await prisma.sub_centre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sub_centreUpdateArgs>(args: SelectSubset<T, sub_centreUpdateArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sub_centres.
     * @param {sub_centreDeleteManyArgs} args - Arguments to filter Sub_centres to delete.
     * @example
     * // Delete a few Sub_centres
     * const { count } = await prisma.sub_centre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sub_centreDeleteManyArgs>(args?: SelectSubset<T, sub_centreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_centres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_centreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sub_centres
     * const sub_centre = await prisma.sub_centre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sub_centreUpdateManyArgs>(args: SelectSubset<T, sub_centreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_centres and returns the data updated in the database.
     * @param {sub_centreUpdateManyAndReturnArgs} args - Arguments to update many Sub_centres.
     * @example
     * // Update many Sub_centres
     * const sub_centre = await prisma.sub_centre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sub_centres and only return the `id`
     * const sub_centreWithIdOnly = await prisma.sub_centre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sub_centreUpdateManyAndReturnArgs>(args: SelectSubset<T, sub_centreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sub_centre.
     * @param {sub_centreUpsertArgs} args - Arguments to update or create a Sub_centre.
     * @example
     * // Update or create a Sub_centre
     * const sub_centre = await prisma.sub_centre.upsert({
     *   create: {
     *     // ... data to create a Sub_centre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sub_centre we want to update
     *   }
     * })
     */
    upsert<T extends sub_centreUpsertArgs>(args: SelectSubset<T, sub_centreUpsertArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sub_centres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_centreCountArgs} args - Arguments to filter Sub_centres to count.
     * @example
     * // Count the number of Sub_centres
     * const count = await prisma.sub_centre.count({
     *   where: {
     *     // ... the filter for the Sub_centres we want to count
     *   }
     * })
    **/
    count<T extends sub_centreCountArgs>(
      args?: Subset<T, sub_centreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sub_centreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sub_centre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_centreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sub_centreAggregateArgs>(args: Subset<T, Sub_centreAggregateArgs>): Prisma.PrismaPromise<GetSub_centreAggregateType<T>>

    /**
     * Group by Sub_centre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sub_centreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sub_centreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sub_centreGroupByArgs['orderBy'] }
        : { orderBy?: sub_centreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sub_centreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSub_centreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sub_centre model
   */
  readonly fields: sub_centreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sub_centre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sub_centreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monthly_health_data<T extends sub_centre$monthly_health_dataArgs<ExtArgs> = {}>(args?: Subset<T, sub_centre$monthly_health_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyHealthDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performance_calculations<T extends sub_centre$performance_calculationsArgs<ExtArgs> = {}>(args?: Subset<T, sub_centre$performance_calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sub_centre model
   */
  interface sub_centreFieldRefs {
    readonly id: FieldRef<"sub_centre", 'Int'>
    readonly name: FieldRef<"sub_centre", 'String'>
    readonly created_at: FieldRef<"sub_centre", 'DateTime'>
    readonly updated_at: FieldRef<"sub_centre", 'DateTime'>
    readonly facility_id: FieldRef<"sub_centre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sub_centre findUnique
   */
  export type sub_centreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * Filter, which sub_centre to fetch.
     */
    where: sub_centreWhereUniqueInput
  }

  /**
   * sub_centre findUniqueOrThrow
   */
  export type sub_centreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * Filter, which sub_centre to fetch.
     */
    where: sub_centreWhereUniqueInput
  }

  /**
   * sub_centre findFirst
   */
  export type sub_centreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * Filter, which sub_centre to fetch.
     */
    where?: sub_centreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_centres to fetch.
     */
    orderBy?: sub_centreOrderByWithRelationInput | sub_centreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_centres.
     */
    cursor?: sub_centreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_centres.
     */
    distinct?: Sub_centreScalarFieldEnum | Sub_centreScalarFieldEnum[]
  }

  /**
   * sub_centre findFirstOrThrow
   */
  export type sub_centreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * Filter, which sub_centre to fetch.
     */
    where?: sub_centreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_centres to fetch.
     */
    orderBy?: sub_centreOrderByWithRelationInput | sub_centreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sub_centres.
     */
    cursor?: sub_centreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sub_centres.
     */
    distinct?: Sub_centreScalarFieldEnum | Sub_centreScalarFieldEnum[]
  }

  /**
   * sub_centre findMany
   */
  export type sub_centreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * Filter, which sub_centres to fetch.
     */
    where?: sub_centreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sub_centres to fetch.
     */
    orderBy?: sub_centreOrderByWithRelationInput | sub_centreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sub_centres.
     */
    cursor?: sub_centreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sub_centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sub_centres.
     */
    skip?: number
    distinct?: Sub_centreScalarFieldEnum | Sub_centreScalarFieldEnum[]
  }

  /**
   * sub_centre create
   */
  export type sub_centreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * The data needed to create a sub_centre.
     */
    data: XOR<sub_centreCreateInput, sub_centreUncheckedCreateInput>
  }

  /**
   * sub_centre createMany
   */
  export type sub_centreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sub_centres.
     */
    data: sub_centreCreateManyInput | sub_centreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sub_centre createManyAndReturn
   */
  export type sub_centreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * The data used to create many sub_centres.
     */
    data: sub_centreCreateManyInput | sub_centreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sub_centre update
   */
  export type sub_centreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * The data needed to update a sub_centre.
     */
    data: XOR<sub_centreUpdateInput, sub_centreUncheckedUpdateInput>
    /**
     * Choose, which sub_centre to update.
     */
    where: sub_centreWhereUniqueInput
  }

  /**
   * sub_centre updateMany
   */
  export type sub_centreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sub_centres.
     */
    data: XOR<sub_centreUpdateManyMutationInput, sub_centreUncheckedUpdateManyInput>
    /**
     * Filter which sub_centres to update
     */
    where?: sub_centreWhereInput
    /**
     * Limit how many sub_centres to update.
     */
    limit?: number
  }

  /**
   * sub_centre updateManyAndReturn
   */
  export type sub_centreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * The data used to update sub_centres.
     */
    data: XOR<sub_centreUpdateManyMutationInput, sub_centreUncheckedUpdateManyInput>
    /**
     * Filter which sub_centres to update
     */
    where?: sub_centreWhereInput
    /**
     * Limit how many sub_centres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sub_centre upsert
   */
  export type sub_centreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * The filter to search for the sub_centre to update in case it exists.
     */
    where: sub_centreWhereUniqueInput
    /**
     * In case the sub_centre found by the `where` argument doesn't exist, create a new sub_centre with this data.
     */
    create: XOR<sub_centreCreateInput, sub_centreUncheckedCreateInput>
    /**
     * In case the sub_centre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sub_centreUpdateInput, sub_centreUncheckedUpdateInput>
  }

  /**
   * sub_centre delete
   */
  export type sub_centreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    /**
     * Filter which sub_centre to delete.
     */
    where: sub_centreWhereUniqueInput
  }

  /**
   * sub_centre deleteMany
   */
  export type sub_centreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sub_centres to delete
     */
    where?: sub_centreWhereInput
    /**
     * Limit how many sub_centres to delete.
     */
    limit?: number
  }

  /**
   * sub_centre.monthly_health_data
   */
  export type sub_centre$monthly_health_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyHealthData
     */
    select?: MonthlyHealthDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonthlyHealthData
     */
    omit?: MonthlyHealthDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyHealthDataInclude<ExtArgs> | null
    where?: MonthlyHealthDataWhereInput
    orderBy?: MonthlyHealthDataOrderByWithRelationInput | MonthlyHealthDataOrderByWithRelationInput[]
    cursor?: MonthlyHealthDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyHealthDataScalarFieldEnum | MonthlyHealthDataScalarFieldEnum[]
  }

  /**
   * sub_centre.performance_calculations
   */
  export type sub_centre$performance_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    where?: PerformanceCalculationWhereInput
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    cursor?: PerformanceCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceCalculationScalarFieldEnum | PerformanceCalculationScalarFieldEnum[]
  }

  /**
   * sub_centre without action
   */
  export type sub_centreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
  }


  /**
   * Model HealthWorker
   */

  export type AggregateHealthWorker = {
    _count: HealthWorkerCountAggregateOutputType | null
    _avg: HealthWorkerAvgAggregateOutputType | null
    _sum: HealthWorkerSumAggregateOutputType | null
    _min: HealthWorkerMinAggregateOutputType | null
    _max: HealthWorkerMaxAggregateOutputType | null
  }

  export type HealthWorkerAvgAggregateOutputType = {
    id: number | null
    allocated_amount: Decimal | null
  }

  export type HealthWorkerSumAggregateOutputType = {
    id: number | null
    allocated_amount: Decimal | null
  }

  export type HealthWorkerMinAggregateOutputType = {
    id: number | null
    facility_id: string | null
    name: string | null
    worker_type: string | null
    allocated_amount: Decimal | null
    contact_number: string | null
    email: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type HealthWorkerMaxAggregateOutputType = {
    id: number | null
    facility_id: string | null
    name: string | null
    worker_type: string | null
    allocated_amount: Decimal | null
    contact_number: string | null
    email: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type HealthWorkerCountAggregateOutputType = {
    id: number
    facility_id: number
    name: number
    worker_type: number
    allocated_amount: number
    contact_number: number
    email: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type HealthWorkerAvgAggregateInputType = {
    id?: true
    allocated_amount?: true
  }

  export type HealthWorkerSumAggregateInputType = {
    id?: true
    allocated_amount?: true
  }

  export type HealthWorkerMinAggregateInputType = {
    id?: true
    facility_id?: true
    name?: true
    worker_type?: true
    allocated_amount?: true
    contact_number?: true
    email?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type HealthWorkerMaxAggregateInputType = {
    id?: true
    facility_id?: true
    name?: true
    worker_type?: true
    allocated_amount?: true
    contact_number?: true
    email?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type HealthWorkerCountAggregateInputType = {
    id?: true
    facility_id?: true
    name?: true
    worker_type?: true
    allocated_amount?: true
    contact_number?: true
    email?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type HealthWorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthWorker to aggregate.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthWorkers
    **/
    _count?: true | HealthWorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthWorkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthWorkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthWorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthWorkerMaxAggregateInputType
  }

  export type GetHealthWorkerAggregateType<T extends HealthWorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthWorker[P]>
      : GetScalarType<T[P], AggregateHealthWorker[P]>
  }




  export type HealthWorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthWorkerWhereInput
    orderBy?: HealthWorkerOrderByWithAggregationInput | HealthWorkerOrderByWithAggregationInput[]
    by: HealthWorkerScalarFieldEnum[] | HealthWorkerScalarFieldEnum
    having?: HealthWorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthWorkerCountAggregateInputType | true
    _avg?: HealthWorkerAvgAggregateInputType
    _sum?: HealthWorkerSumAggregateInputType
    _min?: HealthWorkerMinAggregateInputType
    _max?: HealthWorkerMaxAggregateInputType
  }

  export type HealthWorkerGroupByOutputType = {
    id: number
    facility_id: string
    name: string
    worker_type: string
    allocated_amount: Decimal
    contact_number: string | null
    email: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: HealthWorkerCountAggregateOutputType | null
    _avg: HealthWorkerAvgAggregateOutputType | null
    _sum: HealthWorkerSumAggregateOutputType | null
    _min: HealthWorkerMinAggregateOutputType | null
    _max: HealthWorkerMaxAggregateOutputType | null
  }

  type GetHealthWorkerGroupByPayload<T extends HealthWorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthWorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthWorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthWorkerGroupByOutputType[P]>
            : GetScalarType<T[P], HealthWorkerGroupByOutputType[P]>
        }
      >
    >


  export type HealthWorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    name?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    contact_number?: boolean
    email?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    remuneration_calculations?: boolean | HealthWorker$remuneration_calculationsArgs<ExtArgs>
    _count?: boolean | HealthWorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthWorker"]>

  export type HealthWorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    name?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    contact_number?: boolean
    email?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthWorker"]>

  export type HealthWorkerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    name?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    contact_number?: boolean
    email?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthWorker"]>

  export type HealthWorkerSelectScalar = {
    id?: boolean
    facility_id?: boolean
    name?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    contact_number?: boolean
    email?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type HealthWorkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facility_id" | "name" | "worker_type" | "allocated_amount" | "contact_number" | "email" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["healthWorker"]>
  export type HealthWorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    remuneration_calculations?: boolean | HealthWorker$remuneration_calculationsArgs<ExtArgs>
    _count?: boolean | HealthWorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HealthWorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type HealthWorkerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }

  export type $HealthWorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthWorker"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      remuneration_calculations: Prisma.$WorkerRemunerationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facility_id: string
      name: string
      worker_type: string
      allocated_amount: Prisma.Decimal
      contact_number: string | null
      email: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["healthWorker"]>
    composites: {}
  }

  type HealthWorkerGetPayload<S extends boolean | null | undefined | HealthWorkerDefaultArgs> = $Result.GetResult<Prisma.$HealthWorkerPayload, S>

  type HealthWorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HealthWorkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HealthWorkerCountAggregateInputType | true
    }

  export interface HealthWorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthWorker'], meta: { name: 'HealthWorker' } }
    /**
     * Find zero or one HealthWorker that matches the filter.
     * @param {HealthWorkerFindUniqueArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthWorkerFindUniqueArgs>(args: SelectSubset<T, HealthWorkerFindUniqueArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HealthWorker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HealthWorkerFindUniqueOrThrowArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthWorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthWorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthWorker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerFindFirstArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthWorkerFindFirstArgs>(args?: SelectSubset<T, HealthWorkerFindFirstArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthWorker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerFindFirstOrThrowArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthWorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthWorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthWorkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthWorkers
     * const healthWorkers = await prisma.healthWorker.findMany()
     * 
     * // Get first 10 HealthWorkers
     * const healthWorkers = await prisma.healthWorker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthWorkerWithIdOnly = await prisma.healthWorker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthWorkerFindManyArgs>(args?: SelectSubset<T, HealthWorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HealthWorker.
     * @param {HealthWorkerCreateArgs} args - Arguments to create a HealthWorker.
     * @example
     * // Create one HealthWorker
     * const HealthWorker = await prisma.healthWorker.create({
     *   data: {
     *     // ... data to create a HealthWorker
     *   }
     * })
     * 
     */
    create<T extends HealthWorkerCreateArgs>(args: SelectSubset<T, HealthWorkerCreateArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HealthWorkers.
     * @param {HealthWorkerCreateManyArgs} args - Arguments to create many HealthWorkers.
     * @example
     * // Create many HealthWorkers
     * const healthWorker = await prisma.healthWorker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthWorkerCreateManyArgs>(args?: SelectSubset<T, HealthWorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthWorkers and returns the data saved in the database.
     * @param {HealthWorkerCreateManyAndReturnArgs} args - Arguments to create many HealthWorkers.
     * @example
     * // Create many HealthWorkers
     * const healthWorker = await prisma.healthWorker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthWorkers and only return the `id`
     * const healthWorkerWithIdOnly = await prisma.healthWorker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthWorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthWorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HealthWorker.
     * @param {HealthWorkerDeleteArgs} args - Arguments to delete one HealthWorker.
     * @example
     * // Delete one HealthWorker
     * const HealthWorker = await prisma.healthWorker.delete({
     *   where: {
     *     // ... filter to delete one HealthWorker
     *   }
     * })
     * 
     */
    delete<T extends HealthWorkerDeleteArgs>(args: SelectSubset<T, HealthWorkerDeleteArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HealthWorker.
     * @param {HealthWorkerUpdateArgs} args - Arguments to update one HealthWorker.
     * @example
     * // Update one HealthWorker
     * const healthWorker = await prisma.healthWorker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthWorkerUpdateArgs>(args: SelectSubset<T, HealthWorkerUpdateArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HealthWorkers.
     * @param {HealthWorkerDeleteManyArgs} args - Arguments to filter HealthWorkers to delete.
     * @example
     * // Delete a few HealthWorkers
     * const { count } = await prisma.healthWorker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthWorkerDeleteManyArgs>(args?: SelectSubset<T, HealthWorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthWorkers
     * const healthWorker = await prisma.healthWorker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthWorkerUpdateManyArgs>(args: SelectSubset<T, HealthWorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthWorkers and returns the data updated in the database.
     * @param {HealthWorkerUpdateManyAndReturnArgs} args - Arguments to update many HealthWorkers.
     * @example
     * // Update many HealthWorkers
     * const healthWorker = await prisma.healthWorker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HealthWorkers and only return the `id`
     * const healthWorkerWithIdOnly = await prisma.healthWorker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HealthWorkerUpdateManyAndReturnArgs>(args: SelectSubset<T, HealthWorkerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HealthWorker.
     * @param {HealthWorkerUpsertArgs} args - Arguments to update or create a HealthWorker.
     * @example
     * // Update or create a HealthWorker
     * const healthWorker = await prisma.healthWorker.upsert({
     *   create: {
     *     // ... data to create a HealthWorker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthWorker we want to update
     *   }
     * })
     */
    upsert<T extends HealthWorkerUpsertArgs>(args: SelectSubset<T, HealthWorkerUpsertArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HealthWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerCountArgs} args - Arguments to filter HealthWorkers to count.
     * @example
     * // Count the number of HealthWorkers
     * const count = await prisma.healthWorker.count({
     *   where: {
     *     // ... the filter for the HealthWorkers we want to count
     *   }
     * })
    **/
    count<T extends HealthWorkerCountArgs>(
      args?: Subset<T, HealthWorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthWorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthWorkerAggregateArgs>(args: Subset<T, HealthWorkerAggregateArgs>): Prisma.PrismaPromise<GetHealthWorkerAggregateType<T>>

    /**
     * Group by HealthWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthWorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthWorkerGroupByArgs['orderBy'] }
        : { orderBy?: HealthWorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthWorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthWorker model
   */
  readonly fields: HealthWorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthWorker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthWorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    remuneration_calculations<T extends HealthWorker$remuneration_calculationsArgs<ExtArgs> = {}>(args?: Subset<T, HealthWorker$remuneration_calculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthWorker model
   */
  interface HealthWorkerFieldRefs {
    readonly id: FieldRef<"HealthWorker", 'Int'>
    readonly facility_id: FieldRef<"HealthWorker", 'String'>
    readonly name: FieldRef<"HealthWorker", 'String'>
    readonly worker_type: FieldRef<"HealthWorker", 'String'>
    readonly allocated_amount: FieldRef<"HealthWorker", 'Decimal'>
    readonly contact_number: FieldRef<"HealthWorker", 'String'>
    readonly email: FieldRef<"HealthWorker", 'String'>
    readonly is_active: FieldRef<"HealthWorker", 'Boolean'>
    readonly created_at: FieldRef<"HealthWorker", 'DateTime'>
    readonly updated_at: FieldRef<"HealthWorker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthWorker findUnique
   */
  export type HealthWorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker findUniqueOrThrow
   */
  export type HealthWorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker findFirst
   */
  export type HealthWorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthWorkers.
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthWorkers.
     */
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * HealthWorker findFirstOrThrow
   */
  export type HealthWorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthWorkers.
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthWorkers.
     */
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * HealthWorker findMany
   */
  export type HealthWorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorkers to fetch.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthWorkers.
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * HealthWorker create
   */
  export type HealthWorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthWorker.
     */
    data: XOR<HealthWorkerCreateInput, HealthWorkerUncheckedCreateInput>
  }

  /**
   * HealthWorker createMany
   */
  export type HealthWorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthWorkers.
     */
    data: HealthWorkerCreateManyInput | HealthWorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthWorker createManyAndReturn
   */
  export type HealthWorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * The data used to create many HealthWorkers.
     */
    data: HealthWorkerCreateManyInput | HealthWorkerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthWorker update
   */
  export type HealthWorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthWorker.
     */
    data: XOR<HealthWorkerUpdateInput, HealthWorkerUncheckedUpdateInput>
    /**
     * Choose, which HealthWorker to update.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker updateMany
   */
  export type HealthWorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthWorkers.
     */
    data: XOR<HealthWorkerUpdateManyMutationInput, HealthWorkerUncheckedUpdateManyInput>
    /**
     * Filter which HealthWorkers to update
     */
    where?: HealthWorkerWhereInput
    /**
     * Limit how many HealthWorkers to update.
     */
    limit?: number
  }

  /**
   * HealthWorker updateManyAndReturn
   */
  export type HealthWorkerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * The data used to update HealthWorkers.
     */
    data: XOR<HealthWorkerUpdateManyMutationInput, HealthWorkerUncheckedUpdateManyInput>
    /**
     * Filter which HealthWorkers to update
     */
    where?: HealthWorkerWhereInput
    /**
     * Limit how many HealthWorkers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthWorker upsert
   */
  export type HealthWorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthWorker to update in case it exists.
     */
    where: HealthWorkerWhereUniqueInput
    /**
     * In case the HealthWorker found by the `where` argument doesn't exist, create a new HealthWorker with this data.
     */
    create: XOR<HealthWorkerCreateInput, HealthWorkerUncheckedCreateInput>
    /**
     * In case the HealthWorker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthWorkerUpdateInput, HealthWorkerUncheckedUpdateInput>
  }

  /**
   * HealthWorker delete
   */
  export type HealthWorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter which HealthWorker to delete.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker deleteMany
   */
  export type HealthWorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthWorkers to delete
     */
    where?: HealthWorkerWhereInput
    /**
     * Limit how many HealthWorkers to delete.
     */
    limit?: number
  }

  /**
   * HealthWorker.remuneration_calculations
   */
  export type HealthWorker$remuneration_calculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    where?: WorkerRemunerationWhereInput
    orderBy?: WorkerRemunerationOrderByWithRelationInput | WorkerRemunerationOrderByWithRelationInput[]
    cursor?: WorkerRemunerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerRemunerationScalarFieldEnum | WorkerRemunerationScalarFieldEnum[]
  }

  /**
   * HealthWorker without action
   */
  export type HealthWorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
  }


  /**
   * Model RemunerationCalculation
   */

  export type AggregateRemunerationCalculation = {
    _count: RemunerationCalculationCountAggregateOutputType | null
    _avg: RemunerationCalculationAvgAggregateOutputType | null
    _sum: RemunerationCalculationSumAggregateOutputType | null
    _min: RemunerationCalculationMinAggregateOutputType | null
    _max: RemunerationCalculationMaxAggregateOutputType | null
  }

  export type RemunerationCalculationAvgAggregateOutputType = {
    id: number | null
    performance_percentage: Decimal | null
    facility_remuneration: Decimal | null
    total_worker_remuneration: Decimal | null
    total_remuneration: Decimal | null
    health_workers_count: number | null
    asha_workers_count: number | null
  }

  export type RemunerationCalculationSumAggregateOutputType = {
    id: number | null
    performance_percentage: Decimal | null
    facility_remuneration: Decimal | null
    total_worker_remuneration: Decimal | null
    total_remuneration: Decimal | null
    health_workers_count: number | null
    asha_workers_count: number | null
  }

  export type RemunerationCalculationMinAggregateOutputType = {
    id: number | null
    facility_id: string | null
    report_month: string | null
    performance_percentage: Decimal | null
    facility_remuneration: Decimal | null
    total_worker_remuneration: Decimal | null
    total_remuneration: Decimal | null
    health_workers_count: number | null
    asha_workers_count: number | null
    calculated_at: Date | null
  }

  export type RemunerationCalculationMaxAggregateOutputType = {
    id: number | null
    facility_id: string | null
    report_month: string | null
    performance_percentage: Decimal | null
    facility_remuneration: Decimal | null
    total_worker_remuneration: Decimal | null
    total_remuneration: Decimal | null
    health_workers_count: number | null
    asha_workers_count: number | null
    calculated_at: Date | null
  }

  export type RemunerationCalculationCountAggregateOutputType = {
    id: number
    facility_id: number
    report_month: number
    performance_percentage: number
    facility_remuneration: number
    total_worker_remuneration: number
    total_remuneration: number
    health_workers_count: number
    asha_workers_count: number
    calculated_at: number
    _all: number
  }


  export type RemunerationCalculationAvgAggregateInputType = {
    id?: true
    performance_percentage?: true
    facility_remuneration?: true
    total_worker_remuneration?: true
    total_remuneration?: true
    health_workers_count?: true
    asha_workers_count?: true
  }

  export type RemunerationCalculationSumAggregateInputType = {
    id?: true
    performance_percentage?: true
    facility_remuneration?: true
    total_worker_remuneration?: true
    total_remuneration?: true
    health_workers_count?: true
    asha_workers_count?: true
  }

  export type RemunerationCalculationMinAggregateInputType = {
    id?: true
    facility_id?: true
    report_month?: true
    performance_percentage?: true
    facility_remuneration?: true
    total_worker_remuneration?: true
    total_remuneration?: true
    health_workers_count?: true
    asha_workers_count?: true
    calculated_at?: true
  }

  export type RemunerationCalculationMaxAggregateInputType = {
    id?: true
    facility_id?: true
    report_month?: true
    performance_percentage?: true
    facility_remuneration?: true
    total_worker_remuneration?: true
    total_remuneration?: true
    health_workers_count?: true
    asha_workers_count?: true
    calculated_at?: true
  }

  export type RemunerationCalculationCountAggregateInputType = {
    id?: true
    facility_id?: true
    report_month?: true
    performance_percentage?: true
    facility_remuneration?: true
    total_worker_remuneration?: true
    total_remuneration?: true
    health_workers_count?: true
    asha_workers_count?: true
    calculated_at?: true
    _all?: true
  }

  export type RemunerationCalculationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemunerationCalculation to aggregate.
     */
    where?: RemunerationCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationCalculations to fetch.
     */
    orderBy?: RemunerationCalculationOrderByWithRelationInput | RemunerationCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemunerationCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RemunerationCalculations
    **/
    _count?: true | RemunerationCalculationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RemunerationCalculationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RemunerationCalculationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemunerationCalculationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemunerationCalculationMaxAggregateInputType
  }

  export type GetRemunerationCalculationAggregateType<T extends RemunerationCalculationAggregateArgs> = {
        [P in keyof T & keyof AggregateRemunerationCalculation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemunerationCalculation[P]>
      : GetScalarType<T[P], AggregateRemunerationCalculation[P]>
  }




  export type RemunerationCalculationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemunerationCalculationWhereInput
    orderBy?: RemunerationCalculationOrderByWithAggregationInput | RemunerationCalculationOrderByWithAggregationInput[]
    by: RemunerationCalculationScalarFieldEnum[] | RemunerationCalculationScalarFieldEnum
    having?: RemunerationCalculationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemunerationCalculationCountAggregateInputType | true
    _avg?: RemunerationCalculationAvgAggregateInputType
    _sum?: RemunerationCalculationSumAggregateInputType
    _min?: RemunerationCalculationMinAggregateInputType
    _max?: RemunerationCalculationMaxAggregateInputType
  }

  export type RemunerationCalculationGroupByOutputType = {
    id: number
    facility_id: string
    report_month: string
    performance_percentage: Decimal
    facility_remuneration: Decimal
    total_worker_remuneration: Decimal
    total_remuneration: Decimal
    health_workers_count: number
    asha_workers_count: number
    calculated_at: Date
    _count: RemunerationCalculationCountAggregateOutputType | null
    _avg: RemunerationCalculationAvgAggregateOutputType | null
    _sum: RemunerationCalculationSumAggregateOutputType | null
    _min: RemunerationCalculationMinAggregateOutputType | null
    _max: RemunerationCalculationMaxAggregateOutputType | null
  }

  type GetRemunerationCalculationGroupByPayload<T extends RemunerationCalculationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemunerationCalculationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemunerationCalculationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemunerationCalculationGroupByOutputType[P]>
            : GetScalarType<T[P], RemunerationCalculationGroupByOutputType[P]>
        }
      >
    >


  export type RemunerationCalculationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    report_month?: boolean
    performance_percentage?: boolean
    facility_remuneration?: boolean
    total_worker_remuneration?: boolean
    total_remuneration?: boolean
    health_workers_count?: boolean
    asha_workers_count?: boolean
    calculated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remunerationCalculation"]>

  export type RemunerationCalculationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    report_month?: boolean
    performance_percentage?: boolean
    facility_remuneration?: boolean
    total_worker_remuneration?: boolean
    total_remuneration?: boolean
    health_workers_count?: boolean
    asha_workers_count?: boolean
    calculated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remunerationCalculation"]>

  export type RemunerationCalculationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    report_month?: boolean
    performance_percentage?: boolean
    facility_remuneration?: boolean
    total_worker_remuneration?: boolean
    total_remuneration?: boolean
    health_workers_count?: boolean
    asha_workers_count?: boolean
    calculated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["remunerationCalculation"]>

  export type RemunerationCalculationSelectScalar = {
    id?: boolean
    facility_id?: boolean
    report_month?: boolean
    performance_percentage?: boolean
    facility_remuneration?: boolean
    total_worker_remuneration?: boolean
    total_remuneration?: boolean
    health_workers_count?: boolean
    asha_workers_count?: boolean
    calculated_at?: boolean
  }

  export type RemunerationCalculationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facility_id" | "report_month" | "performance_percentage" | "facility_remuneration" | "total_worker_remuneration" | "total_remuneration" | "health_workers_count" | "asha_workers_count" | "calculated_at", ExtArgs["result"]["remunerationCalculation"]>
  export type RemunerationCalculationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type RemunerationCalculationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type RemunerationCalculationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }

  export type $RemunerationCalculationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RemunerationCalculation"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facility_id: string
      report_month: string
      performance_percentage: Prisma.Decimal
      facility_remuneration: Prisma.Decimal
      total_worker_remuneration: Prisma.Decimal
      total_remuneration: Prisma.Decimal
      health_workers_count: number
      asha_workers_count: number
      calculated_at: Date
    }, ExtArgs["result"]["remunerationCalculation"]>
    composites: {}
  }

  type RemunerationCalculationGetPayload<S extends boolean | null | undefined | RemunerationCalculationDefaultArgs> = $Result.GetResult<Prisma.$RemunerationCalculationPayload, S>

  type RemunerationCalculationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RemunerationCalculationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemunerationCalculationCountAggregateInputType | true
    }

  export interface RemunerationCalculationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RemunerationCalculation'], meta: { name: 'RemunerationCalculation' } }
    /**
     * Find zero or one RemunerationCalculation that matches the filter.
     * @param {RemunerationCalculationFindUniqueArgs} args - Arguments to find a RemunerationCalculation
     * @example
     * // Get one RemunerationCalculation
     * const remunerationCalculation = await prisma.remunerationCalculation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemunerationCalculationFindUniqueArgs>(args: SelectSubset<T, RemunerationCalculationFindUniqueArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RemunerationCalculation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RemunerationCalculationFindUniqueOrThrowArgs} args - Arguments to find a RemunerationCalculation
     * @example
     * // Get one RemunerationCalculation
     * const remunerationCalculation = await prisma.remunerationCalculation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemunerationCalculationFindUniqueOrThrowArgs>(args: SelectSubset<T, RemunerationCalculationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemunerationCalculation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationFindFirstArgs} args - Arguments to find a RemunerationCalculation
     * @example
     * // Get one RemunerationCalculation
     * const remunerationCalculation = await prisma.remunerationCalculation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemunerationCalculationFindFirstArgs>(args?: SelectSubset<T, RemunerationCalculationFindFirstArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemunerationCalculation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationFindFirstOrThrowArgs} args - Arguments to find a RemunerationCalculation
     * @example
     * // Get one RemunerationCalculation
     * const remunerationCalculation = await prisma.remunerationCalculation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemunerationCalculationFindFirstOrThrowArgs>(args?: SelectSubset<T, RemunerationCalculationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RemunerationCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RemunerationCalculations
     * const remunerationCalculations = await prisma.remunerationCalculation.findMany()
     * 
     * // Get first 10 RemunerationCalculations
     * const remunerationCalculations = await prisma.remunerationCalculation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remunerationCalculationWithIdOnly = await prisma.remunerationCalculation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RemunerationCalculationFindManyArgs>(args?: SelectSubset<T, RemunerationCalculationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RemunerationCalculation.
     * @param {RemunerationCalculationCreateArgs} args - Arguments to create a RemunerationCalculation.
     * @example
     * // Create one RemunerationCalculation
     * const RemunerationCalculation = await prisma.remunerationCalculation.create({
     *   data: {
     *     // ... data to create a RemunerationCalculation
     *   }
     * })
     * 
     */
    create<T extends RemunerationCalculationCreateArgs>(args: SelectSubset<T, RemunerationCalculationCreateArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RemunerationCalculations.
     * @param {RemunerationCalculationCreateManyArgs} args - Arguments to create many RemunerationCalculations.
     * @example
     * // Create many RemunerationCalculations
     * const remunerationCalculation = await prisma.remunerationCalculation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemunerationCalculationCreateManyArgs>(args?: SelectSubset<T, RemunerationCalculationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RemunerationCalculations and returns the data saved in the database.
     * @param {RemunerationCalculationCreateManyAndReturnArgs} args - Arguments to create many RemunerationCalculations.
     * @example
     * // Create many RemunerationCalculations
     * const remunerationCalculation = await prisma.remunerationCalculation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RemunerationCalculations and only return the `id`
     * const remunerationCalculationWithIdOnly = await prisma.remunerationCalculation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RemunerationCalculationCreateManyAndReturnArgs>(args?: SelectSubset<T, RemunerationCalculationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RemunerationCalculation.
     * @param {RemunerationCalculationDeleteArgs} args - Arguments to delete one RemunerationCalculation.
     * @example
     * // Delete one RemunerationCalculation
     * const RemunerationCalculation = await prisma.remunerationCalculation.delete({
     *   where: {
     *     // ... filter to delete one RemunerationCalculation
     *   }
     * })
     * 
     */
    delete<T extends RemunerationCalculationDeleteArgs>(args: SelectSubset<T, RemunerationCalculationDeleteArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RemunerationCalculation.
     * @param {RemunerationCalculationUpdateArgs} args - Arguments to update one RemunerationCalculation.
     * @example
     * // Update one RemunerationCalculation
     * const remunerationCalculation = await prisma.remunerationCalculation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemunerationCalculationUpdateArgs>(args: SelectSubset<T, RemunerationCalculationUpdateArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RemunerationCalculations.
     * @param {RemunerationCalculationDeleteManyArgs} args - Arguments to filter RemunerationCalculations to delete.
     * @example
     * // Delete a few RemunerationCalculations
     * const { count } = await prisma.remunerationCalculation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemunerationCalculationDeleteManyArgs>(args?: SelectSubset<T, RemunerationCalculationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemunerationCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RemunerationCalculations
     * const remunerationCalculation = await prisma.remunerationCalculation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemunerationCalculationUpdateManyArgs>(args: SelectSubset<T, RemunerationCalculationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemunerationCalculations and returns the data updated in the database.
     * @param {RemunerationCalculationUpdateManyAndReturnArgs} args - Arguments to update many RemunerationCalculations.
     * @example
     * // Update many RemunerationCalculations
     * const remunerationCalculation = await prisma.remunerationCalculation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RemunerationCalculations and only return the `id`
     * const remunerationCalculationWithIdOnly = await prisma.remunerationCalculation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RemunerationCalculationUpdateManyAndReturnArgs>(args: SelectSubset<T, RemunerationCalculationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RemunerationCalculation.
     * @param {RemunerationCalculationUpsertArgs} args - Arguments to update or create a RemunerationCalculation.
     * @example
     * // Update or create a RemunerationCalculation
     * const remunerationCalculation = await prisma.remunerationCalculation.upsert({
     *   create: {
     *     // ... data to create a RemunerationCalculation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RemunerationCalculation we want to update
     *   }
     * })
     */
    upsert<T extends RemunerationCalculationUpsertArgs>(args: SelectSubset<T, RemunerationCalculationUpsertArgs<ExtArgs>>): Prisma__RemunerationCalculationClient<$Result.GetResult<Prisma.$RemunerationCalculationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RemunerationCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationCountArgs} args - Arguments to filter RemunerationCalculations to count.
     * @example
     * // Count the number of RemunerationCalculations
     * const count = await prisma.remunerationCalculation.count({
     *   where: {
     *     // ... the filter for the RemunerationCalculations we want to count
     *   }
     * })
    **/
    count<T extends RemunerationCalculationCountArgs>(
      args?: Subset<T, RemunerationCalculationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemunerationCalculationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RemunerationCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemunerationCalculationAggregateArgs>(args: Subset<T, RemunerationCalculationAggregateArgs>): Prisma.PrismaPromise<GetRemunerationCalculationAggregateType<T>>

    /**
     * Group by RemunerationCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemunerationCalculationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemunerationCalculationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemunerationCalculationGroupByArgs['orderBy'] }
        : { orderBy?: RemunerationCalculationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemunerationCalculationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemunerationCalculationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RemunerationCalculation model
   */
  readonly fields: RemunerationCalculationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RemunerationCalculation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemunerationCalculationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RemunerationCalculation model
   */
  interface RemunerationCalculationFieldRefs {
    readonly id: FieldRef<"RemunerationCalculation", 'Int'>
    readonly facility_id: FieldRef<"RemunerationCalculation", 'String'>
    readonly report_month: FieldRef<"RemunerationCalculation", 'String'>
    readonly performance_percentage: FieldRef<"RemunerationCalculation", 'Decimal'>
    readonly facility_remuneration: FieldRef<"RemunerationCalculation", 'Decimal'>
    readonly total_worker_remuneration: FieldRef<"RemunerationCalculation", 'Decimal'>
    readonly total_remuneration: FieldRef<"RemunerationCalculation", 'Decimal'>
    readonly health_workers_count: FieldRef<"RemunerationCalculation", 'Int'>
    readonly asha_workers_count: FieldRef<"RemunerationCalculation", 'Int'>
    readonly calculated_at: FieldRef<"RemunerationCalculation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RemunerationCalculation findUnique
   */
  export type RemunerationCalculationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationCalculation to fetch.
     */
    where: RemunerationCalculationWhereUniqueInput
  }

  /**
   * RemunerationCalculation findUniqueOrThrow
   */
  export type RemunerationCalculationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationCalculation to fetch.
     */
    where: RemunerationCalculationWhereUniqueInput
  }

  /**
   * RemunerationCalculation findFirst
   */
  export type RemunerationCalculationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationCalculation to fetch.
     */
    where?: RemunerationCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationCalculations to fetch.
     */
    orderBy?: RemunerationCalculationOrderByWithRelationInput | RemunerationCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemunerationCalculations.
     */
    cursor?: RemunerationCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemunerationCalculations.
     */
    distinct?: RemunerationCalculationScalarFieldEnum | RemunerationCalculationScalarFieldEnum[]
  }

  /**
   * RemunerationCalculation findFirstOrThrow
   */
  export type RemunerationCalculationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationCalculation to fetch.
     */
    where?: RemunerationCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationCalculations to fetch.
     */
    orderBy?: RemunerationCalculationOrderByWithRelationInput | RemunerationCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemunerationCalculations.
     */
    cursor?: RemunerationCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemunerationCalculations.
     */
    distinct?: RemunerationCalculationScalarFieldEnum | RemunerationCalculationScalarFieldEnum[]
  }

  /**
   * RemunerationCalculation findMany
   */
  export type RemunerationCalculationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * Filter, which RemunerationCalculations to fetch.
     */
    where?: RemunerationCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemunerationCalculations to fetch.
     */
    orderBy?: RemunerationCalculationOrderByWithRelationInput | RemunerationCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RemunerationCalculations.
     */
    cursor?: RemunerationCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemunerationCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemunerationCalculations.
     */
    skip?: number
    distinct?: RemunerationCalculationScalarFieldEnum | RemunerationCalculationScalarFieldEnum[]
  }

  /**
   * RemunerationCalculation create
   */
  export type RemunerationCalculationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * The data needed to create a RemunerationCalculation.
     */
    data: XOR<RemunerationCalculationCreateInput, RemunerationCalculationUncheckedCreateInput>
  }

  /**
   * RemunerationCalculation createMany
   */
  export type RemunerationCalculationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RemunerationCalculations.
     */
    data: RemunerationCalculationCreateManyInput | RemunerationCalculationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemunerationCalculation createManyAndReturn
   */
  export type RemunerationCalculationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * The data used to create many RemunerationCalculations.
     */
    data: RemunerationCalculationCreateManyInput | RemunerationCalculationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemunerationCalculation update
   */
  export type RemunerationCalculationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * The data needed to update a RemunerationCalculation.
     */
    data: XOR<RemunerationCalculationUpdateInput, RemunerationCalculationUncheckedUpdateInput>
    /**
     * Choose, which RemunerationCalculation to update.
     */
    where: RemunerationCalculationWhereUniqueInput
  }

  /**
   * RemunerationCalculation updateMany
   */
  export type RemunerationCalculationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RemunerationCalculations.
     */
    data: XOR<RemunerationCalculationUpdateManyMutationInput, RemunerationCalculationUncheckedUpdateManyInput>
    /**
     * Filter which RemunerationCalculations to update
     */
    where?: RemunerationCalculationWhereInput
    /**
     * Limit how many RemunerationCalculations to update.
     */
    limit?: number
  }

  /**
   * RemunerationCalculation updateManyAndReturn
   */
  export type RemunerationCalculationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * The data used to update RemunerationCalculations.
     */
    data: XOR<RemunerationCalculationUpdateManyMutationInput, RemunerationCalculationUncheckedUpdateManyInput>
    /**
     * Filter which RemunerationCalculations to update
     */
    where?: RemunerationCalculationWhereInput
    /**
     * Limit how many RemunerationCalculations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RemunerationCalculation upsert
   */
  export type RemunerationCalculationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * The filter to search for the RemunerationCalculation to update in case it exists.
     */
    where: RemunerationCalculationWhereUniqueInput
    /**
     * In case the RemunerationCalculation found by the `where` argument doesn't exist, create a new RemunerationCalculation with this data.
     */
    create: XOR<RemunerationCalculationCreateInput, RemunerationCalculationUncheckedCreateInput>
    /**
     * In case the RemunerationCalculation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemunerationCalculationUpdateInput, RemunerationCalculationUncheckedUpdateInput>
  }

  /**
   * RemunerationCalculation delete
   */
  export type RemunerationCalculationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
    /**
     * Filter which RemunerationCalculation to delete.
     */
    where: RemunerationCalculationWhereUniqueInput
  }

  /**
   * RemunerationCalculation deleteMany
   */
  export type RemunerationCalculationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemunerationCalculations to delete
     */
    where?: RemunerationCalculationWhereInput
    /**
     * Limit how many RemunerationCalculations to delete.
     */
    limit?: number
  }

  /**
   * RemunerationCalculation without action
   */
  export type RemunerationCalculationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationCalculation
     */
    select?: RemunerationCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationCalculation
     */
    omit?: RemunerationCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationCalculationInclude<ExtArgs> | null
  }


  /**
   * Model WorkerRemuneration
   */

  export type AggregateWorkerRemuneration = {
    _count: WorkerRemunerationCountAggregateOutputType | null
    _avg: WorkerRemunerationAvgAggregateOutputType | null
    _sum: WorkerRemunerationSumAggregateOutputType | null
    _min: WorkerRemunerationMinAggregateOutputType | null
    _max: WorkerRemunerationMaxAggregateOutputType | null
  }

  export type WorkerRemunerationAvgAggregateOutputType = {
    id: number | null
    health_worker_id: number | null
    allocated_amount: Decimal | null
    performance_percentage: Decimal | null
    calculated_amount: Decimal | null
  }

  export type WorkerRemunerationSumAggregateOutputType = {
    id: number | null
    health_worker_id: number | null
    allocated_amount: Decimal | null
    performance_percentage: Decimal | null
    calculated_amount: Decimal | null
  }

  export type WorkerRemunerationMinAggregateOutputType = {
    id: number | null
    health_worker_id: number | null
    report_month: string | null
    allocated_amount: Decimal | null
    performance_percentage: Decimal | null
    calculated_amount: Decimal | null
    calculated_at: Date | null
  }

  export type WorkerRemunerationMaxAggregateOutputType = {
    id: number | null
    health_worker_id: number | null
    report_month: string | null
    allocated_amount: Decimal | null
    performance_percentage: Decimal | null
    calculated_amount: Decimal | null
    calculated_at: Date | null
  }

  export type WorkerRemunerationCountAggregateOutputType = {
    id: number
    health_worker_id: number
    report_month: number
    allocated_amount: number
    performance_percentage: number
    calculated_amount: number
    calculated_at: number
    _all: number
  }


  export type WorkerRemunerationAvgAggregateInputType = {
    id?: true
    health_worker_id?: true
    allocated_amount?: true
    performance_percentage?: true
    calculated_amount?: true
  }

  export type WorkerRemunerationSumAggregateInputType = {
    id?: true
    health_worker_id?: true
    allocated_amount?: true
    performance_percentage?: true
    calculated_amount?: true
  }

  export type WorkerRemunerationMinAggregateInputType = {
    id?: true
    health_worker_id?: true
    report_month?: true
    allocated_amount?: true
    performance_percentage?: true
    calculated_amount?: true
    calculated_at?: true
  }

  export type WorkerRemunerationMaxAggregateInputType = {
    id?: true
    health_worker_id?: true
    report_month?: true
    allocated_amount?: true
    performance_percentage?: true
    calculated_amount?: true
    calculated_at?: true
  }

  export type WorkerRemunerationCountAggregateInputType = {
    id?: true
    health_worker_id?: true
    report_month?: true
    allocated_amount?: true
    performance_percentage?: true
    calculated_amount?: true
    calculated_at?: true
    _all?: true
  }

  export type WorkerRemunerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerRemuneration to aggregate.
     */
    where?: WorkerRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRemunerations to fetch.
     */
    orderBy?: WorkerRemunerationOrderByWithRelationInput | WorkerRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerRemunerations
    **/
    _count?: true | WorkerRemunerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerRemunerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerRemunerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerRemunerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerRemunerationMaxAggregateInputType
  }

  export type GetWorkerRemunerationAggregateType<T extends WorkerRemunerationAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerRemuneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerRemuneration[P]>
      : GetScalarType<T[P], AggregateWorkerRemuneration[P]>
  }




  export type WorkerRemunerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerRemunerationWhereInput
    orderBy?: WorkerRemunerationOrderByWithAggregationInput | WorkerRemunerationOrderByWithAggregationInput[]
    by: WorkerRemunerationScalarFieldEnum[] | WorkerRemunerationScalarFieldEnum
    having?: WorkerRemunerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerRemunerationCountAggregateInputType | true
    _avg?: WorkerRemunerationAvgAggregateInputType
    _sum?: WorkerRemunerationSumAggregateInputType
    _min?: WorkerRemunerationMinAggregateInputType
    _max?: WorkerRemunerationMaxAggregateInputType
  }

  export type WorkerRemunerationGroupByOutputType = {
    id: number
    health_worker_id: number
    report_month: string
    allocated_amount: Decimal
    performance_percentage: Decimal
    calculated_amount: Decimal
    calculated_at: Date
    _count: WorkerRemunerationCountAggregateOutputType | null
    _avg: WorkerRemunerationAvgAggregateOutputType | null
    _sum: WorkerRemunerationSumAggregateOutputType | null
    _min: WorkerRemunerationMinAggregateOutputType | null
    _max: WorkerRemunerationMaxAggregateOutputType | null
  }

  type GetWorkerRemunerationGroupByPayload<T extends WorkerRemunerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerRemunerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerRemunerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerRemunerationGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerRemunerationGroupByOutputType[P]>
        }
      >
    >


  export type WorkerRemunerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    health_worker_id?: boolean
    report_month?: boolean
    allocated_amount?: boolean
    performance_percentage?: boolean
    calculated_amount?: boolean
    calculated_at?: boolean
    health_worker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerRemuneration"]>

  export type WorkerRemunerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    health_worker_id?: boolean
    report_month?: boolean
    allocated_amount?: boolean
    performance_percentage?: boolean
    calculated_amount?: boolean
    calculated_at?: boolean
    health_worker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerRemuneration"]>

  export type WorkerRemunerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    health_worker_id?: boolean
    report_month?: boolean
    allocated_amount?: boolean
    performance_percentage?: boolean
    calculated_amount?: boolean
    calculated_at?: boolean
    health_worker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerRemuneration"]>

  export type WorkerRemunerationSelectScalar = {
    id?: boolean
    health_worker_id?: boolean
    report_month?: boolean
    allocated_amount?: boolean
    performance_percentage?: boolean
    calculated_amount?: boolean
    calculated_at?: boolean
  }

  export type WorkerRemunerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "health_worker_id" | "report_month" | "allocated_amount" | "performance_percentage" | "calculated_amount" | "calculated_at", ExtArgs["result"]["workerRemuneration"]>
  export type WorkerRemunerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    health_worker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
  }
  export type WorkerRemunerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    health_worker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
  }
  export type WorkerRemunerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    health_worker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
  }

  export type $WorkerRemunerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerRemuneration"
    objects: {
      health_worker: Prisma.$HealthWorkerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      health_worker_id: number
      report_month: string
      allocated_amount: Prisma.Decimal
      performance_percentage: Prisma.Decimal
      calculated_amount: Prisma.Decimal
      calculated_at: Date
    }, ExtArgs["result"]["workerRemuneration"]>
    composites: {}
  }

  type WorkerRemunerationGetPayload<S extends boolean | null | undefined | WorkerRemunerationDefaultArgs> = $Result.GetResult<Prisma.$WorkerRemunerationPayload, S>

  type WorkerRemunerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerRemunerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerRemunerationCountAggregateInputType | true
    }

  export interface WorkerRemunerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerRemuneration'], meta: { name: 'WorkerRemuneration' } }
    /**
     * Find zero or one WorkerRemuneration that matches the filter.
     * @param {WorkerRemunerationFindUniqueArgs} args - Arguments to find a WorkerRemuneration
     * @example
     * // Get one WorkerRemuneration
     * const workerRemuneration = await prisma.workerRemuneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerRemunerationFindUniqueArgs>(args: SelectSubset<T, WorkerRemunerationFindUniqueArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkerRemuneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerRemunerationFindUniqueOrThrowArgs} args - Arguments to find a WorkerRemuneration
     * @example
     * // Get one WorkerRemuneration
     * const workerRemuneration = await prisma.workerRemuneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerRemunerationFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerRemunerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerRemuneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationFindFirstArgs} args - Arguments to find a WorkerRemuneration
     * @example
     * // Get one WorkerRemuneration
     * const workerRemuneration = await prisma.workerRemuneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerRemunerationFindFirstArgs>(args?: SelectSubset<T, WorkerRemunerationFindFirstArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerRemuneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationFindFirstOrThrowArgs} args - Arguments to find a WorkerRemuneration
     * @example
     * // Get one WorkerRemuneration
     * const workerRemuneration = await prisma.workerRemuneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerRemunerationFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerRemunerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerRemunerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerRemunerations
     * const workerRemunerations = await prisma.workerRemuneration.findMany()
     * 
     * // Get first 10 WorkerRemunerations
     * const workerRemunerations = await prisma.workerRemuneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerRemunerationWithIdOnly = await prisma.workerRemuneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerRemunerationFindManyArgs>(args?: SelectSubset<T, WorkerRemunerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkerRemuneration.
     * @param {WorkerRemunerationCreateArgs} args - Arguments to create a WorkerRemuneration.
     * @example
     * // Create one WorkerRemuneration
     * const WorkerRemuneration = await prisma.workerRemuneration.create({
     *   data: {
     *     // ... data to create a WorkerRemuneration
     *   }
     * })
     * 
     */
    create<T extends WorkerRemunerationCreateArgs>(args: SelectSubset<T, WorkerRemunerationCreateArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkerRemunerations.
     * @param {WorkerRemunerationCreateManyArgs} args - Arguments to create many WorkerRemunerations.
     * @example
     * // Create many WorkerRemunerations
     * const workerRemuneration = await prisma.workerRemuneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerRemunerationCreateManyArgs>(args?: SelectSubset<T, WorkerRemunerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerRemunerations and returns the data saved in the database.
     * @param {WorkerRemunerationCreateManyAndReturnArgs} args - Arguments to create many WorkerRemunerations.
     * @example
     * // Create many WorkerRemunerations
     * const workerRemuneration = await prisma.workerRemuneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerRemunerations and only return the `id`
     * const workerRemunerationWithIdOnly = await prisma.workerRemuneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerRemunerationCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerRemunerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkerRemuneration.
     * @param {WorkerRemunerationDeleteArgs} args - Arguments to delete one WorkerRemuneration.
     * @example
     * // Delete one WorkerRemuneration
     * const WorkerRemuneration = await prisma.workerRemuneration.delete({
     *   where: {
     *     // ... filter to delete one WorkerRemuneration
     *   }
     * })
     * 
     */
    delete<T extends WorkerRemunerationDeleteArgs>(args: SelectSubset<T, WorkerRemunerationDeleteArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkerRemuneration.
     * @param {WorkerRemunerationUpdateArgs} args - Arguments to update one WorkerRemuneration.
     * @example
     * // Update one WorkerRemuneration
     * const workerRemuneration = await prisma.workerRemuneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerRemunerationUpdateArgs>(args: SelectSubset<T, WorkerRemunerationUpdateArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkerRemunerations.
     * @param {WorkerRemunerationDeleteManyArgs} args - Arguments to filter WorkerRemunerations to delete.
     * @example
     * // Delete a few WorkerRemunerations
     * const { count } = await prisma.workerRemuneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerRemunerationDeleteManyArgs>(args?: SelectSubset<T, WorkerRemunerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerRemunerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerRemunerations
     * const workerRemuneration = await prisma.workerRemuneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerRemunerationUpdateManyArgs>(args: SelectSubset<T, WorkerRemunerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerRemunerations and returns the data updated in the database.
     * @param {WorkerRemunerationUpdateManyAndReturnArgs} args - Arguments to update many WorkerRemunerations.
     * @example
     * // Update many WorkerRemunerations
     * const workerRemuneration = await prisma.workerRemuneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkerRemunerations and only return the `id`
     * const workerRemunerationWithIdOnly = await prisma.workerRemuneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerRemunerationUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerRemunerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkerRemuneration.
     * @param {WorkerRemunerationUpsertArgs} args - Arguments to update or create a WorkerRemuneration.
     * @example
     * // Update or create a WorkerRemuneration
     * const workerRemuneration = await prisma.workerRemuneration.upsert({
     *   create: {
     *     // ... data to create a WorkerRemuneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerRemuneration we want to update
     *   }
     * })
     */
    upsert<T extends WorkerRemunerationUpsertArgs>(args: SelectSubset<T, WorkerRemunerationUpsertArgs<ExtArgs>>): Prisma__WorkerRemunerationClient<$Result.GetResult<Prisma.$WorkerRemunerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkerRemunerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationCountArgs} args - Arguments to filter WorkerRemunerations to count.
     * @example
     * // Count the number of WorkerRemunerations
     * const count = await prisma.workerRemuneration.count({
     *   where: {
     *     // ... the filter for the WorkerRemunerations we want to count
     *   }
     * })
    **/
    count<T extends WorkerRemunerationCountArgs>(
      args?: Subset<T, WorkerRemunerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerRemunerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerRemuneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerRemunerationAggregateArgs>(args: Subset<T, WorkerRemunerationAggregateArgs>): Prisma.PrismaPromise<GetWorkerRemunerationAggregateType<T>>

    /**
     * Group by WorkerRemuneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerRemunerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerRemunerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerRemunerationGroupByArgs['orderBy'] }
        : { orderBy?: WorkerRemunerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerRemunerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerRemunerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerRemuneration model
   */
  readonly fields: WorkerRemunerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerRemuneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerRemunerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    health_worker<T extends HealthWorkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthWorkerDefaultArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerRemuneration model
   */
  interface WorkerRemunerationFieldRefs {
    readonly id: FieldRef<"WorkerRemuneration", 'Int'>
    readonly health_worker_id: FieldRef<"WorkerRemuneration", 'Int'>
    readonly report_month: FieldRef<"WorkerRemuneration", 'String'>
    readonly allocated_amount: FieldRef<"WorkerRemuneration", 'Decimal'>
    readonly performance_percentage: FieldRef<"WorkerRemuneration", 'Decimal'>
    readonly calculated_amount: FieldRef<"WorkerRemuneration", 'Decimal'>
    readonly calculated_at: FieldRef<"WorkerRemuneration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkerRemuneration findUnique
   */
  export type WorkerRemunerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRemuneration to fetch.
     */
    where: WorkerRemunerationWhereUniqueInput
  }

  /**
   * WorkerRemuneration findUniqueOrThrow
   */
  export type WorkerRemunerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRemuneration to fetch.
     */
    where: WorkerRemunerationWhereUniqueInput
  }

  /**
   * WorkerRemuneration findFirst
   */
  export type WorkerRemunerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRemuneration to fetch.
     */
    where?: WorkerRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRemunerations to fetch.
     */
    orderBy?: WorkerRemunerationOrderByWithRelationInput | WorkerRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerRemunerations.
     */
    cursor?: WorkerRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerRemunerations.
     */
    distinct?: WorkerRemunerationScalarFieldEnum | WorkerRemunerationScalarFieldEnum[]
  }

  /**
   * WorkerRemuneration findFirstOrThrow
   */
  export type WorkerRemunerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRemuneration to fetch.
     */
    where?: WorkerRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRemunerations to fetch.
     */
    orderBy?: WorkerRemunerationOrderByWithRelationInput | WorkerRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerRemunerations.
     */
    cursor?: WorkerRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerRemunerations.
     */
    distinct?: WorkerRemunerationScalarFieldEnum | WorkerRemunerationScalarFieldEnum[]
  }

  /**
   * WorkerRemuneration findMany
   */
  export type WorkerRemunerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which WorkerRemunerations to fetch.
     */
    where?: WorkerRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerRemunerations to fetch.
     */
    orderBy?: WorkerRemunerationOrderByWithRelationInput | WorkerRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerRemunerations.
     */
    cursor?: WorkerRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerRemunerations.
     */
    skip?: number
    distinct?: WorkerRemunerationScalarFieldEnum | WorkerRemunerationScalarFieldEnum[]
  }

  /**
   * WorkerRemuneration create
   */
  export type WorkerRemunerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerRemuneration.
     */
    data: XOR<WorkerRemunerationCreateInput, WorkerRemunerationUncheckedCreateInput>
  }

  /**
   * WorkerRemuneration createMany
   */
  export type WorkerRemunerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerRemunerations.
     */
    data: WorkerRemunerationCreateManyInput | WorkerRemunerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerRemuneration createManyAndReturn
   */
  export type WorkerRemunerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * The data used to create many WorkerRemunerations.
     */
    data: WorkerRemunerationCreateManyInput | WorkerRemunerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerRemuneration update
   */
  export type WorkerRemunerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerRemuneration.
     */
    data: XOR<WorkerRemunerationUpdateInput, WorkerRemunerationUncheckedUpdateInput>
    /**
     * Choose, which WorkerRemuneration to update.
     */
    where: WorkerRemunerationWhereUniqueInput
  }

  /**
   * WorkerRemuneration updateMany
   */
  export type WorkerRemunerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerRemunerations.
     */
    data: XOR<WorkerRemunerationUpdateManyMutationInput, WorkerRemunerationUncheckedUpdateManyInput>
    /**
     * Filter which WorkerRemunerations to update
     */
    where?: WorkerRemunerationWhereInput
    /**
     * Limit how many WorkerRemunerations to update.
     */
    limit?: number
  }

  /**
   * WorkerRemuneration updateManyAndReturn
   */
  export type WorkerRemunerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * The data used to update WorkerRemunerations.
     */
    data: XOR<WorkerRemunerationUpdateManyMutationInput, WorkerRemunerationUncheckedUpdateManyInput>
    /**
     * Filter which WorkerRemunerations to update
     */
    where?: WorkerRemunerationWhereInput
    /**
     * Limit how many WorkerRemunerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerRemuneration upsert
   */
  export type WorkerRemunerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerRemuneration to update in case it exists.
     */
    where: WorkerRemunerationWhereUniqueInput
    /**
     * In case the WorkerRemuneration found by the `where` argument doesn't exist, create a new WorkerRemuneration with this data.
     */
    create: XOR<WorkerRemunerationCreateInput, WorkerRemunerationUncheckedCreateInput>
    /**
     * In case the WorkerRemuneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerRemunerationUpdateInput, WorkerRemunerationUncheckedUpdateInput>
  }

  /**
   * WorkerRemuneration delete
   */
  export type WorkerRemunerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
    /**
     * Filter which WorkerRemuneration to delete.
     */
    where: WorkerRemunerationWhereUniqueInput
  }

  /**
   * WorkerRemuneration deleteMany
   */
  export type WorkerRemunerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerRemunerations to delete
     */
    where?: WorkerRemunerationWhereInput
    /**
     * Limit how many WorkerRemunerations to delete.
     */
    limit?: number
  }

  /**
   * WorkerRemuneration without action
   */
  export type WorkerRemunerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerRemuneration
     */
    select?: WorkerRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerRemuneration
     */
    omit?: WorkerRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerRemunerationInclude<ExtArgs> | null
  }


  /**
   * Model WorkerAllocationConfig
   */

  export type AggregateWorkerAllocationConfig = {
    _count: WorkerAllocationConfigCountAggregateOutputType | null
    _avg: WorkerAllocationConfigAvgAggregateOutputType | null
    _sum: WorkerAllocationConfigSumAggregateOutputType | null
    _min: WorkerAllocationConfigMinAggregateOutputType | null
    _max: WorkerAllocationConfigMaxAggregateOutputType | null
  }

  export type WorkerAllocationConfigAvgAggregateOutputType = {
    id: number | null
    max_count: number | null
    allocated_amount: Decimal | null
  }

  export type WorkerAllocationConfigSumAggregateOutputType = {
    id: number | null
    max_count: number | null
    allocated_amount: Decimal | null
  }

  export type WorkerAllocationConfigMinAggregateOutputType = {
    id: number | null
    facility_type_id: string | null
    worker_type: string | null
    worker_role: string | null
    max_count: number | null
    allocated_amount: Decimal | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkerAllocationConfigMaxAggregateOutputType = {
    id: number | null
    facility_type_id: string | null
    worker_type: string | null
    worker_role: string | null
    max_count: number | null
    allocated_amount: Decimal | null
    description: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WorkerAllocationConfigCountAggregateOutputType = {
    id: number
    facility_type_id: number
    worker_type: number
    worker_role: number
    max_count: number
    allocated_amount: number
    description: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WorkerAllocationConfigAvgAggregateInputType = {
    id?: true
    max_count?: true
    allocated_amount?: true
  }

  export type WorkerAllocationConfigSumAggregateInputType = {
    id?: true
    max_count?: true
    allocated_amount?: true
  }

  export type WorkerAllocationConfigMinAggregateInputType = {
    id?: true
    facility_type_id?: true
    worker_type?: true
    worker_role?: true
    max_count?: true
    allocated_amount?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkerAllocationConfigMaxAggregateInputType = {
    id?: true
    facility_type_id?: true
    worker_type?: true
    worker_role?: true
    max_count?: true
    allocated_amount?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type WorkerAllocationConfigCountAggregateInputType = {
    id?: true
    facility_type_id?: true
    worker_type?: true
    worker_role?: true
    max_count?: true
    allocated_amount?: true
    description?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WorkerAllocationConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerAllocationConfig to aggregate.
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAllocationConfigs to fetch.
     */
    orderBy?: WorkerAllocationConfigOrderByWithRelationInput | WorkerAllocationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerAllocationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAllocationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAllocationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerAllocationConfigs
    **/
    _count?: true | WorkerAllocationConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerAllocationConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerAllocationConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerAllocationConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerAllocationConfigMaxAggregateInputType
  }

  export type GetWorkerAllocationConfigAggregateType<T extends WorkerAllocationConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerAllocationConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerAllocationConfig[P]>
      : GetScalarType<T[P], AggregateWorkerAllocationConfig[P]>
  }




  export type WorkerAllocationConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerAllocationConfigWhereInput
    orderBy?: WorkerAllocationConfigOrderByWithAggregationInput | WorkerAllocationConfigOrderByWithAggregationInput[]
    by: WorkerAllocationConfigScalarFieldEnum[] | WorkerAllocationConfigScalarFieldEnum
    having?: WorkerAllocationConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerAllocationConfigCountAggregateInputType | true
    _avg?: WorkerAllocationConfigAvgAggregateInputType
    _sum?: WorkerAllocationConfigSumAggregateInputType
    _min?: WorkerAllocationConfigMinAggregateInputType
    _max?: WorkerAllocationConfigMaxAggregateInputType
  }

  export type WorkerAllocationConfigGroupByOutputType = {
    id: number
    facility_type_id: string
    worker_type: string
    worker_role: string
    max_count: number
    allocated_amount: Decimal
    description: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: WorkerAllocationConfigCountAggregateOutputType | null
    _avg: WorkerAllocationConfigAvgAggregateOutputType | null
    _sum: WorkerAllocationConfigSumAggregateOutputType | null
    _min: WorkerAllocationConfigMinAggregateOutputType | null
    _max: WorkerAllocationConfigMaxAggregateOutputType | null
  }

  type GetWorkerAllocationConfigGroupByPayload<T extends WorkerAllocationConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerAllocationConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerAllocationConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerAllocationConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerAllocationConfigGroupByOutputType[P]>
        }
      >
    >


  export type WorkerAllocationConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_type_id?: boolean
    worker_type?: boolean
    worker_role?: boolean
    max_count?: boolean
    allocated_amount?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_allocations?: boolean | WorkerAllocationConfig$facility_allocationsArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    _count?: boolean | WorkerAllocationConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerAllocationConfig"]>

  export type WorkerAllocationConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_type_id?: boolean
    worker_type?: boolean
    worker_role?: boolean
    max_count?: boolean
    allocated_amount?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerAllocationConfig"]>

  export type WorkerAllocationConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_type_id?: boolean
    worker_type?: boolean
    worker_role?: boolean
    max_count?: boolean
    allocated_amount?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workerAllocationConfig"]>

  export type WorkerAllocationConfigSelectScalar = {
    id?: boolean
    facility_type_id?: boolean
    worker_type?: boolean
    worker_role?: boolean
    max_count?: boolean
    allocated_amount?: boolean
    description?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WorkerAllocationConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facility_type_id" | "worker_type" | "worker_role" | "max_count" | "allocated_amount" | "description" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["workerAllocationConfig"]>
  export type WorkerAllocationConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_allocations?: boolean | WorkerAllocationConfig$facility_allocationsArgs<ExtArgs>
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    _count?: boolean | WorkerAllocationConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerAllocationConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }
  export type WorkerAllocationConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }

  export type $WorkerAllocationConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkerAllocationConfig"
    objects: {
      facility_allocations: Prisma.$FacilityWorkerAllocationPayload<ExtArgs>[]
      facility_type: Prisma.$FacilityTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facility_type_id: string
      worker_type: string
      worker_role: string
      max_count: number
      allocated_amount: Prisma.Decimal
      description: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["workerAllocationConfig"]>
    composites: {}
  }

  type WorkerAllocationConfigGetPayload<S extends boolean | null | undefined | WorkerAllocationConfigDefaultArgs> = $Result.GetResult<Prisma.$WorkerAllocationConfigPayload, S>

  type WorkerAllocationConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerAllocationConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerAllocationConfigCountAggregateInputType | true
    }

  export interface WorkerAllocationConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkerAllocationConfig'], meta: { name: 'WorkerAllocationConfig' } }
    /**
     * Find zero or one WorkerAllocationConfig that matches the filter.
     * @param {WorkerAllocationConfigFindUniqueArgs} args - Arguments to find a WorkerAllocationConfig
     * @example
     * // Get one WorkerAllocationConfig
     * const workerAllocationConfig = await prisma.workerAllocationConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerAllocationConfigFindUniqueArgs>(args: SelectSubset<T, WorkerAllocationConfigFindUniqueArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkerAllocationConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerAllocationConfigFindUniqueOrThrowArgs} args - Arguments to find a WorkerAllocationConfig
     * @example
     * // Get one WorkerAllocationConfig
     * const workerAllocationConfig = await prisma.workerAllocationConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerAllocationConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerAllocationConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerAllocationConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigFindFirstArgs} args - Arguments to find a WorkerAllocationConfig
     * @example
     * // Get one WorkerAllocationConfig
     * const workerAllocationConfig = await prisma.workerAllocationConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerAllocationConfigFindFirstArgs>(args?: SelectSubset<T, WorkerAllocationConfigFindFirstArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkerAllocationConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigFindFirstOrThrowArgs} args - Arguments to find a WorkerAllocationConfig
     * @example
     * // Get one WorkerAllocationConfig
     * const workerAllocationConfig = await prisma.workerAllocationConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerAllocationConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerAllocationConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkerAllocationConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerAllocationConfigs
     * const workerAllocationConfigs = await prisma.workerAllocationConfig.findMany()
     * 
     * // Get first 10 WorkerAllocationConfigs
     * const workerAllocationConfigs = await prisma.workerAllocationConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerAllocationConfigWithIdOnly = await prisma.workerAllocationConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerAllocationConfigFindManyArgs>(args?: SelectSubset<T, WorkerAllocationConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkerAllocationConfig.
     * @param {WorkerAllocationConfigCreateArgs} args - Arguments to create a WorkerAllocationConfig.
     * @example
     * // Create one WorkerAllocationConfig
     * const WorkerAllocationConfig = await prisma.workerAllocationConfig.create({
     *   data: {
     *     // ... data to create a WorkerAllocationConfig
     *   }
     * })
     * 
     */
    create<T extends WorkerAllocationConfigCreateArgs>(args: SelectSubset<T, WorkerAllocationConfigCreateArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkerAllocationConfigs.
     * @param {WorkerAllocationConfigCreateManyArgs} args - Arguments to create many WorkerAllocationConfigs.
     * @example
     * // Create many WorkerAllocationConfigs
     * const workerAllocationConfig = await prisma.workerAllocationConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerAllocationConfigCreateManyArgs>(args?: SelectSubset<T, WorkerAllocationConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkerAllocationConfigs and returns the data saved in the database.
     * @param {WorkerAllocationConfigCreateManyAndReturnArgs} args - Arguments to create many WorkerAllocationConfigs.
     * @example
     * // Create many WorkerAllocationConfigs
     * const workerAllocationConfig = await prisma.workerAllocationConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkerAllocationConfigs and only return the `id`
     * const workerAllocationConfigWithIdOnly = await prisma.workerAllocationConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerAllocationConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerAllocationConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkerAllocationConfig.
     * @param {WorkerAllocationConfigDeleteArgs} args - Arguments to delete one WorkerAllocationConfig.
     * @example
     * // Delete one WorkerAllocationConfig
     * const WorkerAllocationConfig = await prisma.workerAllocationConfig.delete({
     *   where: {
     *     // ... filter to delete one WorkerAllocationConfig
     *   }
     * })
     * 
     */
    delete<T extends WorkerAllocationConfigDeleteArgs>(args: SelectSubset<T, WorkerAllocationConfigDeleteArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkerAllocationConfig.
     * @param {WorkerAllocationConfigUpdateArgs} args - Arguments to update one WorkerAllocationConfig.
     * @example
     * // Update one WorkerAllocationConfig
     * const workerAllocationConfig = await prisma.workerAllocationConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerAllocationConfigUpdateArgs>(args: SelectSubset<T, WorkerAllocationConfigUpdateArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkerAllocationConfigs.
     * @param {WorkerAllocationConfigDeleteManyArgs} args - Arguments to filter WorkerAllocationConfigs to delete.
     * @example
     * // Delete a few WorkerAllocationConfigs
     * const { count } = await prisma.workerAllocationConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerAllocationConfigDeleteManyArgs>(args?: SelectSubset<T, WorkerAllocationConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerAllocationConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerAllocationConfigs
     * const workerAllocationConfig = await prisma.workerAllocationConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerAllocationConfigUpdateManyArgs>(args: SelectSubset<T, WorkerAllocationConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerAllocationConfigs and returns the data updated in the database.
     * @param {WorkerAllocationConfigUpdateManyAndReturnArgs} args - Arguments to update many WorkerAllocationConfigs.
     * @example
     * // Update many WorkerAllocationConfigs
     * const workerAllocationConfig = await prisma.workerAllocationConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkerAllocationConfigs and only return the `id`
     * const workerAllocationConfigWithIdOnly = await prisma.workerAllocationConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerAllocationConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerAllocationConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkerAllocationConfig.
     * @param {WorkerAllocationConfigUpsertArgs} args - Arguments to update or create a WorkerAllocationConfig.
     * @example
     * // Update or create a WorkerAllocationConfig
     * const workerAllocationConfig = await prisma.workerAllocationConfig.upsert({
     *   create: {
     *     // ... data to create a WorkerAllocationConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerAllocationConfig we want to update
     *   }
     * })
     */
    upsert<T extends WorkerAllocationConfigUpsertArgs>(args: SelectSubset<T, WorkerAllocationConfigUpsertArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkerAllocationConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigCountArgs} args - Arguments to filter WorkerAllocationConfigs to count.
     * @example
     * // Count the number of WorkerAllocationConfigs
     * const count = await prisma.workerAllocationConfig.count({
     *   where: {
     *     // ... the filter for the WorkerAllocationConfigs we want to count
     *   }
     * })
    **/
    count<T extends WorkerAllocationConfigCountArgs>(
      args?: Subset<T, WorkerAllocationConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerAllocationConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerAllocationConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAllocationConfigAggregateArgs>(args: Subset<T, WorkerAllocationConfigAggregateArgs>): Prisma.PrismaPromise<GetWorkerAllocationConfigAggregateType<T>>

    /**
     * Group by WorkerAllocationConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAllocationConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerAllocationConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerAllocationConfigGroupByArgs['orderBy'] }
        : { orderBy?: WorkerAllocationConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerAllocationConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerAllocationConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkerAllocationConfig model
   */
  readonly fields: WorkerAllocationConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerAllocationConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerAllocationConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility_allocations<T extends WorkerAllocationConfig$facility_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, WorkerAllocationConfig$facility_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    facility_type<T extends FacilityTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityTypeDefaultArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkerAllocationConfig model
   */
  interface WorkerAllocationConfigFieldRefs {
    readonly id: FieldRef<"WorkerAllocationConfig", 'Int'>
    readonly facility_type_id: FieldRef<"WorkerAllocationConfig", 'String'>
    readonly worker_type: FieldRef<"WorkerAllocationConfig", 'String'>
    readonly worker_role: FieldRef<"WorkerAllocationConfig", 'String'>
    readonly max_count: FieldRef<"WorkerAllocationConfig", 'Int'>
    readonly allocated_amount: FieldRef<"WorkerAllocationConfig", 'Decimal'>
    readonly description: FieldRef<"WorkerAllocationConfig", 'String'>
    readonly is_active: FieldRef<"WorkerAllocationConfig", 'Boolean'>
    readonly created_at: FieldRef<"WorkerAllocationConfig", 'DateTime'>
    readonly updated_at: FieldRef<"WorkerAllocationConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkerAllocationConfig findUnique
   */
  export type WorkerAllocationConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAllocationConfig to fetch.
     */
    where: WorkerAllocationConfigWhereUniqueInput
  }

  /**
   * WorkerAllocationConfig findUniqueOrThrow
   */
  export type WorkerAllocationConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAllocationConfig to fetch.
     */
    where: WorkerAllocationConfigWhereUniqueInput
  }

  /**
   * WorkerAllocationConfig findFirst
   */
  export type WorkerAllocationConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAllocationConfig to fetch.
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAllocationConfigs to fetch.
     */
    orderBy?: WorkerAllocationConfigOrderByWithRelationInput | WorkerAllocationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerAllocationConfigs.
     */
    cursor?: WorkerAllocationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAllocationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAllocationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerAllocationConfigs.
     */
    distinct?: WorkerAllocationConfigScalarFieldEnum | WorkerAllocationConfigScalarFieldEnum[]
  }

  /**
   * WorkerAllocationConfig findFirstOrThrow
   */
  export type WorkerAllocationConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAllocationConfig to fetch.
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAllocationConfigs to fetch.
     */
    orderBy?: WorkerAllocationConfigOrderByWithRelationInput | WorkerAllocationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerAllocationConfigs.
     */
    cursor?: WorkerAllocationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAllocationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAllocationConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerAllocationConfigs.
     */
    distinct?: WorkerAllocationConfigScalarFieldEnum | WorkerAllocationConfigScalarFieldEnum[]
  }

  /**
   * WorkerAllocationConfig findMany
   */
  export type WorkerAllocationConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * Filter, which WorkerAllocationConfigs to fetch.
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerAllocationConfigs to fetch.
     */
    orderBy?: WorkerAllocationConfigOrderByWithRelationInput | WorkerAllocationConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerAllocationConfigs.
     */
    cursor?: WorkerAllocationConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerAllocationConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerAllocationConfigs.
     */
    skip?: number
    distinct?: WorkerAllocationConfigScalarFieldEnum | WorkerAllocationConfigScalarFieldEnum[]
  }

  /**
   * WorkerAllocationConfig create
   */
  export type WorkerAllocationConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkerAllocationConfig.
     */
    data: XOR<WorkerAllocationConfigCreateInput, WorkerAllocationConfigUncheckedCreateInput>
  }

  /**
   * WorkerAllocationConfig createMany
   */
  export type WorkerAllocationConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkerAllocationConfigs.
     */
    data: WorkerAllocationConfigCreateManyInput | WorkerAllocationConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkerAllocationConfig createManyAndReturn
   */
  export type WorkerAllocationConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * The data used to create many WorkerAllocationConfigs.
     */
    data: WorkerAllocationConfigCreateManyInput | WorkerAllocationConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerAllocationConfig update
   */
  export type WorkerAllocationConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkerAllocationConfig.
     */
    data: XOR<WorkerAllocationConfigUpdateInput, WorkerAllocationConfigUncheckedUpdateInput>
    /**
     * Choose, which WorkerAllocationConfig to update.
     */
    where: WorkerAllocationConfigWhereUniqueInput
  }

  /**
   * WorkerAllocationConfig updateMany
   */
  export type WorkerAllocationConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkerAllocationConfigs.
     */
    data: XOR<WorkerAllocationConfigUpdateManyMutationInput, WorkerAllocationConfigUncheckedUpdateManyInput>
    /**
     * Filter which WorkerAllocationConfigs to update
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * Limit how many WorkerAllocationConfigs to update.
     */
    limit?: number
  }

  /**
   * WorkerAllocationConfig updateManyAndReturn
   */
  export type WorkerAllocationConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * The data used to update WorkerAllocationConfigs.
     */
    data: XOR<WorkerAllocationConfigUpdateManyMutationInput, WorkerAllocationConfigUncheckedUpdateManyInput>
    /**
     * Filter which WorkerAllocationConfigs to update
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * Limit how many WorkerAllocationConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkerAllocationConfig upsert
   */
  export type WorkerAllocationConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkerAllocationConfig to update in case it exists.
     */
    where: WorkerAllocationConfigWhereUniqueInput
    /**
     * In case the WorkerAllocationConfig found by the `where` argument doesn't exist, create a new WorkerAllocationConfig with this data.
     */
    create: XOR<WorkerAllocationConfigCreateInput, WorkerAllocationConfigUncheckedCreateInput>
    /**
     * In case the WorkerAllocationConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerAllocationConfigUpdateInput, WorkerAllocationConfigUncheckedUpdateInput>
  }

  /**
   * WorkerAllocationConfig delete
   */
  export type WorkerAllocationConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
    /**
     * Filter which WorkerAllocationConfig to delete.
     */
    where: WorkerAllocationConfigWhereUniqueInput
  }

  /**
   * WorkerAllocationConfig deleteMany
   */
  export type WorkerAllocationConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkerAllocationConfigs to delete
     */
    where?: WorkerAllocationConfigWhereInput
    /**
     * Limit how many WorkerAllocationConfigs to delete.
     */
    limit?: number
  }

  /**
   * WorkerAllocationConfig.facility_allocations
   */
  export type WorkerAllocationConfig$facility_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    where?: FacilityWorkerAllocationWhereInput
    orderBy?: FacilityWorkerAllocationOrderByWithRelationInput | FacilityWorkerAllocationOrderByWithRelationInput[]
    cursor?: FacilityWorkerAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilityWorkerAllocationScalarFieldEnum | FacilityWorkerAllocationScalarFieldEnum[]
  }

  /**
   * WorkerAllocationConfig without action
   */
  export type WorkerAllocationConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerAllocationConfig
     */
    select?: WorkerAllocationConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkerAllocationConfig
     */
    omit?: WorkerAllocationConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerAllocationConfigInclude<ExtArgs> | null
  }


  /**
   * Model FacilityWorkerAllocation
   */

  export type AggregateFacilityWorkerAllocation = {
    _count: FacilityWorkerAllocationCountAggregateOutputType | null
    _avg: FacilityWorkerAllocationAvgAggregateOutputType | null
    _sum: FacilityWorkerAllocationSumAggregateOutputType | null
    _min: FacilityWorkerAllocationMinAggregateOutputType | null
    _max: FacilityWorkerAllocationMaxAggregateOutputType | null
  }

  export type FacilityWorkerAllocationAvgAggregateOutputType = {
    id: number | null
    worker_allocation_config_id: number | null
    worker_count: number | null
    total_allocated_amount: Decimal | null
  }

  export type FacilityWorkerAllocationSumAggregateOutputType = {
    id: number | null
    worker_allocation_config_id: number | null
    worker_count: number | null
    total_allocated_amount: Decimal | null
  }

  export type FacilityWorkerAllocationMinAggregateOutputType = {
    id: number | null
    facility_id: string | null
    worker_allocation_config_id: number | null
    worker_count: number | null
    total_allocated_amount: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FacilityWorkerAllocationMaxAggregateOutputType = {
    id: number | null
    facility_id: string | null
    worker_allocation_config_id: number | null
    worker_count: number | null
    total_allocated_amount: Decimal | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FacilityWorkerAllocationCountAggregateOutputType = {
    id: number
    facility_id: number
    worker_allocation_config_id: number
    worker_count: number
    total_allocated_amount: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FacilityWorkerAllocationAvgAggregateInputType = {
    id?: true
    worker_allocation_config_id?: true
    worker_count?: true
    total_allocated_amount?: true
  }

  export type FacilityWorkerAllocationSumAggregateInputType = {
    id?: true
    worker_allocation_config_id?: true
    worker_count?: true
    total_allocated_amount?: true
  }

  export type FacilityWorkerAllocationMinAggregateInputType = {
    id?: true
    facility_id?: true
    worker_allocation_config_id?: true
    worker_count?: true
    total_allocated_amount?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type FacilityWorkerAllocationMaxAggregateInputType = {
    id?: true
    facility_id?: true
    worker_allocation_config_id?: true
    worker_count?: true
    total_allocated_amount?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type FacilityWorkerAllocationCountAggregateInputType = {
    id?: true
    facility_id?: true
    worker_allocation_config_id?: true
    worker_count?: true
    total_allocated_amount?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FacilityWorkerAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityWorkerAllocation to aggregate.
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityWorkerAllocations to fetch.
     */
    orderBy?: FacilityWorkerAllocationOrderByWithRelationInput | FacilityWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityWorkerAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityWorkerAllocations
    **/
    _count?: true | FacilityWorkerAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityWorkerAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilityWorkerAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityWorkerAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityWorkerAllocationMaxAggregateInputType
  }

  export type GetFacilityWorkerAllocationAggregateType<T extends FacilityWorkerAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityWorkerAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityWorkerAllocation[P]>
      : GetScalarType<T[P], AggregateFacilityWorkerAllocation[P]>
  }




  export type FacilityWorkerAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWorkerAllocationWhereInput
    orderBy?: FacilityWorkerAllocationOrderByWithAggregationInput | FacilityWorkerAllocationOrderByWithAggregationInput[]
    by: FacilityWorkerAllocationScalarFieldEnum[] | FacilityWorkerAllocationScalarFieldEnum
    having?: FacilityWorkerAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityWorkerAllocationCountAggregateInputType | true
    _avg?: FacilityWorkerAllocationAvgAggregateInputType
    _sum?: FacilityWorkerAllocationSumAggregateInputType
    _min?: FacilityWorkerAllocationMinAggregateInputType
    _max?: FacilityWorkerAllocationMaxAggregateInputType
  }

  export type FacilityWorkerAllocationGroupByOutputType = {
    id: number
    facility_id: string
    worker_allocation_config_id: number
    worker_count: number
    total_allocated_amount: Decimal
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: FacilityWorkerAllocationCountAggregateOutputType | null
    _avg: FacilityWorkerAllocationAvgAggregateOutputType | null
    _sum: FacilityWorkerAllocationSumAggregateOutputType | null
    _min: FacilityWorkerAllocationMinAggregateOutputType | null
    _max: FacilityWorkerAllocationMaxAggregateOutputType | null
  }

  type GetFacilityWorkerAllocationGroupByPayload<T extends FacilityWorkerAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityWorkerAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityWorkerAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityWorkerAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityWorkerAllocationGroupByOutputType[P]>
        }
      >
    >


  export type FacilityWorkerAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    worker_allocation_config_id?: boolean
    worker_count?: boolean
    total_allocated_amount?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    worker_allocation_config?: boolean | WorkerAllocationConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityWorkerAllocation"]>

  export type FacilityWorkerAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    worker_allocation_config_id?: boolean
    worker_count?: boolean
    total_allocated_amount?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    worker_allocation_config?: boolean | WorkerAllocationConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityWorkerAllocation"]>

  export type FacilityWorkerAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_id?: boolean
    worker_allocation_config_id?: boolean
    worker_count?: boolean
    total_allocated_amount?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    worker_allocation_config?: boolean | WorkerAllocationConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityWorkerAllocation"]>

  export type FacilityWorkerAllocationSelectScalar = {
    id?: boolean
    facility_id?: boolean
    worker_allocation_config_id?: boolean
    worker_count?: boolean
    total_allocated_amount?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FacilityWorkerAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facility_id" | "worker_allocation_config_id" | "worker_count" | "total_allocated_amount" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["facilityWorkerAllocation"]>
  export type FacilityWorkerAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    worker_allocation_config?: boolean | WorkerAllocationConfigDefaultArgs<ExtArgs>
  }
  export type FacilityWorkerAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    worker_allocation_config?: boolean | WorkerAllocationConfigDefaultArgs<ExtArgs>
  }
  export type FacilityWorkerAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    worker_allocation_config?: boolean | WorkerAllocationConfigDefaultArgs<ExtArgs>
  }

  export type $FacilityWorkerAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityWorkerAllocation"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      worker_allocation_config: Prisma.$WorkerAllocationConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facility_id: string
      worker_allocation_config_id: number
      worker_count: number
      total_allocated_amount: Prisma.Decimal
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["facilityWorkerAllocation"]>
    composites: {}
  }

  type FacilityWorkerAllocationGetPayload<S extends boolean | null | undefined | FacilityWorkerAllocationDefaultArgs> = $Result.GetResult<Prisma.$FacilityWorkerAllocationPayload, S>

  type FacilityWorkerAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityWorkerAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityWorkerAllocationCountAggregateInputType | true
    }

  export interface FacilityWorkerAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityWorkerAllocation'], meta: { name: 'FacilityWorkerAllocation' } }
    /**
     * Find zero or one FacilityWorkerAllocation that matches the filter.
     * @param {FacilityWorkerAllocationFindUniqueArgs} args - Arguments to find a FacilityWorkerAllocation
     * @example
     * // Get one FacilityWorkerAllocation
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityWorkerAllocationFindUniqueArgs>(args: SelectSubset<T, FacilityWorkerAllocationFindUniqueArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacilityWorkerAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityWorkerAllocationFindUniqueOrThrowArgs} args - Arguments to find a FacilityWorkerAllocation
     * @example
     * // Get one FacilityWorkerAllocation
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityWorkerAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityWorkerAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityWorkerAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationFindFirstArgs} args - Arguments to find a FacilityWorkerAllocation
     * @example
     * // Get one FacilityWorkerAllocation
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityWorkerAllocationFindFirstArgs>(args?: SelectSubset<T, FacilityWorkerAllocationFindFirstArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityWorkerAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationFindFirstOrThrowArgs} args - Arguments to find a FacilityWorkerAllocation
     * @example
     * // Get one FacilityWorkerAllocation
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityWorkerAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityWorkerAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacilityWorkerAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityWorkerAllocations
     * const facilityWorkerAllocations = await prisma.facilityWorkerAllocation.findMany()
     * 
     * // Get first 10 FacilityWorkerAllocations
     * const facilityWorkerAllocations = await prisma.facilityWorkerAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWorkerAllocationWithIdOnly = await prisma.facilityWorkerAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityWorkerAllocationFindManyArgs>(args?: SelectSubset<T, FacilityWorkerAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacilityWorkerAllocation.
     * @param {FacilityWorkerAllocationCreateArgs} args - Arguments to create a FacilityWorkerAllocation.
     * @example
     * // Create one FacilityWorkerAllocation
     * const FacilityWorkerAllocation = await prisma.facilityWorkerAllocation.create({
     *   data: {
     *     // ... data to create a FacilityWorkerAllocation
     *   }
     * })
     * 
     */
    create<T extends FacilityWorkerAllocationCreateArgs>(args: SelectSubset<T, FacilityWorkerAllocationCreateArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacilityWorkerAllocations.
     * @param {FacilityWorkerAllocationCreateManyArgs} args - Arguments to create many FacilityWorkerAllocations.
     * @example
     * // Create many FacilityWorkerAllocations
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityWorkerAllocationCreateManyArgs>(args?: SelectSubset<T, FacilityWorkerAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityWorkerAllocations and returns the data saved in the database.
     * @param {FacilityWorkerAllocationCreateManyAndReturnArgs} args - Arguments to create many FacilityWorkerAllocations.
     * @example
     * // Create many FacilityWorkerAllocations
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityWorkerAllocations and only return the `id`
     * const facilityWorkerAllocationWithIdOnly = await prisma.facilityWorkerAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityWorkerAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityWorkerAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacilityWorkerAllocation.
     * @param {FacilityWorkerAllocationDeleteArgs} args - Arguments to delete one FacilityWorkerAllocation.
     * @example
     * // Delete one FacilityWorkerAllocation
     * const FacilityWorkerAllocation = await prisma.facilityWorkerAllocation.delete({
     *   where: {
     *     // ... filter to delete one FacilityWorkerAllocation
     *   }
     * })
     * 
     */
    delete<T extends FacilityWorkerAllocationDeleteArgs>(args: SelectSubset<T, FacilityWorkerAllocationDeleteArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacilityWorkerAllocation.
     * @param {FacilityWorkerAllocationUpdateArgs} args - Arguments to update one FacilityWorkerAllocation.
     * @example
     * // Update one FacilityWorkerAllocation
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityWorkerAllocationUpdateArgs>(args: SelectSubset<T, FacilityWorkerAllocationUpdateArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacilityWorkerAllocations.
     * @param {FacilityWorkerAllocationDeleteManyArgs} args - Arguments to filter FacilityWorkerAllocations to delete.
     * @example
     * // Delete a few FacilityWorkerAllocations
     * const { count } = await prisma.facilityWorkerAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityWorkerAllocationDeleteManyArgs>(args?: SelectSubset<T, FacilityWorkerAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityWorkerAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityWorkerAllocations
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityWorkerAllocationUpdateManyArgs>(args: SelectSubset<T, FacilityWorkerAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityWorkerAllocations and returns the data updated in the database.
     * @param {FacilityWorkerAllocationUpdateManyAndReturnArgs} args - Arguments to update many FacilityWorkerAllocations.
     * @example
     * // Update many FacilityWorkerAllocations
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacilityWorkerAllocations and only return the `id`
     * const facilityWorkerAllocationWithIdOnly = await prisma.facilityWorkerAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityWorkerAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityWorkerAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacilityWorkerAllocation.
     * @param {FacilityWorkerAllocationUpsertArgs} args - Arguments to update or create a FacilityWorkerAllocation.
     * @example
     * // Update or create a FacilityWorkerAllocation
     * const facilityWorkerAllocation = await prisma.facilityWorkerAllocation.upsert({
     *   create: {
     *     // ... data to create a FacilityWorkerAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityWorkerAllocation we want to update
     *   }
     * })
     */
    upsert<T extends FacilityWorkerAllocationUpsertArgs>(args: SelectSubset<T, FacilityWorkerAllocationUpsertArgs<ExtArgs>>): Prisma__FacilityWorkerAllocationClient<$Result.GetResult<Prisma.$FacilityWorkerAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacilityWorkerAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationCountArgs} args - Arguments to filter FacilityWorkerAllocations to count.
     * @example
     * // Count the number of FacilityWorkerAllocations
     * const count = await prisma.facilityWorkerAllocation.count({
     *   where: {
     *     // ... the filter for the FacilityWorkerAllocations we want to count
     *   }
     * })
    **/
    count<T extends FacilityWorkerAllocationCountArgs>(
      args?: Subset<T, FacilityWorkerAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityWorkerAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityWorkerAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityWorkerAllocationAggregateArgs>(args: Subset<T, FacilityWorkerAllocationAggregateArgs>): Prisma.PrismaPromise<GetFacilityWorkerAllocationAggregateType<T>>

    /**
     * Group by FacilityWorkerAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityWorkerAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityWorkerAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityWorkerAllocationGroupByArgs['orderBy'] }
        : { orderBy?: FacilityWorkerAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityWorkerAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityWorkerAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityWorkerAllocation model
   */
  readonly fields: FacilityWorkerAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityWorkerAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityWorkerAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    worker_allocation_config<T extends WorkerAllocationConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkerAllocationConfigDefaultArgs<ExtArgs>>): Prisma__WorkerAllocationConfigClient<$Result.GetResult<Prisma.$WorkerAllocationConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityWorkerAllocation model
   */
  interface FacilityWorkerAllocationFieldRefs {
    readonly id: FieldRef<"FacilityWorkerAllocation", 'Int'>
    readonly facility_id: FieldRef<"FacilityWorkerAllocation", 'String'>
    readonly worker_allocation_config_id: FieldRef<"FacilityWorkerAllocation", 'Int'>
    readonly worker_count: FieldRef<"FacilityWorkerAllocation", 'Int'>
    readonly total_allocated_amount: FieldRef<"FacilityWorkerAllocation", 'Decimal'>
    readonly is_active: FieldRef<"FacilityWorkerAllocation", 'Boolean'>
    readonly created_at: FieldRef<"FacilityWorkerAllocation", 'DateTime'>
    readonly updated_at: FieldRef<"FacilityWorkerAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacilityWorkerAllocation findUnique
   */
  export type FacilityWorkerAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityWorkerAllocation to fetch.
     */
    where: FacilityWorkerAllocationWhereUniqueInput
  }

  /**
   * FacilityWorkerAllocation findUniqueOrThrow
   */
  export type FacilityWorkerAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityWorkerAllocation to fetch.
     */
    where: FacilityWorkerAllocationWhereUniqueInput
  }

  /**
   * FacilityWorkerAllocation findFirst
   */
  export type FacilityWorkerAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityWorkerAllocation to fetch.
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityWorkerAllocations to fetch.
     */
    orderBy?: FacilityWorkerAllocationOrderByWithRelationInput | FacilityWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityWorkerAllocations.
     */
    cursor?: FacilityWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityWorkerAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityWorkerAllocations.
     */
    distinct?: FacilityWorkerAllocationScalarFieldEnum | FacilityWorkerAllocationScalarFieldEnum[]
  }

  /**
   * FacilityWorkerAllocation findFirstOrThrow
   */
  export type FacilityWorkerAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityWorkerAllocation to fetch.
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityWorkerAllocations to fetch.
     */
    orderBy?: FacilityWorkerAllocationOrderByWithRelationInput | FacilityWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityWorkerAllocations.
     */
    cursor?: FacilityWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityWorkerAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityWorkerAllocations.
     */
    distinct?: FacilityWorkerAllocationScalarFieldEnum | FacilityWorkerAllocationScalarFieldEnum[]
  }

  /**
   * FacilityWorkerAllocation findMany
   */
  export type FacilityWorkerAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityWorkerAllocations to fetch.
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityWorkerAllocations to fetch.
     */
    orderBy?: FacilityWorkerAllocationOrderByWithRelationInput | FacilityWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityWorkerAllocations.
     */
    cursor?: FacilityWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityWorkerAllocations.
     */
    skip?: number
    distinct?: FacilityWorkerAllocationScalarFieldEnum | FacilityWorkerAllocationScalarFieldEnum[]
  }

  /**
   * FacilityWorkerAllocation create
   */
  export type FacilityWorkerAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityWorkerAllocation.
     */
    data: XOR<FacilityWorkerAllocationCreateInput, FacilityWorkerAllocationUncheckedCreateInput>
  }

  /**
   * FacilityWorkerAllocation createMany
   */
  export type FacilityWorkerAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityWorkerAllocations.
     */
    data: FacilityWorkerAllocationCreateManyInput | FacilityWorkerAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityWorkerAllocation createManyAndReturn
   */
  export type FacilityWorkerAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many FacilityWorkerAllocations.
     */
    data: FacilityWorkerAllocationCreateManyInput | FacilityWorkerAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityWorkerAllocation update
   */
  export type FacilityWorkerAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityWorkerAllocation.
     */
    data: XOR<FacilityWorkerAllocationUpdateInput, FacilityWorkerAllocationUncheckedUpdateInput>
    /**
     * Choose, which FacilityWorkerAllocation to update.
     */
    where: FacilityWorkerAllocationWhereUniqueInput
  }

  /**
   * FacilityWorkerAllocation updateMany
   */
  export type FacilityWorkerAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityWorkerAllocations.
     */
    data: XOR<FacilityWorkerAllocationUpdateManyMutationInput, FacilityWorkerAllocationUncheckedUpdateManyInput>
    /**
     * Filter which FacilityWorkerAllocations to update
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * Limit how many FacilityWorkerAllocations to update.
     */
    limit?: number
  }

  /**
   * FacilityWorkerAllocation updateManyAndReturn
   */
  export type FacilityWorkerAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * The data used to update FacilityWorkerAllocations.
     */
    data: XOR<FacilityWorkerAllocationUpdateManyMutationInput, FacilityWorkerAllocationUncheckedUpdateManyInput>
    /**
     * Filter which FacilityWorkerAllocations to update
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * Limit how many FacilityWorkerAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityWorkerAllocation upsert
   */
  export type FacilityWorkerAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityWorkerAllocation to update in case it exists.
     */
    where: FacilityWorkerAllocationWhereUniqueInput
    /**
     * In case the FacilityWorkerAllocation found by the `where` argument doesn't exist, create a new FacilityWorkerAllocation with this data.
     */
    create: XOR<FacilityWorkerAllocationCreateInput, FacilityWorkerAllocationUncheckedCreateInput>
    /**
     * In case the FacilityWorkerAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityWorkerAllocationUpdateInput, FacilityWorkerAllocationUncheckedUpdateInput>
  }

  /**
   * FacilityWorkerAllocation delete
   */
  export type FacilityWorkerAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter which FacilityWorkerAllocation to delete.
     */
    where: FacilityWorkerAllocationWhereUniqueInput
  }

  /**
   * FacilityWorkerAllocation deleteMany
   */
  export type FacilityWorkerAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityWorkerAllocations to delete
     */
    where?: FacilityWorkerAllocationWhereInput
    /**
     * Limit how many FacilityWorkerAllocations to delete.
     */
    limit?: number
  }

  /**
   * FacilityWorkerAllocation without action
   */
  export type FacilityWorkerAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityWorkerAllocation
     */
    select?: FacilityWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityWorkerAllocation
     */
    omit?: FacilityWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityWorkerAllocationInclude<ExtArgs> | null
  }


  /**
   * Model FacilityTypeRemuneration
   */

  export type AggregateFacilityTypeRemuneration = {
    _count: FacilityTypeRemunerationCountAggregateOutputType | null
    _avg: FacilityTypeRemunerationAvgAggregateOutputType | null
    _sum: FacilityTypeRemunerationSumAggregateOutputType | null
    _min: FacilityTypeRemunerationMinAggregateOutputType | null
    _max: FacilityTypeRemunerationMaxAggregateOutputType | null
  }

  export type FacilityTypeRemunerationAvgAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
  }

  export type FacilityTypeRemunerationSumAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
  }

  export type FacilityTypeRemunerationMinAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
    effective_from: Date | null
    effective_to: Date | null
    created_at: Date | null
    updated_at: Date | null
    facility_type_id: string | null
  }

  export type FacilityTypeRemunerationMaxAggregateOutputType = {
    id: number | null
    total_amount: Decimal | null
    effective_from: Date | null
    effective_to: Date | null
    created_at: Date | null
    updated_at: Date | null
    facility_type_id: string | null
  }

  export type FacilityTypeRemunerationCountAggregateOutputType = {
    id: number
    total_amount: number
    effective_from: number
    effective_to: number
    created_at: number
    updated_at: number
    facility_type_id: number
    _all: number
  }


  export type FacilityTypeRemunerationAvgAggregateInputType = {
    id?: true
    total_amount?: true
  }

  export type FacilityTypeRemunerationSumAggregateInputType = {
    id?: true
    total_amount?: true
  }

  export type FacilityTypeRemunerationMinAggregateInputType = {
    id?: true
    total_amount?: true
    effective_from?: true
    effective_to?: true
    created_at?: true
    updated_at?: true
    facility_type_id?: true
  }

  export type FacilityTypeRemunerationMaxAggregateInputType = {
    id?: true
    total_amount?: true
    effective_from?: true
    effective_to?: true
    created_at?: true
    updated_at?: true
    facility_type_id?: true
  }

  export type FacilityTypeRemunerationCountAggregateInputType = {
    id?: true
    total_amount?: true
    effective_from?: true
    effective_to?: true
    created_at?: true
    updated_at?: true
    facility_type_id?: true
    _all?: true
  }

  export type FacilityTypeRemunerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityTypeRemuneration to aggregate.
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypeRemunerations to fetch.
     */
    orderBy?: FacilityTypeRemunerationOrderByWithRelationInput | FacilityTypeRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityTypeRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypeRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypeRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityTypeRemunerations
    **/
    _count?: true | FacilityTypeRemunerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityTypeRemunerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilityTypeRemunerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityTypeRemunerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityTypeRemunerationMaxAggregateInputType
  }

  export type GetFacilityTypeRemunerationAggregateType<T extends FacilityTypeRemunerationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityTypeRemuneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityTypeRemuneration[P]>
      : GetScalarType<T[P], AggregateFacilityTypeRemuneration[P]>
  }




  export type FacilityTypeRemunerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityTypeRemunerationWhereInput
    orderBy?: FacilityTypeRemunerationOrderByWithAggregationInput | FacilityTypeRemunerationOrderByWithAggregationInput[]
    by: FacilityTypeRemunerationScalarFieldEnum[] | FacilityTypeRemunerationScalarFieldEnum
    having?: FacilityTypeRemunerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityTypeRemunerationCountAggregateInputType | true
    _avg?: FacilityTypeRemunerationAvgAggregateInputType
    _sum?: FacilityTypeRemunerationSumAggregateInputType
    _min?: FacilityTypeRemunerationMinAggregateInputType
    _max?: FacilityTypeRemunerationMaxAggregateInputType
  }

  export type FacilityTypeRemunerationGroupByOutputType = {
    id: number
    total_amount: Decimal
    effective_from: Date
    effective_to: Date | null
    created_at: Date
    updated_at: Date
    facility_type_id: string
    _count: FacilityTypeRemunerationCountAggregateOutputType | null
    _avg: FacilityTypeRemunerationAvgAggregateOutputType | null
    _sum: FacilityTypeRemunerationSumAggregateOutputType | null
    _min: FacilityTypeRemunerationMinAggregateOutputType | null
    _max: FacilityTypeRemunerationMaxAggregateOutputType | null
  }

  type GetFacilityTypeRemunerationGroupByPayload<T extends FacilityTypeRemunerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityTypeRemunerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityTypeRemunerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityTypeRemunerationGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityTypeRemunerationGroupByOutputType[P]>
        }
      >
    >


  export type FacilityTypeRemunerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_amount?: boolean
    effective_from?: boolean
    effective_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    indicator_remunerations?: boolean | FacilityTypeRemuneration$indicator_remunerationsArgs<ExtArgs>
    _count?: boolean | FacilityTypeRemunerationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityTypeRemuneration"]>

  export type FacilityTypeRemunerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_amount?: boolean
    effective_from?: boolean
    effective_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityTypeRemuneration"]>

  export type FacilityTypeRemunerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_amount?: boolean
    effective_from?: boolean
    effective_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityTypeRemuneration"]>

  export type FacilityTypeRemunerationSelectScalar = {
    id?: boolean
    total_amount?: boolean
    effective_from?: boolean
    effective_to?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_type_id?: boolean
  }

  export type FacilityTypeRemunerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "total_amount" | "effective_from" | "effective_to" | "created_at" | "updated_at" | "facility_type_id", ExtArgs["result"]["facilityTypeRemuneration"]>
  export type FacilityTypeRemunerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
    indicator_remunerations?: boolean | FacilityTypeRemuneration$indicator_remunerationsArgs<ExtArgs>
    _count?: boolean | FacilityTypeRemunerationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityTypeRemunerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }
  export type FacilityTypeRemunerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type?: boolean | FacilityTypeDefaultArgs<ExtArgs>
  }

  export type $FacilityTypeRemunerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityTypeRemuneration"
    objects: {
      facility_type: Prisma.$FacilityTypePayload<ExtArgs>
      indicator_remunerations: Prisma.$IndicatorRemunerationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      total_amount: Prisma.Decimal
      effective_from: Date
      effective_to: Date | null
      created_at: Date
      updated_at: Date
      facility_type_id: string
    }, ExtArgs["result"]["facilityTypeRemuneration"]>
    composites: {}
  }

  type FacilityTypeRemunerationGetPayload<S extends boolean | null | undefined | FacilityTypeRemunerationDefaultArgs> = $Result.GetResult<Prisma.$FacilityTypeRemunerationPayload, S>

  type FacilityTypeRemunerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityTypeRemunerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityTypeRemunerationCountAggregateInputType | true
    }

  export interface FacilityTypeRemunerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityTypeRemuneration'], meta: { name: 'FacilityTypeRemuneration' } }
    /**
     * Find zero or one FacilityTypeRemuneration that matches the filter.
     * @param {FacilityTypeRemunerationFindUniqueArgs} args - Arguments to find a FacilityTypeRemuneration
     * @example
     * // Get one FacilityTypeRemuneration
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityTypeRemunerationFindUniqueArgs>(args: SelectSubset<T, FacilityTypeRemunerationFindUniqueArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacilityTypeRemuneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityTypeRemunerationFindUniqueOrThrowArgs} args - Arguments to find a FacilityTypeRemuneration
     * @example
     * // Get one FacilityTypeRemuneration
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityTypeRemunerationFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityTypeRemunerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityTypeRemuneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationFindFirstArgs} args - Arguments to find a FacilityTypeRemuneration
     * @example
     * // Get one FacilityTypeRemuneration
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityTypeRemunerationFindFirstArgs>(args?: SelectSubset<T, FacilityTypeRemunerationFindFirstArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityTypeRemuneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationFindFirstOrThrowArgs} args - Arguments to find a FacilityTypeRemuneration
     * @example
     * // Get one FacilityTypeRemuneration
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityTypeRemunerationFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityTypeRemunerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacilityTypeRemunerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityTypeRemunerations
     * const facilityTypeRemunerations = await prisma.facilityTypeRemuneration.findMany()
     * 
     * // Get first 10 FacilityTypeRemunerations
     * const facilityTypeRemunerations = await prisma.facilityTypeRemuneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityTypeRemunerationWithIdOnly = await prisma.facilityTypeRemuneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityTypeRemunerationFindManyArgs>(args?: SelectSubset<T, FacilityTypeRemunerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacilityTypeRemuneration.
     * @param {FacilityTypeRemunerationCreateArgs} args - Arguments to create a FacilityTypeRemuneration.
     * @example
     * // Create one FacilityTypeRemuneration
     * const FacilityTypeRemuneration = await prisma.facilityTypeRemuneration.create({
     *   data: {
     *     // ... data to create a FacilityTypeRemuneration
     *   }
     * })
     * 
     */
    create<T extends FacilityTypeRemunerationCreateArgs>(args: SelectSubset<T, FacilityTypeRemunerationCreateArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacilityTypeRemunerations.
     * @param {FacilityTypeRemunerationCreateManyArgs} args - Arguments to create many FacilityTypeRemunerations.
     * @example
     * // Create many FacilityTypeRemunerations
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityTypeRemunerationCreateManyArgs>(args?: SelectSubset<T, FacilityTypeRemunerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityTypeRemunerations and returns the data saved in the database.
     * @param {FacilityTypeRemunerationCreateManyAndReturnArgs} args - Arguments to create many FacilityTypeRemunerations.
     * @example
     * // Create many FacilityTypeRemunerations
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityTypeRemunerations and only return the `id`
     * const facilityTypeRemunerationWithIdOnly = await prisma.facilityTypeRemuneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityTypeRemunerationCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityTypeRemunerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacilityTypeRemuneration.
     * @param {FacilityTypeRemunerationDeleteArgs} args - Arguments to delete one FacilityTypeRemuneration.
     * @example
     * // Delete one FacilityTypeRemuneration
     * const FacilityTypeRemuneration = await prisma.facilityTypeRemuneration.delete({
     *   where: {
     *     // ... filter to delete one FacilityTypeRemuneration
     *   }
     * })
     * 
     */
    delete<T extends FacilityTypeRemunerationDeleteArgs>(args: SelectSubset<T, FacilityTypeRemunerationDeleteArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacilityTypeRemuneration.
     * @param {FacilityTypeRemunerationUpdateArgs} args - Arguments to update one FacilityTypeRemuneration.
     * @example
     * // Update one FacilityTypeRemuneration
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityTypeRemunerationUpdateArgs>(args: SelectSubset<T, FacilityTypeRemunerationUpdateArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacilityTypeRemunerations.
     * @param {FacilityTypeRemunerationDeleteManyArgs} args - Arguments to filter FacilityTypeRemunerations to delete.
     * @example
     * // Delete a few FacilityTypeRemunerations
     * const { count } = await prisma.facilityTypeRemuneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityTypeRemunerationDeleteManyArgs>(args?: SelectSubset<T, FacilityTypeRemunerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityTypeRemunerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityTypeRemunerations
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityTypeRemunerationUpdateManyArgs>(args: SelectSubset<T, FacilityTypeRemunerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityTypeRemunerations and returns the data updated in the database.
     * @param {FacilityTypeRemunerationUpdateManyAndReturnArgs} args - Arguments to update many FacilityTypeRemunerations.
     * @example
     * // Update many FacilityTypeRemunerations
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacilityTypeRemunerations and only return the `id`
     * const facilityTypeRemunerationWithIdOnly = await prisma.facilityTypeRemuneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityTypeRemunerationUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityTypeRemunerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacilityTypeRemuneration.
     * @param {FacilityTypeRemunerationUpsertArgs} args - Arguments to update or create a FacilityTypeRemuneration.
     * @example
     * // Update or create a FacilityTypeRemuneration
     * const facilityTypeRemuneration = await prisma.facilityTypeRemuneration.upsert({
     *   create: {
     *     // ... data to create a FacilityTypeRemuneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityTypeRemuneration we want to update
     *   }
     * })
     */
    upsert<T extends FacilityTypeRemunerationUpsertArgs>(args: SelectSubset<T, FacilityTypeRemunerationUpsertArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacilityTypeRemunerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationCountArgs} args - Arguments to filter FacilityTypeRemunerations to count.
     * @example
     * // Count the number of FacilityTypeRemunerations
     * const count = await prisma.facilityTypeRemuneration.count({
     *   where: {
     *     // ... the filter for the FacilityTypeRemunerations we want to count
     *   }
     * })
    **/
    count<T extends FacilityTypeRemunerationCountArgs>(
      args?: Subset<T, FacilityTypeRemunerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityTypeRemunerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityTypeRemuneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityTypeRemunerationAggregateArgs>(args: Subset<T, FacilityTypeRemunerationAggregateArgs>): Prisma.PrismaPromise<GetFacilityTypeRemunerationAggregateType<T>>

    /**
     * Group by FacilityTypeRemuneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTypeRemunerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityTypeRemunerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityTypeRemunerationGroupByArgs['orderBy'] }
        : { orderBy?: FacilityTypeRemunerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityTypeRemunerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityTypeRemunerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityTypeRemuneration model
   */
  readonly fields: FacilityTypeRemunerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityTypeRemuneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityTypeRemunerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility_type<T extends FacilityTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityTypeDefaultArgs<ExtArgs>>): Prisma__FacilityTypeClient<$Result.GetResult<Prisma.$FacilityTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicator_remunerations<T extends FacilityTypeRemuneration$indicator_remunerationsArgs<ExtArgs> = {}>(args?: Subset<T, FacilityTypeRemuneration$indicator_remunerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityTypeRemuneration model
   */
  interface FacilityTypeRemunerationFieldRefs {
    readonly id: FieldRef<"FacilityTypeRemuneration", 'Int'>
    readonly total_amount: FieldRef<"FacilityTypeRemuneration", 'Decimal'>
    readonly effective_from: FieldRef<"FacilityTypeRemuneration", 'DateTime'>
    readonly effective_to: FieldRef<"FacilityTypeRemuneration", 'DateTime'>
    readonly created_at: FieldRef<"FacilityTypeRemuneration", 'DateTime'>
    readonly updated_at: FieldRef<"FacilityTypeRemuneration", 'DateTime'>
    readonly facility_type_id: FieldRef<"FacilityTypeRemuneration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FacilityTypeRemuneration findUnique
   */
  export type FacilityTypeRemunerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTypeRemuneration to fetch.
     */
    where: FacilityTypeRemunerationWhereUniqueInput
  }

  /**
   * FacilityTypeRemuneration findUniqueOrThrow
   */
  export type FacilityTypeRemunerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTypeRemuneration to fetch.
     */
    where: FacilityTypeRemunerationWhereUniqueInput
  }

  /**
   * FacilityTypeRemuneration findFirst
   */
  export type FacilityTypeRemunerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTypeRemuneration to fetch.
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypeRemunerations to fetch.
     */
    orderBy?: FacilityTypeRemunerationOrderByWithRelationInput | FacilityTypeRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityTypeRemunerations.
     */
    cursor?: FacilityTypeRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypeRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypeRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityTypeRemunerations.
     */
    distinct?: FacilityTypeRemunerationScalarFieldEnum | FacilityTypeRemunerationScalarFieldEnum[]
  }

  /**
   * FacilityTypeRemuneration findFirstOrThrow
   */
  export type FacilityTypeRemunerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTypeRemuneration to fetch.
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypeRemunerations to fetch.
     */
    orderBy?: FacilityTypeRemunerationOrderByWithRelationInput | FacilityTypeRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityTypeRemunerations.
     */
    cursor?: FacilityTypeRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypeRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypeRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityTypeRemunerations.
     */
    distinct?: FacilityTypeRemunerationScalarFieldEnum | FacilityTypeRemunerationScalarFieldEnum[]
  }

  /**
   * FacilityTypeRemuneration findMany
   */
  export type FacilityTypeRemunerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTypeRemunerations to fetch.
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTypeRemunerations to fetch.
     */
    orderBy?: FacilityTypeRemunerationOrderByWithRelationInput | FacilityTypeRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityTypeRemunerations.
     */
    cursor?: FacilityTypeRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTypeRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTypeRemunerations.
     */
    skip?: number
    distinct?: FacilityTypeRemunerationScalarFieldEnum | FacilityTypeRemunerationScalarFieldEnum[]
  }

  /**
   * FacilityTypeRemuneration create
   */
  export type FacilityTypeRemunerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityTypeRemuneration.
     */
    data: XOR<FacilityTypeRemunerationCreateInput, FacilityTypeRemunerationUncheckedCreateInput>
  }

  /**
   * FacilityTypeRemuneration createMany
   */
  export type FacilityTypeRemunerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityTypeRemunerations.
     */
    data: FacilityTypeRemunerationCreateManyInput | FacilityTypeRemunerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityTypeRemuneration createManyAndReturn
   */
  export type FacilityTypeRemunerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * The data used to create many FacilityTypeRemunerations.
     */
    data: FacilityTypeRemunerationCreateManyInput | FacilityTypeRemunerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityTypeRemuneration update
   */
  export type FacilityTypeRemunerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityTypeRemuneration.
     */
    data: XOR<FacilityTypeRemunerationUpdateInput, FacilityTypeRemunerationUncheckedUpdateInput>
    /**
     * Choose, which FacilityTypeRemuneration to update.
     */
    where: FacilityTypeRemunerationWhereUniqueInput
  }

  /**
   * FacilityTypeRemuneration updateMany
   */
  export type FacilityTypeRemunerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityTypeRemunerations.
     */
    data: XOR<FacilityTypeRemunerationUpdateManyMutationInput, FacilityTypeRemunerationUncheckedUpdateManyInput>
    /**
     * Filter which FacilityTypeRemunerations to update
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * Limit how many FacilityTypeRemunerations to update.
     */
    limit?: number
  }

  /**
   * FacilityTypeRemuneration updateManyAndReturn
   */
  export type FacilityTypeRemunerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * The data used to update FacilityTypeRemunerations.
     */
    data: XOR<FacilityTypeRemunerationUpdateManyMutationInput, FacilityTypeRemunerationUncheckedUpdateManyInput>
    /**
     * Filter which FacilityTypeRemunerations to update
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * Limit how many FacilityTypeRemunerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityTypeRemuneration upsert
   */
  export type FacilityTypeRemunerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityTypeRemuneration to update in case it exists.
     */
    where: FacilityTypeRemunerationWhereUniqueInput
    /**
     * In case the FacilityTypeRemuneration found by the `where` argument doesn't exist, create a new FacilityTypeRemuneration with this data.
     */
    create: XOR<FacilityTypeRemunerationCreateInput, FacilityTypeRemunerationUncheckedCreateInput>
    /**
     * In case the FacilityTypeRemuneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityTypeRemunerationUpdateInput, FacilityTypeRemunerationUncheckedUpdateInput>
  }

  /**
   * FacilityTypeRemuneration delete
   */
  export type FacilityTypeRemunerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
    /**
     * Filter which FacilityTypeRemuneration to delete.
     */
    where: FacilityTypeRemunerationWhereUniqueInput
  }

  /**
   * FacilityTypeRemuneration deleteMany
   */
  export type FacilityTypeRemunerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityTypeRemunerations to delete
     */
    where?: FacilityTypeRemunerationWhereInput
    /**
     * Limit how many FacilityTypeRemunerations to delete.
     */
    limit?: number
  }

  /**
   * FacilityTypeRemuneration.indicator_remunerations
   */
  export type FacilityTypeRemuneration$indicator_remunerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    where?: IndicatorRemunerationWhereInput
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    cursor?: IndicatorRemunerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicatorRemunerationScalarFieldEnum | IndicatorRemunerationScalarFieldEnum[]
  }

  /**
   * FacilityTypeRemuneration without action
   */
  export type FacilityTypeRemunerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTypeRemuneration
     */
    select?: FacilityTypeRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTypeRemuneration
     */
    omit?: FacilityTypeRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTypeRemunerationInclude<ExtArgs> | null
  }


  /**
   * Model IndicatorRemuneration
   */

  export type AggregateIndicatorRemuneration = {
    _count: IndicatorRemunerationCountAggregateOutputType | null
    _avg: IndicatorRemunerationAvgAggregateOutputType | null
    _sum: IndicatorRemunerationSumAggregateOutputType | null
    _min: IndicatorRemunerationMinAggregateOutputType | null
    _max: IndicatorRemunerationMaxAggregateOutputType | null
  }

  export type IndicatorRemunerationAvgAggregateOutputType = {
    id: number | null
    facility_type_remuneration_id: number | null
    indicator_id: number | null
    base_amount: Decimal | null
    conditional_amount: Decimal | null
  }

  export type IndicatorRemunerationSumAggregateOutputType = {
    id: number | null
    facility_type_remuneration_id: number | null
    indicator_id: number | null
    base_amount: Decimal | null
    conditional_amount: Decimal | null
  }

  export type IndicatorRemunerationMinAggregateOutputType = {
    id: number | null
    facility_type_remuneration_id: number | null
    indicator_id: number | null
    base_amount: Decimal | null
    conditional_amount: Decimal | null
    condition_type: string | null
    created_at: Date | null
    updated_at: Date | null
    remuneration_system_id: string | null
  }

  export type IndicatorRemunerationMaxAggregateOutputType = {
    id: number | null
    facility_type_remuneration_id: number | null
    indicator_id: number | null
    base_amount: Decimal | null
    conditional_amount: Decimal | null
    condition_type: string | null
    created_at: Date | null
    updated_at: Date | null
    remuneration_system_id: string | null
  }

  export type IndicatorRemunerationCountAggregateOutputType = {
    id: number
    facility_type_remuneration_id: number
    indicator_id: number
    base_amount: number
    conditional_amount: number
    condition_type: number
    created_at: number
    updated_at: number
    remuneration_system_id: number
    _all: number
  }


  export type IndicatorRemunerationAvgAggregateInputType = {
    id?: true
    facility_type_remuneration_id?: true
    indicator_id?: true
    base_amount?: true
    conditional_amount?: true
  }

  export type IndicatorRemunerationSumAggregateInputType = {
    id?: true
    facility_type_remuneration_id?: true
    indicator_id?: true
    base_amount?: true
    conditional_amount?: true
  }

  export type IndicatorRemunerationMinAggregateInputType = {
    id?: true
    facility_type_remuneration_id?: true
    indicator_id?: true
    base_amount?: true
    conditional_amount?: true
    condition_type?: true
    created_at?: true
    updated_at?: true
    remuneration_system_id?: true
  }

  export type IndicatorRemunerationMaxAggregateInputType = {
    id?: true
    facility_type_remuneration_id?: true
    indicator_id?: true
    base_amount?: true
    conditional_amount?: true
    condition_type?: true
    created_at?: true
    updated_at?: true
    remuneration_system_id?: true
  }

  export type IndicatorRemunerationCountAggregateInputType = {
    id?: true
    facility_type_remuneration_id?: true
    indicator_id?: true
    base_amount?: true
    conditional_amount?: true
    condition_type?: true
    created_at?: true
    updated_at?: true
    remuneration_system_id?: true
    _all?: true
  }

  export type IndicatorRemunerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorRemuneration to aggregate.
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorRemunerations to fetch.
     */
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicatorRemunerations
    **/
    _count?: true | IndicatorRemunerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorRemunerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorRemunerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorRemunerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorRemunerationMaxAggregateInputType
  }

  export type GetIndicatorRemunerationAggregateType<T extends IndicatorRemunerationAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicatorRemuneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicatorRemuneration[P]>
      : GetScalarType<T[P], AggregateIndicatorRemuneration[P]>
  }




  export type IndicatorRemunerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorRemunerationWhereInput
    orderBy?: IndicatorRemunerationOrderByWithAggregationInput | IndicatorRemunerationOrderByWithAggregationInput[]
    by: IndicatorRemunerationScalarFieldEnum[] | IndicatorRemunerationScalarFieldEnum
    having?: IndicatorRemunerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorRemunerationCountAggregateInputType | true
    _avg?: IndicatorRemunerationAvgAggregateInputType
    _sum?: IndicatorRemunerationSumAggregateInputType
    _min?: IndicatorRemunerationMinAggregateInputType
    _max?: IndicatorRemunerationMaxAggregateInputType
  }

  export type IndicatorRemunerationGroupByOutputType = {
    id: number
    facility_type_remuneration_id: number
    indicator_id: number
    base_amount: Decimal
    conditional_amount: Decimal | null
    condition_type: string | null
    created_at: Date
    updated_at: Date
    remuneration_system_id: string | null
    _count: IndicatorRemunerationCountAggregateOutputType | null
    _avg: IndicatorRemunerationAvgAggregateOutputType | null
    _sum: IndicatorRemunerationSumAggregateOutputType | null
    _min: IndicatorRemunerationMinAggregateOutputType | null
    _max: IndicatorRemunerationMaxAggregateOutputType | null
  }

  type GetIndicatorRemunerationGroupByPayload<T extends IndicatorRemunerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorRemunerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorRemunerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorRemunerationGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorRemunerationGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorRemunerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_type_remuneration_id?: boolean
    indicator_id?: boolean
    base_amount?: boolean
    conditional_amount?: boolean
    condition_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    remuneration_system_id?: boolean
    facility_type_remuneration?: boolean | FacilityTypeRemunerationDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    remuneration_system?: boolean | IndicatorRemuneration$remuneration_systemArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorRemuneration"]>

  export type IndicatorRemunerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_type_remuneration_id?: boolean
    indicator_id?: boolean
    base_amount?: boolean
    conditional_amount?: boolean
    condition_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    remuneration_system_id?: boolean
    facility_type_remuneration?: boolean | FacilityTypeRemunerationDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    remuneration_system?: boolean | IndicatorRemuneration$remuneration_systemArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorRemuneration"]>

  export type IndicatorRemunerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facility_type_remuneration_id?: boolean
    indicator_id?: boolean
    base_amount?: boolean
    conditional_amount?: boolean
    condition_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    remuneration_system_id?: boolean
    facility_type_remuneration?: boolean | FacilityTypeRemunerationDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    remuneration_system?: boolean | IndicatorRemuneration$remuneration_systemArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorRemuneration"]>

  export type IndicatorRemunerationSelectScalar = {
    id?: boolean
    facility_type_remuneration_id?: boolean
    indicator_id?: boolean
    base_amount?: boolean
    conditional_amount?: boolean
    condition_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    remuneration_system_id?: boolean
  }

  export type IndicatorRemunerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facility_type_remuneration_id" | "indicator_id" | "base_amount" | "conditional_amount" | "condition_type" | "created_at" | "updated_at" | "remuneration_system_id", ExtArgs["result"]["indicatorRemuneration"]>
  export type IndicatorRemunerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type_remuneration?: boolean | FacilityTypeRemunerationDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    remuneration_system?: boolean | IndicatorRemuneration$remuneration_systemArgs<ExtArgs>
  }
  export type IndicatorRemunerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type_remuneration?: boolean | FacilityTypeRemunerationDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    remuneration_system?: boolean | IndicatorRemuneration$remuneration_systemArgs<ExtArgs>
  }
  export type IndicatorRemunerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility_type_remuneration?: boolean | FacilityTypeRemunerationDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    remuneration_system?: boolean | IndicatorRemuneration$remuneration_systemArgs<ExtArgs>
  }

  export type $IndicatorRemunerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicatorRemuneration"
    objects: {
      facility_type_remuneration: Prisma.$FacilityTypeRemunerationPayload<ExtArgs>
      indicator: Prisma.$IndicatorPayload<ExtArgs>
      remuneration_system: Prisma.$RemunerationSystemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facility_type_remuneration_id: number
      indicator_id: number
      base_amount: Prisma.Decimal
      conditional_amount: Prisma.Decimal | null
      condition_type: string | null
      created_at: Date
      updated_at: Date
      remuneration_system_id: string | null
    }, ExtArgs["result"]["indicatorRemuneration"]>
    composites: {}
  }

  type IndicatorRemunerationGetPayload<S extends boolean | null | undefined | IndicatorRemunerationDefaultArgs> = $Result.GetResult<Prisma.$IndicatorRemunerationPayload, S>

  type IndicatorRemunerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicatorRemunerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicatorRemunerationCountAggregateInputType | true
    }

  export interface IndicatorRemunerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicatorRemuneration'], meta: { name: 'IndicatorRemuneration' } }
    /**
     * Find zero or one IndicatorRemuneration that matches the filter.
     * @param {IndicatorRemunerationFindUniqueArgs} args - Arguments to find a IndicatorRemuneration
     * @example
     * // Get one IndicatorRemuneration
     * const indicatorRemuneration = await prisma.indicatorRemuneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorRemunerationFindUniqueArgs>(args: SelectSubset<T, IndicatorRemunerationFindUniqueArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IndicatorRemuneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicatorRemunerationFindUniqueOrThrowArgs} args - Arguments to find a IndicatorRemuneration
     * @example
     * // Get one IndicatorRemuneration
     * const indicatorRemuneration = await prisma.indicatorRemuneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorRemunerationFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorRemunerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndicatorRemuneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationFindFirstArgs} args - Arguments to find a IndicatorRemuneration
     * @example
     * // Get one IndicatorRemuneration
     * const indicatorRemuneration = await prisma.indicatorRemuneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorRemunerationFindFirstArgs>(args?: SelectSubset<T, IndicatorRemunerationFindFirstArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndicatorRemuneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationFindFirstOrThrowArgs} args - Arguments to find a IndicatorRemuneration
     * @example
     * // Get one IndicatorRemuneration
     * const indicatorRemuneration = await prisma.indicatorRemuneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorRemunerationFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorRemunerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IndicatorRemunerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicatorRemunerations
     * const indicatorRemunerations = await prisma.indicatorRemuneration.findMany()
     * 
     * // Get first 10 IndicatorRemunerations
     * const indicatorRemunerations = await prisma.indicatorRemuneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorRemunerationWithIdOnly = await prisma.indicatorRemuneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorRemunerationFindManyArgs>(args?: SelectSubset<T, IndicatorRemunerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IndicatorRemuneration.
     * @param {IndicatorRemunerationCreateArgs} args - Arguments to create a IndicatorRemuneration.
     * @example
     * // Create one IndicatorRemuneration
     * const IndicatorRemuneration = await prisma.indicatorRemuneration.create({
     *   data: {
     *     // ... data to create a IndicatorRemuneration
     *   }
     * })
     * 
     */
    create<T extends IndicatorRemunerationCreateArgs>(args: SelectSubset<T, IndicatorRemunerationCreateArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IndicatorRemunerations.
     * @param {IndicatorRemunerationCreateManyArgs} args - Arguments to create many IndicatorRemunerations.
     * @example
     * // Create many IndicatorRemunerations
     * const indicatorRemuneration = await prisma.indicatorRemuneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorRemunerationCreateManyArgs>(args?: SelectSubset<T, IndicatorRemunerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicatorRemunerations and returns the data saved in the database.
     * @param {IndicatorRemunerationCreateManyAndReturnArgs} args - Arguments to create many IndicatorRemunerations.
     * @example
     * // Create many IndicatorRemunerations
     * const indicatorRemuneration = await prisma.indicatorRemuneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicatorRemunerations and only return the `id`
     * const indicatorRemunerationWithIdOnly = await prisma.indicatorRemuneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorRemunerationCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorRemunerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IndicatorRemuneration.
     * @param {IndicatorRemunerationDeleteArgs} args - Arguments to delete one IndicatorRemuneration.
     * @example
     * // Delete one IndicatorRemuneration
     * const IndicatorRemuneration = await prisma.indicatorRemuneration.delete({
     *   where: {
     *     // ... filter to delete one IndicatorRemuneration
     *   }
     * })
     * 
     */
    delete<T extends IndicatorRemunerationDeleteArgs>(args: SelectSubset<T, IndicatorRemunerationDeleteArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IndicatorRemuneration.
     * @param {IndicatorRemunerationUpdateArgs} args - Arguments to update one IndicatorRemuneration.
     * @example
     * // Update one IndicatorRemuneration
     * const indicatorRemuneration = await prisma.indicatorRemuneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorRemunerationUpdateArgs>(args: SelectSubset<T, IndicatorRemunerationUpdateArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IndicatorRemunerations.
     * @param {IndicatorRemunerationDeleteManyArgs} args - Arguments to filter IndicatorRemunerations to delete.
     * @example
     * // Delete a few IndicatorRemunerations
     * const { count } = await prisma.indicatorRemuneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorRemunerationDeleteManyArgs>(args?: SelectSubset<T, IndicatorRemunerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorRemunerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicatorRemunerations
     * const indicatorRemuneration = await prisma.indicatorRemuneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorRemunerationUpdateManyArgs>(args: SelectSubset<T, IndicatorRemunerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorRemunerations and returns the data updated in the database.
     * @param {IndicatorRemunerationUpdateManyAndReturnArgs} args - Arguments to update many IndicatorRemunerations.
     * @example
     * // Update many IndicatorRemunerations
     * const indicatorRemuneration = await prisma.indicatorRemuneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IndicatorRemunerations and only return the `id`
     * const indicatorRemunerationWithIdOnly = await prisma.indicatorRemuneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndicatorRemunerationUpdateManyAndReturnArgs>(args: SelectSubset<T, IndicatorRemunerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IndicatorRemuneration.
     * @param {IndicatorRemunerationUpsertArgs} args - Arguments to update or create a IndicatorRemuneration.
     * @example
     * // Update or create a IndicatorRemuneration
     * const indicatorRemuneration = await prisma.indicatorRemuneration.upsert({
     *   create: {
     *     // ... data to create a IndicatorRemuneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicatorRemuneration we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorRemunerationUpsertArgs>(args: SelectSubset<T, IndicatorRemunerationUpsertArgs<ExtArgs>>): Prisma__IndicatorRemunerationClient<$Result.GetResult<Prisma.$IndicatorRemunerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IndicatorRemunerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationCountArgs} args - Arguments to filter IndicatorRemunerations to count.
     * @example
     * // Count the number of IndicatorRemunerations
     * const count = await prisma.indicatorRemuneration.count({
     *   where: {
     *     // ... the filter for the IndicatorRemunerations we want to count
     *   }
     * })
    **/
    count<T extends IndicatorRemunerationCountArgs>(
      args?: Subset<T, IndicatorRemunerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorRemunerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicatorRemuneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorRemunerationAggregateArgs>(args: Subset<T, IndicatorRemunerationAggregateArgs>): Prisma.PrismaPromise<GetIndicatorRemunerationAggregateType<T>>

    /**
     * Group by IndicatorRemuneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorRemunerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorRemunerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorRemunerationGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorRemunerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorRemunerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorRemunerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicatorRemuneration model
   */
  readonly fields: IndicatorRemunerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicatorRemuneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorRemunerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility_type_remuneration<T extends FacilityTypeRemunerationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityTypeRemunerationDefaultArgs<ExtArgs>>): Prisma__FacilityTypeRemunerationClient<$Result.GetResult<Prisma.$FacilityTypeRemunerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    remuneration_system<T extends IndicatorRemuneration$remuneration_systemArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorRemuneration$remuneration_systemArgs<ExtArgs>>): Prisma__RemunerationSystemClient<$Result.GetResult<Prisma.$RemunerationSystemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicatorRemuneration model
   */
  interface IndicatorRemunerationFieldRefs {
    readonly id: FieldRef<"IndicatorRemuneration", 'Int'>
    readonly facility_type_remuneration_id: FieldRef<"IndicatorRemuneration", 'Int'>
    readonly indicator_id: FieldRef<"IndicatorRemuneration", 'Int'>
    readonly base_amount: FieldRef<"IndicatorRemuneration", 'Decimal'>
    readonly conditional_amount: FieldRef<"IndicatorRemuneration", 'Decimal'>
    readonly condition_type: FieldRef<"IndicatorRemuneration", 'String'>
    readonly created_at: FieldRef<"IndicatorRemuneration", 'DateTime'>
    readonly updated_at: FieldRef<"IndicatorRemuneration", 'DateTime'>
    readonly remuneration_system_id: FieldRef<"IndicatorRemuneration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IndicatorRemuneration findUnique
   */
  export type IndicatorRemunerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorRemuneration to fetch.
     */
    where: IndicatorRemunerationWhereUniqueInput
  }

  /**
   * IndicatorRemuneration findUniqueOrThrow
   */
  export type IndicatorRemunerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorRemuneration to fetch.
     */
    where: IndicatorRemunerationWhereUniqueInput
  }

  /**
   * IndicatorRemuneration findFirst
   */
  export type IndicatorRemunerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorRemuneration to fetch.
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorRemunerations to fetch.
     */
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorRemunerations.
     */
    cursor?: IndicatorRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorRemunerations.
     */
    distinct?: IndicatorRemunerationScalarFieldEnum | IndicatorRemunerationScalarFieldEnum[]
  }

  /**
   * IndicatorRemuneration findFirstOrThrow
   */
  export type IndicatorRemunerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorRemuneration to fetch.
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorRemunerations to fetch.
     */
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorRemunerations.
     */
    cursor?: IndicatorRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorRemunerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorRemunerations.
     */
    distinct?: IndicatorRemunerationScalarFieldEnum | IndicatorRemunerationScalarFieldEnum[]
  }

  /**
   * IndicatorRemuneration findMany
   */
  export type IndicatorRemunerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorRemunerations to fetch.
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorRemunerations to fetch.
     */
    orderBy?: IndicatorRemunerationOrderByWithRelationInput | IndicatorRemunerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicatorRemunerations.
     */
    cursor?: IndicatorRemunerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorRemunerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorRemunerations.
     */
    skip?: number
    distinct?: IndicatorRemunerationScalarFieldEnum | IndicatorRemunerationScalarFieldEnum[]
  }

  /**
   * IndicatorRemuneration create
   */
  export type IndicatorRemunerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicatorRemuneration.
     */
    data: XOR<IndicatorRemunerationCreateInput, IndicatorRemunerationUncheckedCreateInput>
  }

  /**
   * IndicatorRemuneration createMany
   */
  export type IndicatorRemunerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicatorRemunerations.
     */
    data: IndicatorRemunerationCreateManyInput | IndicatorRemunerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorRemuneration createManyAndReturn
   */
  export type IndicatorRemunerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * The data used to create many IndicatorRemunerations.
     */
    data: IndicatorRemunerationCreateManyInput | IndicatorRemunerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorRemuneration update
   */
  export type IndicatorRemunerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicatorRemuneration.
     */
    data: XOR<IndicatorRemunerationUpdateInput, IndicatorRemunerationUncheckedUpdateInput>
    /**
     * Choose, which IndicatorRemuneration to update.
     */
    where: IndicatorRemunerationWhereUniqueInput
  }

  /**
   * IndicatorRemuneration updateMany
   */
  export type IndicatorRemunerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicatorRemunerations.
     */
    data: XOR<IndicatorRemunerationUpdateManyMutationInput, IndicatorRemunerationUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorRemunerations to update
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * Limit how many IndicatorRemunerations to update.
     */
    limit?: number
  }

  /**
   * IndicatorRemuneration updateManyAndReturn
   */
  export type IndicatorRemunerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * The data used to update IndicatorRemunerations.
     */
    data: XOR<IndicatorRemunerationUpdateManyMutationInput, IndicatorRemunerationUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorRemunerations to update
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * Limit how many IndicatorRemunerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorRemuneration upsert
   */
  export type IndicatorRemunerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicatorRemuneration to update in case it exists.
     */
    where: IndicatorRemunerationWhereUniqueInput
    /**
     * In case the IndicatorRemuneration found by the `where` argument doesn't exist, create a new IndicatorRemuneration with this data.
     */
    create: XOR<IndicatorRemunerationCreateInput, IndicatorRemunerationUncheckedCreateInput>
    /**
     * In case the IndicatorRemuneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorRemunerationUpdateInput, IndicatorRemunerationUncheckedUpdateInput>
  }

  /**
   * IndicatorRemuneration delete
   */
  export type IndicatorRemunerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
    /**
     * Filter which IndicatorRemuneration to delete.
     */
    where: IndicatorRemunerationWhereUniqueInput
  }

  /**
   * IndicatorRemuneration deleteMany
   */
  export type IndicatorRemunerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorRemunerations to delete
     */
    where?: IndicatorRemunerationWhereInput
    /**
     * Limit how many IndicatorRemunerations to delete.
     */
    limit?: number
  }

  /**
   * IndicatorRemuneration.remuneration_system
   */
  export type IndicatorRemuneration$remuneration_systemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemunerationSystem
     */
    select?: RemunerationSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemunerationSystem
     */
    omit?: RemunerationSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RemunerationSystemInclude<ExtArgs> | null
    where?: RemunerationSystemWhereInput
  }

  /**
   * IndicatorRemuneration without action
   */
  export type IndicatorRemunerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorRemuneration
     */
    select?: IndicatorRemunerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorRemuneration
     */
    omit?: IndicatorRemunerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorRemunerationInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceCalculation
   */

  export type AggregatePerformanceCalculation = {
    _count: PerformanceCalculationCountAggregateOutputType | null
    _avg: PerformanceCalculationAvgAggregateOutputType | null
    _sum: PerformanceCalculationSumAggregateOutputType | null
    _min: PerformanceCalculationMinAggregateOutputType | null
    _max: PerformanceCalculationMaxAggregateOutputType | null
  }

  export type PerformanceCalculationAvgAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    indicator_id: number | null
    numerator: Decimal | null
    denominator: Decimal | null
    achievement: Decimal | null
    target_value: Decimal | null
    remuneration_amount: Decimal | null
  }

  export type PerformanceCalculationSumAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    indicator_id: number | null
    numerator: Decimal | null
    denominator: Decimal | null
    achievement: Decimal | null
    target_value: Decimal | null
    remuneration_amount: Decimal | null
  }

  export type PerformanceCalculationMinAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    indicator_id: number | null
    report_month: string | null
    numerator: Decimal | null
    denominator: Decimal | null
    achievement: Decimal | null
    target_value: Decimal | null
    remuneration_amount: Decimal | null
    calculated_at: Date | null
    facility_id: string | null
  }

  export type PerformanceCalculationMaxAggregateOutputType = {
    id: number | null
    sub_centre_id: number | null
    indicator_id: number | null
    report_month: string | null
    numerator: Decimal | null
    denominator: Decimal | null
    achievement: Decimal | null
    target_value: Decimal | null
    remuneration_amount: Decimal | null
    calculated_at: Date | null
    facility_id: string | null
  }

  export type PerformanceCalculationCountAggregateOutputType = {
    id: number
    sub_centre_id: number
    indicator_id: number
    report_month: number
    numerator: number
    denominator: number
    achievement: number
    target_value: number
    remuneration_amount: number
    calculated_at: number
    facility_id: number
    _all: number
  }


  export type PerformanceCalculationAvgAggregateInputType = {
    id?: true
    sub_centre_id?: true
    indicator_id?: true
    numerator?: true
    denominator?: true
    achievement?: true
    target_value?: true
    remuneration_amount?: true
  }

  export type PerformanceCalculationSumAggregateInputType = {
    id?: true
    sub_centre_id?: true
    indicator_id?: true
    numerator?: true
    denominator?: true
    achievement?: true
    target_value?: true
    remuneration_amount?: true
  }

  export type PerformanceCalculationMinAggregateInputType = {
    id?: true
    sub_centre_id?: true
    indicator_id?: true
    report_month?: true
    numerator?: true
    denominator?: true
    achievement?: true
    target_value?: true
    remuneration_amount?: true
    calculated_at?: true
    facility_id?: true
  }

  export type PerformanceCalculationMaxAggregateInputType = {
    id?: true
    sub_centre_id?: true
    indicator_id?: true
    report_month?: true
    numerator?: true
    denominator?: true
    achievement?: true
    target_value?: true
    remuneration_amount?: true
    calculated_at?: true
    facility_id?: true
  }

  export type PerformanceCalculationCountAggregateInputType = {
    id?: true
    sub_centre_id?: true
    indicator_id?: true
    report_month?: true
    numerator?: true
    denominator?: true
    achievement?: true
    target_value?: true
    remuneration_amount?: true
    calculated_at?: true
    facility_id?: true
    _all?: true
  }

  export type PerformanceCalculationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceCalculation to aggregate.
     */
    where?: PerformanceCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCalculations to fetch.
     */
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceCalculations
    **/
    _count?: true | PerformanceCalculationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceCalculationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceCalculationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceCalculationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceCalculationMaxAggregateInputType
  }

  export type GetPerformanceCalculationAggregateType<T extends PerformanceCalculationAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceCalculation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceCalculation[P]>
      : GetScalarType<T[P], AggregatePerformanceCalculation[P]>
  }




  export type PerformanceCalculationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceCalculationWhereInput
    orderBy?: PerformanceCalculationOrderByWithAggregationInput | PerformanceCalculationOrderByWithAggregationInput[]
    by: PerformanceCalculationScalarFieldEnum[] | PerformanceCalculationScalarFieldEnum
    having?: PerformanceCalculationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceCalculationCountAggregateInputType | true
    _avg?: PerformanceCalculationAvgAggregateInputType
    _sum?: PerformanceCalculationSumAggregateInputType
    _min?: PerformanceCalculationMinAggregateInputType
    _max?: PerformanceCalculationMaxAggregateInputType
  }

  export type PerformanceCalculationGroupByOutputType = {
    id: number
    sub_centre_id: number | null
    indicator_id: number
    report_month: string
    numerator: Decimal | null
    denominator: Decimal | null
    achievement: Decimal | null
    target_value: Decimal | null
    remuneration_amount: Decimal | null
    calculated_at: Date
    facility_id: string | null
    _count: PerformanceCalculationCountAggregateOutputType | null
    _avg: PerformanceCalculationAvgAggregateOutputType | null
    _sum: PerformanceCalculationSumAggregateOutputType | null
    _min: PerformanceCalculationMinAggregateOutputType | null
    _max: PerformanceCalculationMaxAggregateOutputType | null
  }

  type GetPerformanceCalculationGroupByPayload<T extends PerformanceCalculationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceCalculationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceCalculationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceCalculationGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceCalculationGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceCalculationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_centre_id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    numerator?: boolean
    denominator?: boolean
    achievement?: boolean
    target_value?: boolean
    remuneration_amount?: boolean
    calculated_at?: boolean
    facility_id?: boolean
    facility?: boolean | PerformanceCalculation$facilityArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    sub_centre?: boolean | PerformanceCalculation$sub_centreArgs<ExtArgs>
  }, ExtArgs["result"]["performanceCalculation"]>

  export type PerformanceCalculationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_centre_id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    numerator?: boolean
    denominator?: boolean
    achievement?: boolean
    target_value?: boolean
    remuneration_amount?: boolean
    calculated_at?: boolean
    facility_id?: boolean
    facility?: boolean | PerformanceCalculation$facilityArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    sub_centre?: boolean | PerformanceCalculation$sub_centreArgs<ExtArgs>
  }, ExtArgs["result"]["performanceCalculation"]>

  export type PerformanceCalculationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_centre_id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    numerator?: boolean
    denominator?: boolean
    achievement?: boolean
    target_value?: boolean
    remuneration_amount?: boolean
    calculated_at?: boolean
    facility_id?: boolean
    facility?: boolean | PerformanceCalculation$facilityArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    sub_centre?: boolean | PerformanceCalculation$sub_centreArgs<ExtArgs>
  }, ExtArgs["result"]["performanceCalculation"]>

  export type PerformanceCalculationSelectScalar = {
    id?: boolean
    sub_centre_id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    numerator?: boolean
    denominator?: boolean
    achievement?: boolean
    target_value?: boolean
    remuneration_amount?: boolean
    calculated_at?: boolean
    facility_id?: boolean
  }

  export type PerformanceCalculationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sub_centre_id" | "indicator_id" | "report_month" | "numerator" | "denominator" | "achievement" | "target_value" | "remuneration_amount" | "calculated_at" | "facility_id", ExtArgs["result"]["performanceCalculation"]>
  export type PerformanceCalculationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | PerformanceCalculation$facilityArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    sub_centre?: boolean | PerformanceCalculation$sub_centreArgs<ExtArgs>
  }
  export type PerformanceCalculationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | PerformanceCalculation$facilityArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    sub_centre?: boolean | PerformanceCalculation$sub_centreArgs<ExtArgs>
  }
  export type PerformanceCalculationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | PerformanceCalculation$facilityArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
    sub_centre?: boolean | PerformanceCalculation$sub_centreArgs<ExtArgs>
  }

  export type $PerformanceCalculationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceCalculation"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      indicator: Prisma.$IndicatorPayload<ExtArgs>
      sub_centre: Prisma.$sub_centrePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sub_centre_id: number | null
      indicator_id: number
      report_month: string
      numerator: Prisma.Decimal | null
      denominator: Prisma.Decimal | null
      achievement: Prisma.Decimal | null
      target_value: Prisma.Decimal | null
      remuneration_amount: Prisma.Decimal | null
      calculated_at: Date
      facility_id: string | null
    }, ExtArgs["result"]["performanceCalculation"]>
    composites: {}
  }

  type PerformanceCalculationGetPayload<S extends boolean | null | undefined | PerformanceCalculationDefaultArgs> = $Result.GetResult<Prisma.$PerformanceCalculationPayload, S>

  type PerformanceCalculationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceCalculationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceCalculationCountAggregateInputType | true
    }

  export interface PerformanceCalculationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceCalculation'], meta: { name: 'PerformanceCalculation' } }
    /**
     * Find zero or one PerformanceCalculation that matches the filter.
     * @param {PerformanceCalculationFindUniqueArgs} args - Arguments to find a PerformanceCalculation
     * @example
     * // Get one PerformanceCalculation
     * const performanceCalculation = await prisma.performanceCalculation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceCalculationFindUniqueArgs>(args: SelectSubset<T, PerformanceCalculationFindUniqueArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceCalculation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceCalculationFindUniqueOrThrowArgs} args - Arguments to find a PerformanceCalculation
     * @example
     * // Get one PerformanceCalculation
     * const performanceCalculation = await prisma.performanceCalculation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceCalculationFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceCalculationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceCalculation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationFindFirstArgs} args - Arguments to find a PerformanceCalculation
     * @example
     * // Get one PerformanceCalculation
     * const performanceCalculation = await prisma.performanceCalculation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceCalculationFindFirstArgs>(args?: SelectSubset<T, PerformanceCalculationFindFirstArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceCalculation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationFindFirstOrThrowArgs} args - Arguments to find a PerformanceCalculation
     * @example
     * // Get one PerformanceCalculation
     * const performanceCalculation = await prisma.performanceCalculation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceCalculationFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceCalculationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceCalculations
     * const performanceCalculations = await prisma.performanceCalculation.findMany()
     * 
     * // Get first 10 PerformanceCalculations
     * const performanceCalculations = await prisma.performanceCalculation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceCalculationWithIdOnly = await prisma.performanceCalculation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceCalculationFindManyArgs>(args?: SelectSubset<T, PerformanceCalculationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceCalculation.
     * @param {PerformanceCalculationCreateArgs} args - Arguments to create a PerformanceCalculation.
     * @example
     * // Create one PerformanceCalculation
     * const PerformanceCalculation = await prisma.performanceCalculation.create({
     *   data: {
     *     // ... data to create a PerformanceCalculation
     *   }
     * })
     * 
     */
    create<T extends PerformanceCalculationCreateArgs>(args: SelectSubset<T, PerformanceCalculationCreateArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceCalculations.
     * @param {PerformanceCalculationCreateManyArgs} args - Arguments to create many PerformanceCalculations.
     * @example
     * // Create many PerformanceCalculations
     * const performanceCalculation = await prisma.performanceCalculation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceCalculationCreateManyArgs>(args?: SelectSubset<T, PerformanceCalculationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceCalculations and returns the data saved in the database.
     * @param {PerformanceCalculationCreateManyAndReturnArgs} args - Arguments to create many PerformanceCalculations.
     * @example
     * // Create many PerformanceCalculations
     * const performanceCalculation = await prisma.performanceCalculation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceCalculations and only return the `id`
     * const performanceCalculationWithIdOnly = await prisma.performanceCalculation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceCalculationCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceCalculationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceCalculation.
     * @param {PerformanceCalculationDeleteArgs} args - Arguments to delete one PerformanceCalculation.
     * @example
     * // Delete one PerformanceCalculation
     * const PerformanceCalculation = await prisma.performanceCalculation.delete({
     *   where: {
     *     // ... filter to delete one PerformanceCalculation
     *   }
     * })
     * 
     */
    delete<T extends PerformanceCalculationDeleteArgs>(args: SelectSubset<T, PerformanceCalculationDeleteArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceCalculation.
     * @param {PerformanceCalculationUpdateArgs} args - Arguments to update one PerformanceCalculation.
     * @example
     * // Update one PerformanceCalculation
     * const performanceCalculation = await prisma.performanceCalculation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceCalculationUpdateArgs>(args: SelectSubset<T, PerformanceCalculationUpdateArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceCalculations.
     * @param {PerformanceCalculationDeleteManyArgs} args - Arguments to filter PerformanceCalculations to delete.
     * @example
     * // Delete a few PerformanceCalculations
     * const { count } = await prisma.performanceCalculation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceCalculationDeleteManyArgs>(args?: SelectSubset<T, PerformanceCalculationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceCalculations
     * const performanceCalculation = await prisma.performanceCalculation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceCalculationUpdateManyArgs>(args: SelectSubset<T, PerformanceCalculationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceCalculations and returns the data updated in the database.
     * @param {PerformanceCalculationUpdateManyAndReturnArgs} args - Arguments to update many PerformanceCalculations.
     * @example
     * // Update many PerformanceCalculations
     * const performanceCalculation = await prisma.performanceCalculation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceCalculations and only return the `id`
     * const performanceCalculationWithIdOnly = await prisma.performanceCalculation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceCalculationUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceCalculationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceCalculation.
     * @param {PerformanceCalculationUpsertArgs} args - Arguments to update or create a PerformanceCalculation.
     * @example
     * // Update or create a PerformanceCalculation
     * const performanceCalculation = await prisma.performanceCalculation.upsert({
     *   create: {
     *     // ... data to create a PerformanceCalculation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceCalculation we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceCalculationUpsertArgs>(args: SelectSubset<T, PerformanceCalculationUpsertArgs<ExtArgs>>): Prisma__PerformanceCalculationClient<$Result.GetResult<Prisma.$PerformanceCalculationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationCountArgs} args - Arguments to filter PerformanceCalculations to count.
     * @example
     * // Count the number of PerformanceCalculations
     * const count = await prisma.performanceCalculation.count({
     *   where: {
     *     // ... the filter for the PerformanceCalculations we want to count
     *   }
     * })
    **/
    count<T extends PerformanceCalculationCountArgs>(
      args?: Subset<T, PerformanceCalculationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceCalculationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceCalculationAggregateArgs>(args: Subset<T, PerformanceCalculationAggregateArgs>): Prisma.PrismaPromise<GetPerformanceCalculationAggregateType<T>>

    /**
     * Group by PerformanceCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceCalculationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceCalculationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceCalculationGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceCalculationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceCalculationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceCalculationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceCalculation model
   */
  readonly fields: PerformanceCalculationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceCalculation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceCalculationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends PerformanceCalculation$facilityArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceCalculation$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sub_centre<T extends PerformanceCalculation$sub_centreArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceCalculation$sub_centreArgs<ExtArgs>>): Prisma__sub_centreClient<$Result.GetResult<Prisma.$sub_centrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceCalculation model
   */
  interface PerformanceCalculationFieldRefs {
    readonly id: FieldRef<"PerformanceCalculation", 'Int'>
    readonly sub_centre_id: FieldRef<"PerformanceCalculation", 'Int'>
    readonly indicator_id: FieldRef<"PerformanceCalculation", 'Int'>
    readonly report_month: FieldRef<"PerformanceCalculation", 'String'>
    readonly numerator: FieldRef<"PerformanceCalculation", 'Decimal'>
    readonly denominator: FieldRef<"PerformanceCalculation", 'Decimal'>
    readonly achievement: FieldRef<"PerformanceCalculation", 'Decimal'>
    readonly target_value: FieldRef<"PerformanceCalculation", 'Decimal'>
    readonly remuneration_amount: FieldRef<"PerformanceCalculation", 'Decimal'>
    readonly calculated_at: FieldRef<"PerformanceCalculation", 'DateTime'>
    readonly facility_id: FieldRef<"PerformanceCalculation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceCalculation findUnique
   */
  export type PerformanceCalculationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCalculation to fetch.
     */
    where: PerformanceCalculationWhereUniqueInput
  }

  /**
   * PerformanceCalculation findUniqueOrThrow
   */
  export type PerformanceCalculationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCalculation to fetch.
     */
    where: PerformanceCalculationWhereUniqueInput
  }

  /**
   * PerformanceCalculation findFirst
   */
  export type PerformanceCalculationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCalculation to fetch.
     */
    where?: PerformanceCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCalculations to fetch.
     */
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceCalculations.
     */
    cursor?: PerformanceCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceCalculations.
     */
    distinct?: PerformanceCalculationScalarFieldEnum | PerformanceCalculationScalarFieldEnum[]
  }

  /**
   * PerformanceCalculation findFirstOrThrow
   */
  export type PerformanceCalculationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCalculation to fetch.
     */
    where?: PerformanceCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCalculations to fetch.
     */
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceCalculations.
     */
    cursor?: PerformanceCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceCalculations.
     */
    distinct?: PerformanceCalculationScalarFieldEnum | PerformanceCalculationScalarFieldEnum[]
  }

  /**
   * PerformanceCalculation findMany
   */
  export type PerformanceCalculationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceCalculations to fetch.
     */
    where?: PerformanceCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceCalculations to fetch.
     */
    orderBy?: PerformanceCalculationOrderByWithRelationInput | PerformanceCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceCalculations.
     */
    cursor?: PerformanceCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceCalculations.
     */
    skip?: number
    distinct?: PerformanceCalculationScalarFieldEnum | PerformanceCalculationScalarFieldEnum[]
  }

  /**
   * PerformanceCalculation create
   */
  export type PerformanceCalculationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceCalculation.
     */
    data: XOR<PerformanceCalculationCreateInput, PerformanceCalculationUncheckedCreateInput>
  }

  /**
   * PerformanceCalculation createMany
   */
  export type PerformanceCalculationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceCalculations.
     */
    data: PerformanceCalculationCreateManyInput | PerformanceCalculationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceCalculation createManyAndReturn
   */
  export type PerformanceCalculationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceCalculations.
     */
    data: PerformanceCalculationCreateManyInput | PerformanceCalculationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceCalculation update
   */
  export type PerformanceCalculationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceCalculation.
     */
    data: XOR<PerformanceCalculationUpdateInput, PerformanceCalculationUncheckedUpdateInput>
    /**
     * Choose, which PerformanceCalculation to update.
     */
    where: PerformanceCalculationWhereUniqueInput
  }

  /**
   * PerformanceCalculation updateMany
   */
  export type PerformanceCalculationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceCalculations.
     */
    data: XOR<PerformanceCalculationUpdateManyMutationInput, PerformanceCalculationUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceCalculations to update
     */
    where?: PerformanceCalculationWhereInput
    /**
     * Limit how many PerformanceCalculations to update.
     */
    limit?: number
  }

  /**
   * PerformanceCalculation updateManyAndReturn
   */
  export type PerformanceCalculationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceCalculations.
     */
    data: XOR<PerformanceCalculationUpdateManyMutationInput, PerformanceCalculationUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceCalculations to update
     */
    where?: PerformanceCalculationWhereInput
    /**
     * Limit how many PerformanceCalculations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceCalculation upsert
   */
  export type PerformanceCalculationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceCalculation to update in case it exists.
     */
    where: PerformanceCalculationWhereUniqueInput
    /**
     * In case the PerformanceCalculation found by the `where` argument doesn't exist, create a new PerformanceCalculation with this data.
     */
    create: XOR<PerformanceCalculationCreateInput, PerformanceCalculationUncheckedCreateInput>
    /**
     * In case the PerformanceCalculation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceCalculationUpdateInput, PerformanceCalculationUncheckedUpdateInput>
  }

  /**
   * PerformanceCalculation delete
   */
  export type PerformanceCalculationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
    /**
     * Filter which PerformanceCalculation to delete.
     */
    where: PerformanceCalculationWhereUniqueInput
  }

  /**
   * PerformanceCalculation deleteMany
   */
  export type PerformanceCalculationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceCalculations to delete
     */
    where?: PerformanceCalculationWhereInput
    /**
     * Limit how many PerformanceCalculations to delete.
     */
    limit?: number
  }

  /**
   * PerformanceCalculation.facility
   */
  export type PerformanceCalculation$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * PerformanceCalculation.sub_centre
   */
  export type PerformanceCalculation$sub_centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sub_centre
     */
    select?: sub_centreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sub_centre
     */
    omit?: sub_centreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sub_centreInclude<ExtArgs> | null
    where?: sub_centreWhereInput
  }

  /**
   * PerformanceCalculation without action
   */
  export type PerformanceCalculationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceCalculation
     */
    select?: PerformanceCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceCalculation
     */
    omit?: PerformanceCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceCalculationInclude<ExtArgs> | null
  }


  /**
   * Model FacilityTarget
   */

  export type AggregateFacilityTarget = {
    _count: FacilityTargetCountAggregateOutputType | null
    _avg: FacilityTargetAvgAggregateOutputType | null
    _sum: FacilityTargetSumAggregateOutputType | null
    _min: FacilityTargetMinAggregateOutputType | null
    _max: FacilityTargetMaxAggregateOutputType | null
  }

  export type FacilityTargetAvgAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    target_value: Decimal | null
  }

  export type FacilityTargetSumAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    target_value: Decimal | null
  }

  export type FacilityTargetMinAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    report_month: string | null
    target_value: Decimal | null
    numerator_label: string | null
    denominator_label: string | null
    created_at: Date | null
    updated_at: Date | null
    facility_id: string | null
  }

  export type FacilityTargetMaxAggregateOutputType = {
    id: number | null
    indicator_id: number | null
    report_month: string | null
    target_value: Decimal | null
    numerator_label: string | null
    denominator_label: string | null
    created_at: Date | null
    updated_at: Date | null
    facility_id: string | null
  }

  export type FacilityTargetCountAggregateOutputType = {
    id: number
    indicator_id: number
    report_month: number
    target_value: number
    numerator_label: number
    denominator_label: number
    created_at: number
    updated_at: number
    facility_id: number
    _all: number
  }


  export type FacilityTargetAvgAggregateInputType = {
    id?: true
    indicator_id?: true
    target_value?: true
  }

  export type FacilityTargetSumAggregateInputType = {
    id?: true
    indicator_id?: true
    target_value?: true
  }

  export type FacilityTargetMinAggregateInputType = {
    id?: true
    indicator_id?: true
    report_month?: true
    target_value?: true
    numerator_label?: true
    denominator_label?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
  }

  export type FacilityTargetMaxAggregateInputType = {
    id?: true
    indicator_id?: true
    report_month?: true
    target_value?: true
    numerator_label?: true
    denominator_label?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
  }

  export type FacilityTargetCountAggregateInputType = {
    id?: true
    indicator_id?: true
    report_month?: true
    target_value?: true
    numerator_label?: true
    denominator_label?: true
    created_at?: true
    updated_at?: true
    facility_id?: true
    _all?: true
  }

  export type FacilityTargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityTarget to aggregate.
     */
    where?: FacilityTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTargets to fetch.
     */
    orderBy?: FacilityTargetOrderByWithRelationInput | FacilityTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityTargets
    **/
    _count?: true | FacilityTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityTargetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilityTargetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityTargetMaxAggregateInputType
  }

  export type GetFacilityTargetAggregateType<T extends FacilityTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityTarget[P]>
      : GetScalarType<T[P], AggregateFacilityTarget[P]>
  }




  export type FacilityTargetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityTargetWhereInput
    orderBy?: FacilityTargetOrderByWithAggregationInput | FacilityTargetOrderByWithAggregationInput[]
    by: FacilityTargetScalarFieldEnum[] | FacilityTargetScalarFieldEnum
    having?: FacilityTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityTargetCountAggregateInputType | true
    _avg?: FacilityTargetAvgAggregateInputType
    _sum?: FacilityTargetSumAggregateInputType
    _min?: FacilityTargetMinAggregateInputType
    _max?: FacilityTargetMaxAggregateInputType
  }

  export type FacilityTargetGroupByOutputType = {
    id: number
    indicator_id: number
    report_month: string
    target_value: Decimal
    numerator_label: string
    denominator_label: string
    created_at: Date
    updated_at: Date
    facility_id: string
    _count: FacilityTargetCountAggregateOutputType | null
    _avg: FacilityTargetAvgAggregateOutputType | null
    _sum: FacilityTargetSumAggregateOutputType | null
    _min: FacilityTargetMinAggregateOutputType | null
    _max: FacilityTargetMaxAggregateOutputType | null
  }

  type GetFacilityTargetGroupByPayload<T extends FacilityTargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityTargetGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityTargetGroupByOutputType[P]>
        }
      >
    >


  export type FacilityTargetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    target_value?: boolean
    numerator_label?: boolean
    denominator_label?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityTarget"]>

  export type FacilityTargetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    target_value?: boolean
    numerator_label?: boolean
    denominator_label?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityTarget"]>

  export type FacilityTargetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    target_value?: boolean
    numerator_label?: boolean
    denominator_label?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityTarget"]>

  export type FacilityTargetSelectScalar = {
    id?: boolean
    indicator_id?: boolean
    report_month?: boolean
    target_value?: boolean
    numerator_label?: boolean
    denominator_label?: boolean
    created_at?: boolean
    updated_at?: boolean
    facility_id?: boolean
  }

  export type FacilityTargetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicator_id" | "report_month" | "target_value" | "numerator_label" | "denominator_label" | "created_at" | "updated_at" | "facility_id", ExtArgs["result"]["facilityTarget"]>
  export type FacilityTargetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type FacilityTargetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type FacilityTargetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }

  export type $FacilityTargetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityTarget"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      indicator: Prisma.$IndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicator_id: number
      report_month: string
      target_value: Prisma.Decimal
      numerator_label: string
      denominator_label: string
      created_at: Date
      updated_at: Date
      facility_id: string
    }, ExtArgs["result"]["facilityTarget"]>
    composites: {}
  }

  type FacilityTargetGetPayload<S extends boolean | null | undefined | FacilityTargetDefaultArgs> = $Result.GetResult<Prisma.$FacilityTargetPayload, S>

  type FacilityTargetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityTargetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityTargetCountAggregateInputType | true
    }

  export interface FacilityTargetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityTarget'], meta: { name: 'FacilityTarget' } }
    /**
     * Find zero or one FacilityTarget that matches the filter.
     * @param {FacilityTargetFindUniqueArgs} args - Arguments to find a FacilityTarget
     * @example
     * // Get one FacilityTarget
     * const facilityTarget = await prisma.facilityTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityTargetFindUniqueArgs>(args: SelectSubset<T, FacilityTargetFindUniqueArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FacilityTarget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityTargetFindUniqueOrThrowArgs} args - Arguments to find a FacilityTarget
     * @example
     * // Get one FacilityTarget
     * const facilityTarget = await prisma.facilityTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityTargetFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityTargetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetFindFirstArgs} args - Arguments to find a FacilityTarget
     * @example
     * // Get one FacilityTarget
     * const facilityTarget = await prisma.facilityTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityTargetFindFirstArgs>(args?: SelectSubset<T, FacilityTargetFindFirstArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FacilityTarget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetFindFirstOrThrowArgs} args - Arguments to find a FacilityTarget
     * @example
     * // Get one FacilityTarget
     * const facilityTarget = await prisma.facilityTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityTargetFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityTargetFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FacilityTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityTargets
     * const facilityTargets = await prisma.facilityTarget.findMany()
     * 
     * // Get first 10 FacilityTargets
     * const facilityTargets = await prisma.facilityTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityTargetWithIdOnly = await prisma.facilityTarget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityTargetFindManyArgs>(args?: SelectSubset<T, FacilityTargetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FacilityTarget.
     * @param {FacilityTargetCreateArgs} args - Arguments to create a FacilityTarget.
     * @example
     * // Create one FacilityTarget
     * const FacilityTarget = await prisma.facilityTarget.create({
     *   data: {
     *     // ... data to create a FacilityTarget
     *   }
     * })
     * 
     */
    create<T extends FacilityTargetCreateArgs>(args: SelectSubset<T, FacilityTargetCreateArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FacilityTargets.
     * @param {FacilityTargetCreateManyArgs} args - Arguments to create many FacilityTargets.
     * @example
     * // Create many FacilityTargets
     * const facilityTarget = await prisma.facilityTarget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityTargetCreateManyArgs>(args?: SelectSubset<T, FacilityTargetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityTargets and returns the data saved in the database.
     * @param {FacilityTargetCreateManyAndReturnArgs} args - Arguments to create many FacilityTargets.
     * @example
     * // Create many FacilityTargets
     * const facilityTarget = await prisma.facilityTarget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityTargets and only return the `id`
     * const facilityTargetWithIdOnly = await prisma.facilityTarget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityTargetCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityTargetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FacilityTarget.
     * @param {FacilityTargetDeleteArgs} args - Arguments to delete one FacilityTarget.
     * @example
     * // Delete one FacilityTarget
     * const FacilityTarget = await prisma.facilityTarget.delete({
     *   where: {
     *     // ... filter to delete one FacilityTarget
     *   }
     * })
     * 
     */
    delete<T extends FacilityTargetDeleteArgs>(args: SelectSubset<T, FacilityTargetDeleteArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FacilityTarget.
     * @param {FacilityTargetUpdateArgs} args - Arguments to update one FacilityTarget.
     * @example
     * // Update one FacilityTarget
     * const facilityTarget = await prisma.facilityTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityTargetUpdateArgs>(args: SelectSubset<T, FacilityTargetUpdateArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FacilityTargets.
     * @param {FacilityTargetDeleteManyArgs} args - Arguments to filter FacilityTargets to delete.
     * @example
     * // Delete a few FacilityTargets
     * const { count } = await prisma.facilityTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityTargetDeleteManyArgs>(args?: SelectSubset<T, FacilityTargetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityTargets
     * const facilityTarget = await prisma.facilityTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityTargetUpdateManyArgs>(args: SelectSubset<T, FacilityTargetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityTargets and returns the data updated in the database.
     * @param {FacilityTargetUpdateManyAndReturnArgs} args - Arguments to update many FacilityTargets.
     * @example
     * // Update many FacilityTargets
     * const facilityTarget = await prisma.facilityTarget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FacilityTargets and only return the `id`
     * const facilityTargetWithIdOnly = await prisma.facilityTarget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityTargetUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityTargetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FacilityTarget.
     * @param {FacilityTargetUpsertArgs} args - Arguments to update or create a FacilityTarget.
     * @example
     * // Update or create a FacilityTarget
     * const facilityTarget = await prisma.facilityTarget.upsert({
     *   create: {
     *     // ... data to create a FacilityTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityTarget we want to update
     *   }
     * })
     */
    upsert<T extends FacilityTargetUpsertArgs>(args: SelectSubset<T, FacilityTargetUpsertArgs<ExtArgs>>): Prisma__FacilityTargetClient<$Result.GetResult<Prisma.$FacilityTargetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FacilityTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetCountArgs} args - Arguments to filter FacilityTargets to count.
     * @example
     * // Count the number of FacilityTargets
     * const count = await prisma.facilityTarget.count({
     *   where: {
     *     // ... the filter for the FacilityTargets we want to count
     *   }
     * })
    **/
    count<T extends FacilityTargetCountArgs>(
      args?: Subset<T, FacilityTargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityTargetAggregateArgs>(args: Subset<T, FacilityTargetAggregateArgs>): Prisma.PrismaPromise<GetFacilityTargetAggregateType<T>>

    /**
     * Group by FacilityTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityTargetGroupByArgs['orderBy'] }
        : { orderBy?: FacilityTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityTarget model
   */
  readonly fields: FacilityTargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityTargetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityTarget model
   */
  interface FacilityTargetFieldRefs {
    readonly id: FieldRef<"FacilityTarget", 'Int'>
    readonly indicator_id: FieldRef<"FacilityTarget", 'Int'>
    readonly report_month: FieldRef<"FacilityTarget", 'String'>
    readonly target_value: FieldRef<"FacilityTarget", 'Decimal'>
    readonly numerator_label: FieldRef<"FacilityTarget", 'String'>
    readonly denominator_label: FieldRef<"FacilityTarget", 'String'>
    readonly created_at: FieldRef<"FacilityTarget", 'DateTime'>
    readonly updated_at: FieldRef<"FacilityTarget", 'DateTime'>
    readonly facility_id: FieldRef<"FacilityTarget", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FacilityTarget findUnique
   */
  export type FacilityTargetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTarget to fetch.
     */
    where: FacilityTargetWhereUniqueInput
  }

  /**
   * FacilityTarget findUniqueOrThrow
   */
  export type FacilityTargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTarget to fetch.
     */
    where: FacilityTargetWhereUniqueInput
  }

  /**
   * FacilityTarget findFirst
   */
  export type FacilityTargetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTarget to fetch.
     */
    where?: FacilityTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTargets to fetch.
     */
    orderBy?: FacilityTargetOrderByWithRelationInput | FacilityTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityTargets.
     */
    cursor?: FacilityTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityTargets.
     */
    distinct?: FacilityTargetScalarFieldEnum | FacilityTargetScalarFieldEnum[]
  }

  /**
   * FacilityTarget findFirstOrThrow
   */
  export type FacilityTargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTarget to fetch.
     */
    where?: FacilityTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTargets to fetch.
     */
    orderBy?: FacilityTargetOrderByWithRelationInput | FacilityTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityTargets.
     */
    cursor?: FacilityTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityTargets.
     */
    distinct?: FacilityTargetScalarFieldEnum | FacilityTargetScalarFieldEnum[]
  }

  /**
   * FacilityTarget findMany
   */
  export type FacilityTargetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * Filter, which FacilityTargets to fetch.
     */
    where?: FacilityTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityTargets to fetch.
     */
    orderBy?: FacilityTargetOrderByWithRelationInput | FacilityTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityTargets.
     */
    cursor?: FacilityTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityTargets.
     */
    skip?: number
    distinct?: FacilityTargetScalarFieldEnum | FacilityTargetScalarFieldEnum[]
  }

  /**
   * FacilityTarget create
   */
  export type FacilityTargetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityTarget.
     */
    data: XOR<FacilityTargetCreateInput, FacilityTargetUncheckedCreateInput>
  }

  /**
   * FacilityTarget createMany
   */
  export type FacilityTargetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityTargets.
     */
    data: FacilityTargetCreateManyInput | FacilityTargetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityTarget createManyAndReturn
   */
  export type FacilityTargetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * The data used to create many FacilityTargets.
     */
    data: FacilityTargetCreateManyInput | FacilityTargetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityTarget update
   */
  export type FacilityTargetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityTarget.
     */
    data: XOR<FacilityTargetUpdateInput, FacilityTargetUncheckedUpdateInput>
    /**
     * Choose, which FacilityTarget to update.
     */
    where: FacilityTargetWhereUniqueInput
  }

  /**
   * FacilityTarget updateMany
   */
  export type FacilityTargetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityTargets.
     */
    data: XOR<FacilityTargetUpdateManyMutationInput, FacilityTargetUncheckedUpdateManyInput>
    /**
     * Filter which FacilityTargets to update
     */
    where?: FacilityTargetWhereInput
    /**
     * Limit how many FacilityTargets to update.
     */
    limit?: number
  }

  /**
   * FacilityTarget updateManyAndReturn
   */
  export type FacilityTargetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * The data used to update FacilityTargets.
     */
    data: XOR<FacilityTargetUpdateManyMutationInput, FacilityTargetUncheckedUpdateManyInput>
    /**
     * Filter which FacilityTargets to update
     */
    where?: FacilityTargetWhereInput
    /**
     * Limit how many FacilityTargets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FacilityTarget upsert
   */
  export type FacilityTargetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityTarget to update in case it exists.
     */
    where: FacilityTargetWhereUniqueInput
    /**
     * In case the FacilityTarget found by the `where` argument doesn't exist, create a new FacilityTarget with this data.
     */
    create: XOR<FacilityTargetCreateInput, FacilityTargetUncheckedCreateInput>
    /**
     * In case the FacilityTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityTargetUpdateInput, FacilityTargetUncheckedUpdateInput>
  }

  /**
   * FacilityTarget delete
   */
  export type FacilityTargetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
    /**
     * Filter which FacilityTarget to delete.
     */
    where: FacilityTargetWhereUniqueInput
  }

  /**
   * FacilityTarget deleteMany
   */
  export type FacilityTargetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityTargets to delete
     */
    where?: FacilityTargetWhereInput
    /**
     * Limit how many FacilityTargets to delete.
     */
    limit?: number
  }

  /**
   * FacilityTarget without action
   */
  export type FacilityTargetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityTarget
     */
    select?: FacilityTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FacilityTarget
     */
    omit?: FacilityTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityTargetInclude<ExtArgs> | null
  }


  /**
   * Model IndicatorWorkerAllocation
   */

  export type AggregateIndicatorWorkerAllocation = {
    _count: IndicatorWorkerAllocationCountAggregateOutputType | null
    _avg: IndicatorWorkerAllocationAvgAggregateOutputType | null
    _sum: IndicatorWorkerAllocationSumAggregateOutputType | null
    _min: IndicatorWorkerAllocationMinAggregateOutputType | null
    _max: IndicatorWorkerAllocationMaxAggregateOutputType | null
  }

  export type IndicatorWorkerAllocationAvgAggregateOutputType = {
    indicator_id: number | null
    allocated_amount: number | null
  }

  export type IndicatorWorkerAllocationSumAggregateOutputType = {
    indicator_id: number | null
    allocated_amount: number | null
  }

  export type IndicatorWorkerAllocationMinAggregateOutputType = {
    id: string | null
    indicator_id: number | null
    worker_type: string | null
    allocated_amount: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type IndicatorWorkerAllocationMaxAggregateOutputType = {
    id: string | null
    indicator_id: number | null
    worker_type: string | null
    allocated_amount: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type IndicatorWorkerAllocationCountAggregateOutputType = {
    id: number
    indicator_id: number
    worker_type: number
    allocated_amount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type IndicatorWorkerAllocationAvgAggregateInputType = {
    indicator_id?: true
    allocated_amount?: true
  }

  export type IndicatorWorkerAllocationSumAggregateInputType = {
    indicator_id?: true
    allocated_amount?: true
  }

  export type IndicatorWorkerAllocationMinAggregateInputType = {
    id?: true
    indicator_id?: true
    worker_type?: true
    allocated_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type IndicatorWorkerAllocationMaxAggregateInputType = {
    id?: true
    indicator_id?: true
    worker_type?: true
    allocated_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type IndicatorWorkerAllocationCountAggregateInputType = {
    id?: true
    indicator_id?: true
    worker_type?: true
    allocated_amount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type IndicatorWorkerAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorWorkerAllocation to aggregate.
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorWorkerAllocations to fetch.
     */
    orderBy?: IndicatorWorkerAllocationOrderByWithRelationInput | IndicatorWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicatorWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorWorkerAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicatorWorkerAllocations
    **/
    _count?: true | IndicatorWorkerAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicatorWorkerAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicatorWorkerAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicatorWorkerAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicatorWorkerAllocationMaxAggregateInputType
  }

  export type GetIndicatorWorkerAllocationAggregateType<T extends IndicatorWorkerAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicatorWorkerAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicatorWorkerAllocation[P]>
      : GetScalarType<T[P], AggregateIndicatorWorkerAllocation[P]>
  }




  export type IndicatorWorkerAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicatorWorkerAllocationWhereInput
    orderBy?: IndicatorWorkerAllocationOrderByWithAggregationInput | IndicatorWorkerAllocationOrderByWithAggregationInput[]
    by: IndicatorWorkerAllocationScalarFieldEnum[] | IndicatorWorkerAllocationScalarFieldEnum
    having?: IndicatorWorkerAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicatorWorkerAllocationCountAggregateInputType | true
    _avg?: IndicatorWorkerAllocationAvgAggregateInputType
    _sum?: IndicatorWorkerAllocationSumAggregateInputType
    _min?: IndicatorWorkerAllocationMinAggregateInputType
    _max?: IndicatorWorkerAllocationMaxAggregateInputType
  }

  export type IndicatorWorkerAllocationGroupByOutputType = {
    id: string
    indicator_id: number
    worker_type: string
    allocated_amount: number
    created_at: Date
    updated_at: Date
    _count: IndicatorWorkerAllocationCountAggregateOutputType | null
    _avg: IndicatorWorkerAllocationAvgAggregateOutputType | null
    _sum: IndicatorWorkerAllocationSumAggregateOutputType | null
    _min: IndicatorWorkerAllocationMinAggregateOutputType | null
    _max: IndicatorWorkerAllocationMaxAggregateOutputType | null
  }

  type GetIndicatorWorkerAllocationGroupByPayload<T extends IndicatorWorkerAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicatorWorkerAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicatorWorkerAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicatorWorkerAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], IndicatorWorkerAllocationGroupByOutputType[P]>
        }
      >
    >


  export type IndicatorWorkerAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorWorkerAllocation"]>

  export type IndicatorWorkerAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorWorkerAllocation"]>

  export type IndicatorWorkerAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicator_id?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicatorWorkerAllocation"]>

  export type IndicatorWorkerAllocationSelectScalar = {
    id?: boolean
    indicator_id?: boolean
    worker_type?: boolean
    allocated_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type IndicatorWorkerAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "indicator_id" | "worker_type" | "allocated_amount" | "created_at" | "updated_at", ExtArgs["result"]["indicatorWorkerAllocation"]>
  export type IndicatorWorkerAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type IndicatorWorkerAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }
  export type IndicatorWorkerAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | IndicatorDefaultArgs<ExtArgs>
  }

  export type $IndicatorWorkerAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicatorWorkerAllocation"
    objects: {
      indicator: Prisma.$IndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      indicator_id: number
      worker_type: string
      allocated_amount: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["indicatorWorkerAllocation"]>
    composites: {}
  }

  type IndicatorWorkerAllocationGetPayload<S extends boolean | null | undefined | IndicatorWorkerAllocationDefaultArgs> = $Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload, S>

  type IndicatorWorkerAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndicatorWorkerAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicatorWorkerAllocationCountAggregateInputType | true
    }

  export interface IndicatorWorkerAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicatorWorkerAllocation'], meta: { name: 'IndicatorWorkerAllocation' } }
    /**
     * Find zero or one IndicatorWorkerAllocation that matches the filter.
     * @param {IndicatorWorkerAllocationFindUniqueArgs} args - Arguments to find a IndicatorWorkerAllocation
     * @example
     * // Get one IndicatorWorkerAllocation
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicatorWorkerAllocationFindUniqueArgs>(args: SelectSubset<T, IndicatorWorkerAllocationFindUniqueArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IndicatorWorkerAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndicatorWorkerAllocationFindUniqueOrThrowArgs} args - Arguments to find a IndicatorWorkerAllocation
     * @example
     * // Get one IndicatorWorkerAllocation
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicatorWorkerAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicatorWorkerAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndicatorWorkerAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationFindFirstArgs} args - Arguments to find a IndicatorWorkerAllocation
     * @example
     * // Get one IndicatorWorkerAllocation
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicatorWorkerAllocationFindFirstArgs>(args?: SelectSubset<T, IndicatorWorkerAllocationFindFirstArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IndicatorWorkerAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationFindFirstOrThrowArgs} args - Arguments to find a IndicatorWorkerAllocation
     * @example
     * // Get one IndicatorWorkerAllocation
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicatorWorkerAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicatorWorkerAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IndicatorWorkerAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicatorWorkerAllocations
     * const indicatorWorkerAllocations = await prisma.indicatorWorkerAllocation.findMany()
     * 
     * // Get first 10 IndicatorWorkerAllocations
     * const indicatorWorkerAllocations = await prisma.indicatorWorkerAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicatorWorkerAllocationWithIdOnly = await prisma.indicatorWorkerAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicatorWorkerAllocationFindManyArgs>(args?: SelectSubset<T, IndicatorWorkerAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IndicatorWorkerAllocation.
     * @param {IndicatorWorkerAllocationCreateArgs} args - Arguments to create a IndicatorWorkerAllocation.
     * @example
     * // Create one IndicatorWorkerAllocation
     * const IndicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.create({
     *   data: {
     *     // ... data to create a IndicatorWorkerAllocation
     *   }
     * })
     * 
     */
    create<T extends IndicatorWorkerAllocationCreateArgs>(args: SelectSubset<T, IndicatorWorkerAllocationCreateArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IndicatorWorkerAllocations.
     * @param {IndicatorWorkerAllocationCreateManyArgs} args - Arguments to create many IndicatorWorkerAllocations.
     * @example
     * // Create many IndicatorWorkerAllocations
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicatorWorkerAllocationCreateManyArgs>(args?: SelectSubset<T, IndicatorWorkerAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicatorWorkerAllocations and returns the data saved in the database.
     * @param {IndicatorWorkerAllocationCreateManyAndReturnArgs} args - Arguments to create many IndicatorWorkerAllocations.
     * @example
     * // Create many IndicatorWorkerAllocations
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicatorWorkerAllocations and only return the `id`
     * const indicatorWorkerAllocationWithIdOnly = await prisma.indicatorWorkerAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicatorWorkerAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicatorWorkerAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IndicatorWorkerAllocation.
     * @param {IndicatorWorkerAllocationDeleteArgs} args - Arguments to delete one IndicatorWorkerAllocation.
     * @example
     * // Delete one IndicatorWorkerAllocation
     * const IndicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.delete({
     *   where: {
     *     // ... filter to delete one IndicatorWorkerAllocation
     *   }
     * })
     * 
     */
    delete<T extends IndicatorWorkerAllocationDeleteArgs>(args: SelectSubset<T, IndicatorWorkerAllocationDeleteArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IndicatorWorkerAllocation.
     * @param {IndicatorWorkerAllocationUpdateArgs} args - Arguments to update one IndicatorWorkerAllocation.
     * @example
     * // Update one IndicatorWorkerAllocation
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicatorWorkerAllocationUpdateArgs>(args: SelectSubset<T, IndicatorWorkerAllocationUpdateArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IndicatorWorkerAllocations.
     * @param {IndicatorWorkerAllocationDeleteManyArgs} args - Arguments to filter IndicatorWorkerAllocations to delete.
     * @example
     * // Delete a few IndicatorWorkerAllocations
     * const { count } = await prisma.indicatorWorkerAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicatorWorkerAllocationDeleteManyArgs>(args?: SelectSubset<T, IndicatorWorkerAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorWorkerAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicatorWorkerAllocations
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicatorWorkerAllocationUpdateManyArgs>(args: SelectSubset<T, IndicatorWorkerAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicatorWorkerAllocations and returns the data updated in the database.
     * @param {IndicatorWorkerAllocationUpdateManyAndReturnArgs} args - Arguments to update many IndicatorWorkerAllocations.
     * @example
     * // Update many IndicatorWorkerAllocations
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IndicatorWorkerAllocations and only return the `id`
     * const indicatorWorkerAllocationWithIdOnly = await prisma.indicatorWorkerAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndicatorWorkerAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, IndicatorWorkerAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IndicatorWorkerAllocation.
     * @param {IndicatorWorkerAllocationUpsertArgs} args - Arguments to update or create a IndicatorWorkerAllocation.
     * @example
     * // Update or create a IndicatorWorkerAllocation
     * const indicatorWorkerAllocation = await prisma.indicatorWorkerAllocation.upsert({
     *   create: {
     *     // ... data to create a IndicatorWorkerAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicatorWorkerAllocation we want to update
     *   }
     * })
     */
    upsert<T extends IndicatorWorkerAllocationUpsertArgs>(args: SelectSubset<T, IndicatorWorkerAllocationUpsertArgs<ExtArgs>>): Prisma__IndicatorWorkerAllocationClient<$Result.GetResult<Prisma.$IndicatorWorkerAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IndicatorWorkerAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationCountArgs} args - Arguments to filter IndicatorWorkerAllocations to count.
     * @example
     * // Count the number of IndicatorWorkerAllocations
     * const count = await prisma.indicatorWorkerAllocation.count({
     *   where: {
     *     // ... the filter for the IndicatorWorkerAllocations we want to count
     *   }
     * })
    **/
    count<T extends IndicatorWorkerAllocationCountArgs>(
      args?: Subset<T, IndicatorWorkerAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicatorWorkerAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicatorWorkerAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicatorWorkerAllocationAggregateArgs>(args: Subset<T, IndicatorWorkerAllocationAggregateArgs>): Prisma.PrismaPromise<GetIndicatorWorkerAllocationAggregateType<T>>

    /**
     * Group by IndicatorWorkerAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicatorWorkerAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicatorWorkerAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicatorWorkerAllocationGroupByArgs['orderBy'] }
        : { orderBy?: IndicatorWorkerAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicatorWorkerAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicatorWorkerAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicatorWorkerAllocation model
   */
  readonly fields: IndicatorWorkerAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicatorWorkerAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicatorWorkerAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicator<T extends IndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndicatorDefaultArgs<ExtArgs>>): Prisma__IndicatorClient<$Result.GetResult<Prisma.$IndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicatorWorkerAllocation model
   */
  interface IndicatorWorkerAllocationFieldRefs {
    readonly id: FieldRef<"IndicatorWorkerAllocation", 'String'>
    readonly indicator_id: FieldRef<"IndicatorWorkerAllocation", 'Int'>
    readonly worker_type: FieldRef<"IndicatorWorkerAllocation", 'String'>
    readonly allocated_amount: FieldRef<"IndicatorWorkerAllocation", 'Int'>
    readonly created_at: FieldRef<"IndicatorWorkerAllocation", 'DateTime'>
    readonly updated_at: FieldRef<"IndicatorWorkerAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndicatorWorkerAllocation findUnique
   */
  export type IndicatorWorkerAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorWorkerAllocation to fetch.
     */
    where: IndicatorWorkerAllocationWhereUniqueInput
  }

  /**
   * IndicatorWorkerAllocation findUniqueOrThrow
   */
  export type IndicatorWorkerAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorWorkerAllocation to fetch.
     */
    where: IndicatorWorkerAllocationWhereUniqueInput
  }

  /**
   * IndicatorWorkerAllocation findFirst
   */
  export type IndicatorWorkerAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorWorkerAllocation to fetch.
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorWorkerAllocations to fetch.
     */
    orderBy?: IndicatorWorkerAllocationOrderByWithRelationInput | IndicatorWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorWorkerAllocations.
     */
    cursor?: IndicatorWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorWorkerAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorWorkerAllocations.
     */
    distinct?: IndicatorWorkerAllocationScalarFieldEnum | IndicatorWorkerAllocationScalarFieldEnum[]
  }

  /**
   * IndicatorWorkerAllocation findFirstOrThrow
   */
  export type IndicatorWorkerAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorWorkerAllocation to fetch.
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorWorkerAllocations to fetch.
     */
    orderBy?: IndicatorWorkerAllocationOrderByWithRelationInput | IndicatorWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicatorWorkerAllocations.
     */
    cursor?: IndicatorWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorWorkerAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicatorWorkerAllocations.
     */
    distinct?: IndicatorWorkerAllocationScalarFieldEnum | IndicatorWorkerAllocationScalarFieldEnum[]
  }

  /**
   * IndicatorWorkerAllocation findMany
   */
  export type IndicatorWorkerAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter, which IndicatorWorkerAllocations to fetch.
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicatorWorkerAllocations to fetch.
     */
    orderBy?: IndicatorWorkerAllocationOrderByWithRelationInput | IndicatorWorkerAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicatorWorkerAllocations.
     */
    cursor?: IndicatorWorkerAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicatorWorkerAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicatorWorkerAllocations.
     */
    skip?: number
    distinct?: IndicatorWorkerAllocationScalarFieldEnum | IndicatorWorkerAllocationScalarFieldEnum[]
  }

  /**
   * IndicatorWorkerAllocation create
   */
  export type IndicatorWorkerAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicatorWorkerAllocation.
     */
    data: XOR<IndicatorWorkerAllocationCreateInput, IndicatorWorkerAllocationUncheckedCreateInput>
  }

  /**
   * IndicatorWorkerAllocation createMany
   */
  export type IndicatorWorkerAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicatorWorkerAllocations.
     */
    data: IndicatorWorkerAllocationCreateManyInput | IndicatorWorkerAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicatorWorkerAllocation createManyAndReturn
   */
  export type IndicatorWorkerAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many IndicatorWorkerAllocations.
     */
    data: IndicatorWorkerAllocationCreateManyInput | IndicatorWorkerAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorWorkerAllocation update
   */
  export type IndicatorWorkerAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicatorWorkerAllocation.
     */
    data: XOR<IndicatorWorkerAllocationUpdateInput, IndicatorWorkerAllocationUncheckedUpdateInput>
    /**
     * Choose, which IndicatorWorkerAllocation to update.
     */
    where: IndicatorWorkerAllocationWhereUniqueInput
  }

  /**
   * IndicatorWorkerAllocation updateMany
   */
  export type IndicatorWorkerAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicatorWorkerAllocations.
     */
    data: XOR<IndicatorWorkerAllocationUpdateManyMutationInput, IndicatorWorkerAllocationUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorWorkerAllocations to update
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * Limit how many IndicatorWorkerAllocations to update.
     */
    limit?: number
  }

  /**
   * IndicatorWorkerAllocation updateManyAndReturn
   */
  export type IndicatorWorkerAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * The data used to update IndicatorWorkerAllocations.
     */
    data: XOR<IndicatorWorkerAllocationUpdateManyMutationInput, IndicatorWorkerAllocationUncheckedUpdateManyInput>
    /**
     * Filter which IndicatorWorkerAllocations to update
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * Limit how many IndicatorWorkerAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicatorWorkerAllocation upsert
   */
  export type IndicatorWorkerAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicatorWorkerAllocation to update in case it exists.
     */
    where: IndicatorWorkerAllocationWhereUniqueInput
    /**
     * In case the IndicatorWorkerAllocation found by the `where` argument doesn't exist, create a new IndicatorWorkerAllocation with this data.
     */
    create: XOR<IndicatorWorkerAllocationCreateInput, IndicatorWorkerAllocationUncheckedCreateInput>
    /**
     * In case the IndicatorWorkerAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicatorWorkerAllocationUpdateInput, IndicatorWorkerAllocationUncheckedUpdateInput>
  }

  /**
   * IndicatorWorkerAllocation delete
   */
  export type IndicatorWorkerAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
    /**
     * Filter which IndicatorWorkerAllocation to delete.
     */
    where: IndicatorWorkerAllocationWhereUniqueInput
  }

  /**
   * IndicatorWorkerAllocation deleteMany
   */
  export type IndicatorWorkerAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicatorWorkerAllocations to delete
     */
    where?: IndicatorWorkerAllocationWhereInput
    /**
     * Limit how many IndicatorWorkerAllocations to delete.
     */
    limit?: number
  }

  /**
   * IndicatorWorkerAllocation without action
   */
  export type IndicatorWorkerAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicatorWorkerAllocation
     */
    select?: IndicatorWorkerAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IndicatorWorkerAllocation
     */
    omit?: IndicatorWorkerAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicatorWorkerAllocationInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    created_at: Date
    updated_at: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "created_at" | "updated_at", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly created_at: FieldRef<"SystemSetting", 'DateTime'>
    readonly updated_at: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password_hash: 'password_hash',
    role: 'role',
    is_active: 'is_active',
    last_login: 'last_login',
    created_at: 'created_at',
    email: 'email',
    facility_id: 'facility_id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const RemunerationSystemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RemunerationSystemScalarFieldEnum = (typeof RemunerationSystemScalarFieldEnum)[keyof typeof RemunerationSystemScalarFieldEnum]


  export const FacilityTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    description: 'description',
    display_name: 'display_name',
    is_active: 'is_active',
    updated_at: 'updated_at'
  };

  export type FacilityTypeScalarFieldEnum = (typeof FacilityTypeScalarFieldEnum)[keyof typeof FacilityTypeScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    description: 'description',
    display_name: 'display_name',
    district_id: 'district_id',
    facility_type_id: 'facility_type_id',
    is_active: 'is_active',
    updated_at: 'updated_at'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const MonthlyHealthDataScalarFieldEnum: {
    id: 'id',
    sub_centre_id: 'sub_centre_id',
    report_month: 'report_month',
    value: 'value',
    data_quality: 'data_quality',
    remarks: 'remarks',
    uploaded_by: 'uploaded_by',
    approved_by: 'approved_by',
    approved_at: 'approved_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    achievement: 'achievement',
    denominator: 'denominator',
    numerator: 'numerator',
    target_value: 'target_value',
    indicator_id: 'indicator_id',
    district_id: 'district_id',
    facility_id: 'facility_id'
  };

  export type MonthlyHealthDataScalarFieldEnum = (typeof MonthlyHealthDataScalarFieldEnum)[keyof typeof MonthlyHealthDataScalarFieldEnum]


  export const DataUploadSessionScalarFieldEnum: {
    id: 'id',
    file_name: 'file_name',
    report_month: 'report_month',
    total_records: 'total_records',
    success_count: 'success_count',
    error_count: 'error_count',
    status: 'status',
    upload_summary: 'upload_summary',
    uploaded_by: 'uploaded_by',
    created_at: 'created_at',
    completed_at: 'completed_at',
    file_path: 'file_path'
  };

  export type DataUploadSessionScalarFieldEnum = (typeof DataUploadSessionScalarFieldEnum)[keyof typeof DataUploadSessionScalarFieldEnum]


  export const FormulaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    structure: 'structure',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FormulaScalarFieldEnum = (typeof FormulaScalarFieldEnum)[keyof typeof FormulaScalarFieldEnum]


  export const IndicatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    structure: 'structure',
    created_at: 'created_at',
    updated_at: 'updated_at',
    code: 'code',
    applicable_facility_types: 'applicable_facility_types',
    conditions: 'conditions',
    denominator_field_id: 'denominator_field_id',
    denominator_label: 'denominator_label',
    formula_config: 'formula_config',
    numerator_field_id: 'numerator_field_id',
    numerator_label: 'numerator_label',
    target_formula: 'target_formula',
    target_type: 'target_type',
    target_value: 'target_value',
    target_field_id: 'target_field_id',
    source_of_verification: 'source_of_verification'
  };

  export type IndicatorScalarFieldEnum = (typeof IndicatorScalarFieldEnum)[keyof typeof IndicatorScalarFieldEnum]


  export const FieldScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at',
    calculation_formula: 'calculation_formula',
    default_value: 'default_value',
    facility_type_targets: 'facility_type_targets',
    field_type: 'field_type',
    is_active: 'is_active',
    sort_order: 'sort_order',
    user_type: 'user_type',
    validation_rules: 'validation_rules',
    field_category: 'field_category'
  };

  export type FieldScalarFieldEnum = (typeof FieldScalarFieldEnum)[keyof typeof FieldScalarFieldEnum]


  export const FieldValueScalarFieldEnum: {
    id: 'id',
    field_id: 'field_id',
    report_month: 'report_month',
    string_value: 'string_value',
    numeric_value: 'numeric_value',
    boolean_value: 'boolean_value',
    json_value: 'json_value',
    uploaded_by: 'uploaded_by',
    remarks: 'remarks',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_override: 'is_override',
    override_reason: 'override_reason',
    facility_id: 'facility_id'
  };

  export type FieldValueScalarFieldEnum = (typeof FieldValueScalarFieldEnum)[keyof typeof FieldValueScalarFieldEnum]


  export const FacilityFieldDefaultsScalarFieldEnum: {
    id: 'id',
    field_id: 'field_id',
    string_value: 'string_value',
    numeric_value: 'numeric_value',
    boolean_value: 'boolean_value',
    json_value: 'json_value',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    facility_id: 'facility_id'
  };

  export type FacilityFieldDefaultsScalarFieldEnum = (typeof FacilityFieldDefaultsScalarFieldEnum)[keyof typeof FacilityFieldDefaultsScalarFieldEnum]


  export const FacilityFieldMappingScalarFieldEnum: {
    id: 'id',
    field_id: 'field_id',
    is_required: 'is_required',
    display_order: 'display_order',
    created_at: 'created_at',
    updated_at: 'updated_at',
    facility_type_id: 'facility_type_id'
  };

  export type FacilityFieldMappingScalarFieldEnum = (typeof FacilityFieldMappingScalarFieldEnum)[keyof typeof FacilityFieldMappingScalarFieldEnum]


  export const Sub_centreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    facility_id: 'facility_id'
  };

  export type Sub_centreScalarFieldEnum = (typeof Sub_centreScalarFieldEnum)[keyof typeof Sub_centreScalarFieldEnum]


  export const HealthWorkerScalarFieldEnum: {
    id: 'id',
    facility_id: 'facility_id',
    name: 'name',
    worker_type: 'worker_type',
    allocated_amount: 'allocated_amount',
    contact_number: 'contact_number',
    email: 'email',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type HealthWorkerScalarFieldEnum = (typeof HealthWorkerScalarFieldEnum)[keyof typeof HealthWorkerScalarFieldEnum]


  export const RemunerationCalculationScalarFieldEnum: {
    id: 'id',
    facility_id: 'facility_id',
    report_month: 'report_month',
    performance_percentage: 'performance_percentage',
    facility_remuneration: 'facility_remuneration',
    total_worker_remuneration: 'total_worker_remuneration',
    total_remuneration: 'total_remuneration',
    health_workers_count: 'health_workers_count',
    asha_workers_count: 'asha_workers_count',
    calculated_at: 'calculated_at'
  };

  export type RemunerationCalculationScalarFieldEnum = (typeof RemunerationCalculationScalarFieldEnum)[keyof typeof RemunerationCalculationScalarFieldEnum]


  export const WorkerRemunerationScalarFieldEnum: {
    id: 'id',
    health_worker_id: 'health_worker_id',
    report_month: 'report_month',
    allocated_amount: 'allocated_amount',
    performance_percentage: 'performance_percentage',
    calculated_amount: 'calculated_amount',
    calculated_at: 'calculated_at'
  };

  export type WorkerRemunerationScalarFieldEnum = (typeof WorkerRemunerationScalarFieldEnum)[keyof typeof WorkerRemunerationScalarFieldEnum]


  export const WorkerAllocationConfigScalarFieldEnum: {
    id: 'id',
    facility_type_id: 'facility_type_id',
    worker_type: 'worker_type',
    worker_role: 'worker_role',
    max_count: 'max_count',
    allocated_amount: 'allocated_amount',
    description: 'description',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WorkerAllocationConfigScalarFieldEnum = (typeof WorkerAllocationConfigScalarFieldEnum)[keyof typeof WorkerAllocationConfigScalarFieldEnum]


  export const FacilityWorkerAllocationScalarFieldEnum: {
    id: 'id',
    facility_id: 'facility_id',
    worker_allocation_config_id: 'worker_allocation_config_id',
    worker_count: 'worker_count',
    total_allocated_amount: 'total_allocated_amount',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FacilityWorkerAllocationScalarFieldEnum = (typeof FacilityWorkerAllocationScalarFieldEnum)[keyof typeof FacilityWorkerAllocationScalarFieldEnum]


  export const FacilityTypeRemunerationScalarFieldEnum: {
    id: 'id',
    total_amount: 'total_amount',
    effective_from: 'effective_from',
    effective_to: 'effective_to',
    created_at: 'created_at',
    updated_at: 'updated_at',
    facility_type_id: 'facility_type_id'
  };

  export type FacilityTypeRemunerationScalarFieldEnum = (typeof FacilityTypeRemunerationScalarFieldEnum)[keyof typeof FacilityTypeRemunerationScalarFieldEnum]


  export const IndicatorRemunerationScalarFieldEnum: {
    id: 'id',
    facility_type_remuneration_id: 'facility_type_remuneration_id',
    indicator_id: 'indicator_id',
    base_amount: 'base_amount',
    conditional_amount: 'conditional_amount',
    condition_type: 'condition_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    remuneration_system_id: 'remuneration_system_id'
  };

  export type IndicatorRemunerationScalarFieldEnum = (typeof IndicatorRemunerationScalarFieldEnum)[keyof typeof IndicatorRemunerationScalarFieldEnum]


  export const PerformanceCalculationScalarFieldEnum: {
    id: 'id',
    sub_centre_id: 'sub_centre_id',
    indicator_id: 'indicator_id',
    report_month: 'report_month',
    numerator: 'numerator',
    denominator: 'denominator',
    achievement: 'achievement',
    target_value: 'target_value',
    remuneration_amount: 'remuneration_amount',
    calculated_at: 'calculated_at',
    facility_id: 'facility_id'
  };

  export type PerformanceCalculationScalarFieldEnum = (typeof PerformanceCalculationScalarFieldEnum)[keyof typeof PerformanceCalculationScalarFieldEnum]


  export const FacilityTargetScalarFieldEnum: {
    id: 'id',
    indicator_id: 'indicator_id',
    report_month: 'report_month',
    target_value: 'target_value',
    numerator_label: 'numerator_label',
    denominator_label: 'denominator_label',
    created_at: 'created_at',
    updated_at: 'updated_at',
    facility_id: 'facility_id'
  };

  export type FacilityTargetScalarFieldEnum = (typeof FacilityTargetScalarFieldEnum)[keyof typeof FacilityTargetScalarFieldEnum]


  export const IndicatorWorkerAllocationScalarFieldEnum: {
    id: 'id',
    indicator_id: 'indicator_id',
    worker_type: 'worker_type',
    allocated_amount: 'allocated_amount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type IndicatorWorkerAllocationScalarFieldEnum = (typeof IndicatorWorkerAllocationScalarFieldEnum)[keyof typeof IndicatorWorkerAllocationScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DataQuality'
   */
  export type EnumDataQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataQuality'>
    


  /**
   * Reference to a field of type 'DataQuality[]'
   */
  export type ListEnumDataQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataQuality[]'>
    


  /**
   * Reference to a field of type 'UploadStatus'
   */
  export type EnumUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadStatus'>
    


  /**
   * Reference to a field of type 'UploadStatus[]'
   */
  export type ListEnumUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TargetType'
   */
  export type EnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType'>
    


  /**
   * Reference to a field of type 'TargetType[]'
   */
  export type ListEnumTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TargetType[]'>
    


  /**
   * Reference to a field of type 'FieldType'
   */
  export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


  /**
   * Reference to a field of type 'FieldType[]'
   */
  export type ListEnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'FieldCategory'
   */
  export type EnumFieldCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldCategory'>
    


  /**
   * Reference to a field of type 'FieldCategory[]'
   */
  export type ListEnumFieldCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_active?: BoolNullableFilter<"User"> | boolean | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    email?: StringNullableFilter<"User"> | string | null
    facility_id?: StringNullableFilter<"User"> | string | null
    upload_sessions?: DataUploadSessionListRelationFilter
    field_values?: FieldValueListRelationFilter
    approved_data?: MonthlyHealthDataListRelationFilter
    uploaded_data?: MonthlyHealthDataListRelationFilter
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    facility_id?: SortOrderInput | SortOrder
    upload_sessions?: DataUploadSessionOrderByRelationAggregateInput
    field_values?: FieldValueOrderByRelationAggregateInput
    approved_data?: MonthlyHealthDataOrderByRelationAggregateInput
    uploaded_data?: MonthlyHealthDataOrderByRelationAggregateInput
    facility?: FacilityOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_active?: BoolNullableFilter<"User"> | boolean | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    facility_id?: StringNullableFilter<"User"> | string | null
    upload_sessions?: DataUploadSessionListRelationFilter
    field_values?: FieldValueListRelationFilter
    approved_data?: MonthlyHealthDataListRelationFilter
    uploaded_data?: MonthlyHealthDataListRelationFilter
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrderInput | SortOrder
    last_login?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    facility_id?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    is_active?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    last_login?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    facility_id?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: StringFilter<"District"> | string
    name?: StringFilter<"District"> | string
    created_at?: DateTimeFilter<"District"> | Date | string
    updated_at?: DateTimeFilter<"District"> | Date | string
    facilities?: FacilityListRelationFilter
    monthly_data?: MonthlyHealthDataListRelationFilter
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facilities?: FacilityOrderByRelationAggregateInput
    monthly_data?: MonthlyHealthDataOrderByRelationAggregateInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    created_at?: DateTimeFilter<"District"> | Date | string
    updated_at?: DateTimeFilter<"District"> | Date | string
    facilities?: FacilityListRelationFilter
    monthly_data?: MonthlyHealthDataListRelationFilter
  }, "id" | "name">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"District"> | string
    name?: StringWithAggregatesFilter<"District"> | string
    created_at?: DateTimeWithAggregatesFilter<"District"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"District"> | Date | string
  }

  export type RemunerationSystemWhereInput = {
    AND?: RemunerationSystemWhereInput | RemunerationSystemWhereInput[]
    OR?: RemunerationSystemWhereInput[]
    NOT?: RemunerationSystemWhereInput | RemunerationSystemWhereInput[]
    id?: StringFilter<"RemunerationSystem"> | string
    name?: StringFilter<"RemunerationSystem"> | string
    description?: StringNullableFilter<"RemunerationSystem"> | string | null
    is_active?: BoolFilter<"RemunerationSystem"> | boolean
    created_at?: DateTimeFilter<"RemunerationSystem"> | Date | string
    updated_at?: DateTimeFilter<"RemunerationSystem"> | Date | string
    indicator_remunerations?: IndicatorRemunerationListRelationFilter
  }

  export type RemunerationSystemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    indicator_remunerations?: IndicatorRemunerationOrderByRelationAggregateInput
  }

  export type RemunerationSystemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RemunerationSystemWhereInput | RemunerationSystemWhereInput[]
    OR?: RemunerationSystemWhereInput[]
    NOT?: RemunerationSystemWhereInput | RemunerationSystemWhereInput[]
    description?: StringNullableFilter<"RemunerationSystem"> | string | null
    is_active?: BoolFilter<"RemunerationSystem"> | boolean
    created_at?: DateTimeFilter<"RemunerationSystem"> | Date | string
    updated_at?: DateTimeFilter<"RemunerationSystem"> | Date | string
    indicator_remunerations?: IndicatorRemunerationListRelationFilter
  }, "id" | "name">

  export type RemunerationSystemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RemunerationSystemCountOrderByAggregateInput
    _max?: RemunerationSystemMaxOrderByAggregateInput
    _min?: RemunerationSystemMinOrderByAggregateInput
  }

  export type RemunerationSystemScalarWhereWithAggregatesInput = {
    AND?: RemunerationSystemScalarWhereWithAggregatesInput | RemunerationSystemScalarWhereWithAggregatesInput[]
    OR?: RemunerationSystemScalarWhereWithAggregatesInput[]
    NOT?: RemunerationSystemScalarWhereWithAggregatesInput | RemunerationSystemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RemunerationSystem"> | string
    name?: StringWithAggregatesFilter<"RemunerationSystem"> | string
    description?: StringNullableWithAggregatesFilter<"RemunerationSystem"> | string | null
    is_active?: BoolWithAggregatesFilter<"RemunerationSystem"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"RemunerationSystem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"RemunerationSystem"> | Date | string
  }

  export type FacilityTypeWhereInput = {
    AND?: FacilityTypeWhereInput | FacilityTypeWhereInput[]
    OR?: FacilityTypeWhereInput[]
    NOT?: FacilityTypeWhereInput | FacilityTypeWhereInput[]
    id?: StringFilter<"FacilityType"> | string
    name?: StringFilter<"FacilityType"> | string
    created_at?: DateTimeFilter<"FacilityType"> | Date | string
    description?: StringNullableFilter<"FacilityType"> | string | null
    display_name?: StringFilter<"FacilityType"> | string
    is_active?: BoolFilter<"FacilityType"> | boolean
    updated_at?: DateTimeFilter<"FacilityType"> | Date | string
    facilities?: FacilityListRelationFilter
    field_mappings?: FacilityFieldMappingListRelationFilter
    remunerations?: XOR<FacilityTypeRemunerationNullableScalarRelationFilter, FacilityTypeRemunerationWhereInput> | null
    worker_allocations?: WorkerAllocationConfigListRelationFilter
  }

  export type FacilityTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrderInput | SortOrder
    display_name?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
    facilities?: FacilityOrderByRelationAggregateInput
    field_mappings?: FacilityFieldMappingOrderByRelationAggregateInput
    remunerations?: FacilityTypeRemunerationOrderByWithRelationInput
    worker_allocations?: WorkerAllocationConfigOrderByRelationAggregateInput
  }

  export type FacilityTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FacilityTypeWhereInput | FacilityTypeWhereInput[]
    OR?: FacilityTypeWhereInput[]
    NOT?: FacilityTypeWhereInput | FacilityTypeWhereInput[]
    created_at?: DateTimeFilter<"FacilityType"> | Date | string
    description?: StringNullableFilter<"FacilityType"> | string | null
    display_name?: StringFilter<"FacilityType"> | string
    is_active?: BoolFilter<"FacilityType"> | boolean
    updated_at?: DateTimeFilter<"FacilityType"> | Date | string
    facilities?: FacilityListRelationFilter
    field_mappings?: FacilityFieldMappingListRelationFilter
    remunerations?: XOR<FacilityTypeRemunerationNullableScalarRelationFilter, FacilityTypeRemunerationWhereInput> | null
    worker_allocations?: WorkerAllocationConfigListRelationFilter
  }, "id" | "name">

  export type FacilityTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrderInput | SortOrder
    display_name?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
    _count?: FacilityTypeCountOrderByAggregateInput
    _max?: FacilityTypeMaxOrderByAggregateInput
    _min?: FacilityTypeMinOrderByAggregateInput
  }

  export type FacilityTypeScalarWhereWithAggregatesInput = {
    AND?: FacilityTypeScalarWhereWithAggregatesInput | FacilityTypeScalarWhereWithAggregatesInput[]
    OR?: FacilityTypeScalarWhereWithAggregatesInput[]
    NOT?: FacilityTypeScalarWhereWithAggregatesInput | FacilityTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FacilityType"> | string
    name?: StringWithAggregatesFilter<"FacilityType"> | string
    created_at?: DateTimeWithAggregatesFilter<"FacilityType"> | Date | string
    description?: StringNullableWithAggregatesFilter<"FacilityType"> | string | null
    display_name?: StringWithAggregatesFilter<"FacilityType"> | string
    is_active?: BoolWithAggregatesFilter<"FacilityType"> | boolean
    updated_at?: DateTimeWithAggregatesFilter<"FacilityType"> | Date | string
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    created_at?: DateTimeFilter<"Facility"> | Date | string
    description?: StringNullableFilter<"Facility"> | string | null
    display_name?: StringFilter<"Facility"> | string
    district_id?: StringFilter<"Facility"> | string
    facility_type_id?: StringFilter<"Facility"> | string
    is_active?: BoolFilter<"Facility"> | boolean
    updated_at?: DateTimeFilter<"Facility"> | Date | string
    district?: XOR<DistrictScalarRelationFilter, DistrictWhereInput>
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
    facility_field_defaults?: FacilityFieldDefaultsListRelationFilter
    facility_targets?: FacilityTargetListRelationFilter
    worker_allocations?: FacilityWorkerAllocationListRelationFilter
    field_values?: FieldValueListRelationFilter
    health_workers?: HealthWorkerListRelationFilter
    monthly_data?: MonthlyHealthDataListRelationFilter
    performance_calculations?: PerformanceCalculationListRelationFilter
    remuneration_calculations?: RemunerationCalculationListRelationFilter
    sub_centres?: Sub_centreListRelationFilter
    users?: UserListRelationFilter
  }

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrderInput | SortOrder
    display_name?: SortOrder
    district_id?: SortOrder
    facility_type_id?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
    district?: DistrictOrderByWithRelationInput
    facility_type?: FacilityTypeOrderByWithRelationInput
    facility_field_defaults?: FacilityFieldDefaultsOrderByRelationAggregateInput
    facility_targets?: FacilityTargetOrderByRelationAggregateInput
    worker_allocations?: FacilityWorkerAllocationOrderByRelationAggregateInput
    field_values?: FieldValueOrderByRelationAggregateInput
    health_workers?: HealthWorkerOrderByRelationAggregateInput
    monthly_data?: MonthlyHealthDataOrderByRelationAggregateInput
    performance_calculations?: PerformanceCalculationOrderByRelationAggregateInput
    remuneration_calculations?: RemunerationCalculationOrderByRelationAggregateInput
    sub_centres?: sub_centreOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_district_id?: FacilityNameDistrict_idCompoundUniqueInput
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    name?: StringFilter<"Facility"> | string
    created_at?: DateTimeFilter<"Facility"> | Date | string
    description?: StringNullableFilter<"Facility"> | string | null
    display_name?: StringFilter<"Facility"> | string
    district_id?: StringFilter<"Facility"> | string
    facility_type_id?: StringFilter<"Facility"> | string
    is_active?: BoolFilter<"Facility"> | boolean
    updated_at?: DateTimeFilter<"Facility"> | Date | string
    district?: XOR<DistrictScalarRelationFilter, DistrictWhereInput>
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
    facility_field_defaults?: FacilityFieldDefaultsListRelationFilter
    facility_targets?: FacilityTargetListRelationFilter
    worker_allocations?: FacilityWorkerAllocationListRelationFilter
    field_values?: FieldValueListRelationFilter
    health_workers?: HealthWorkerListRelationFilter
    monthly_data?: MonthlyHealthDataListRelationFilter
    performance_calculations?: PerformanceCalculationListRelationFilter
    remuneration_calculations?: RemunerationCalculationListRelationFilter
    sub_centres?: Sub_centreListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "name_district_id">

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrderInput | SortOrder
    display_name?: SortOrder
    district_id?: SortOrder
    facility_type_id?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Facility"> | string
    name?: StringWithAggregatesFilter<"Facility"> | string
    created_at?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    display_name?: StringWithAggregatesFilter<"Facility"> | string
    district_id?: StringWithAggregatesFilter<"Facility"> | string
    facility_type_id?: StringWithAggregatesFilter<"Facility"> | string
    is_active?: BoolWithAggregatesFilter<"Facility"> | boolean
    updated_at?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
  }

  export type MonthlyHealthDataWhereInput = {
    AND?: MonthlyHealthDataWhereInput | MonthlyHealthDataWhereInput[]
    OR?: MonthlyHealthDataWhereInput[]
    NOT?: MonthlyHealthDataWhereInput | MonthlyHealthDataWhereInput[]
    id?: IntFilter<"MonthlyHealthData"> | number
    sub_centre_id?: IntNullableFilter<"MonthlyHealthData"> | number | null
    report_month?: StringFilter<"MonthlyHealthData"> | string
    value?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFilter<"MonthlyHealthData"> | $Enums.DataQuality
    remarks?: StringNullableFilter<"MonthlyHealthData"> | string | null
    uploaded_by?: IntFilter<"MonthlyHealthData"> | number
    approved_by?: IntNullableFilter<"MonthlyHealthData"> | number | null
    approved_at?: DateTimeNullableFilter<"MonthlyHealthData"> | Date | string | null
    created_at?: DateTimeFilter<"MonthlyHealthData"> | Date | string
    updated_at?: DateTimeFilter<"MonthlyHealthData"> | Date | string
    achievement?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    numerator?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    indicator_id?: IntNullableFilter<"MonthlyHealthData"> | number | null
    district_id?: StringFilter<"MonthlyHealthData"> | string
    facility_id?: StringNullableFilter<"MonthlyHealthData"> | string | null
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    district?: XOR<DistrictScalarRelationFilter, DistrictWhereInput>
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    indicator?: XOR<IndicatorNullableScalarRelationFilter, IndicatorWhereInput> | null
    sub_centre?: XOR<Sub_centreNullableScalarRelationFilter, sub_centreWhereInput> | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MonthlyHealthDataOrderByWithRelationInput = {
    id?: SortOrder
    sub_centre_id?: SortOrderInput | SortOrder
    report_month?: SortOrder
    value?: SortOrderInput | SortOrder
    data_quality?: SortOrder
    remarks?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    achievement?: SortOrderInput | SortOrder
    denominator?: SortOrderInput | SortOrder
    numerator?: SortOrderInput | SortOrder
    target_value?: SortOrderInput | SortOrder
    indicator_id?: SortOrderInput | SortOrder
    district_id?: SortOrder
    facility_id?: SortOrderInput | SortOrder
    approver?: UserOrderByWithRelationInput
    district?: DistrictOrderByWithRelationInput
    facility?: FacilityOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
    sub_centre?: sub_centreOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type MonthlyHealthDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_id_sub_centre_id_indicator_id_report_month?: MonthlyHealthDataFacility_idSub_centre_idIndicator_idReport_monthCompoundUniqueInput
    AND?: MonthlyHealthDataWhereInput | MonthlyHealthDataWhereInput[]
    OR?: MonthlyHealthDataWhereInput[]
    NOT?: MonthlyHealthDataWhereInput | MonthlyHealthDataWhereInput[]
    sub_centre_id?: IntNullableFilter<"MonthlyHealthData"> | number | null
    report_month?: StringFilter<"MonthlyHealthData"> | string
    value?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFilter<"MonthlyHealthData"> | $Enums.DataQuality
    remarks?: StringNullableFilter<"MonthlyHealthData"> | string | null
    uploaded_by?: IntFilter<"MonthlyHealthData"> | number
    approved_by?: IntNullableFilter<"MonthlyHealthData"> | number | null
    approved_at?: DateTimeNullableFilter<"MonthlyHealthData"> | Date | string | null
    created_at?: DateTimeFilter<"MonthlyHealthData"> | Date | string
    updated_at?: DateTimeFilter<"MonthlyHealthData"> | Date | string
    achievement?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    numerator?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    indicator_id?: IntNullableFilter<"MonthlyHealthData"> | number | null
    district_id?: StringFilter<"MonthlyHealthData"> | string
    facility_id?: StringNullableFilter<"MonthlyHealthData"> | string | null
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    district?: XOR<DistrictScalarRelationFilter, DistrictWhereInput>
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    indicator?: XOR<IndicatorNullableScalarRelationFilter, IndicatorWhereInput> | null
    sub_centre?: XOR<Sub_centreNullableScalarRelationFilter, sub_centreWhereInput> | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "facility_id_sub_centre_id_indicator_id_report_month">

  export type MonthlyHealthDataOrderByWithAggregationInput = {
    id?: SortOrder
    sub_centre_id?: SortOrderInput | SortOrder
    report_month?: SortOrder
    value?: SortOrderInput | SortOrder
    data_quality?: SortOrder
    remarks?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrderInput | SortOrder
    approved_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    achievement?: SortOrderInput | SortOrder
    denominator?: SortOrderInput | SortOrder
    numerator?: SortOrderInput | SortOrder
    target_value?: SortOrderInput | SortOrder
    indicator_id?: SortOrderInput | SortOrder
    district_id?: SortOrder
    facility_id?: SortOrderInput | SortOrder
    _count?: MonthlyHealthDataCountOrderByAggregateInput
    _avg?: MonthlyHealthDataAvgOrderByAggregateInput
    _max?: MonthlyHealthDataMaxOrderByAggregateInput
    _min?: MonthlyHealthDataMinOrderByAggregateInput
    _sum?: MonthlyHealthDataSumOrderByAggregateInput
  }

  export type MonthlyHealthDataScalarWhereWithAggregatesInput = {
    AND?: MonthlyHealthDataScalarWhereWithAggregatesInput | MonthlyHealthDataScalarWhereWithAggregatesInput[]
    OR?: MonthlyHealthDataScalarWhereWithAggregatesInput[]
    NOT?: MonthlyHealthDataScalarWhereWithAggregatesInput | MonthlyHealthDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MonthlyHealthData"> | number
    sub_centre_id?: IntNullableWithAggregatesFilter<"MonthlyHealthData"> | number | null
    report_month?: StringWithAggregatesFilter<"MonthlyHealthData"> | string
    value?: DecimalNullableWithAggregatesFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityWithAggregatesFilter<"MonthlyHealthData"> | $Enums.DataQuality
    remarks?: StringNullableWithAggregatesFilter<"MonthlyHealthData"> | string | null
    uploaded_by?: IntWithAggregatesFilter<"MonthlyHealthData"> | number
    approved_by?: IntNullableWithAggregatesFilter<"MonthlyHealthData"> | number | null
    approved_at?: DateTimeNullableWithAggregatesFilter<"MonthlyHealthData"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"MonthlyHealthData"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MonthlyHealthData"> | Date | string
    achievement?: DecimalNullableWithAggregatesFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableWithAggregatesFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    numerator?: DecimalNullableWithAggregatesFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableWithAggregatesFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    indicator_id?: IntNullableWithAggregatesFilter<"MonthlyHealthData"> | number | null
    district_id?: StringWithAggregatesFilter<"MonthlyHealthData"> | string
    facility_id?: StringNullableWithAggregatesFilter<"MonthlyHealthData"> | string | null
  }

  export type DataUploadSessionWhereInput = {
    AND?: DataUploadSessionWhereInput | DataUploadSessionWhereInput[]
    OR?: DataUploadSessionWhereInput[]
    NOT?: DataUploadSessionWhereInput | DataUploadSessionWhereInput[]
    id?: IntFilter<"DataUploadSession"> | number
    file_name?: StringFilter<"DataUploadSession"> | string
    report_month?: StringFilter<"DataUploadSession"> | string
    total_records?: IntFilter<"DataUploadSession"> | number
    success_count?: IntFilter<"DataUploadSession"> | number
    error_count?: IntFilter<"DataUploadSession"> | number
    status?: EnumUploadStatusFilter<"DataUploadSession"> | $Enums.UploadStatus
    upload_summary?: JsonNullableFilter<"DataUploadSession">
    uploaded_by?: IntFilter<"DataUploadSession"> | number
    created_at?: DateTimeFilter<"DataUploadSession"> | Date | string
    completed_at?: DateTimeNullableFilter<"DataUploadSession"> | Date | string | null
    file_path?: StringNullableFilter<"DataUploadSession"> | string | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DataUploadSessionOrderByWithRelationInput = {
    id?: SortOrder
    file_name?: SortOrder
    report_month?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    status?: SortOrder
    upload_summary?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    uploader?: UserOrderByWithRelationInput
  }

  export type DataUploadSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DataUploadSessionWhereInput | DataUploadSessionWhereInput[]
    OR?: DataUploadSessionWhereInput[]
    NOT?: DataUploadSessionWhereInput | DataUploadSessionWhereInput[]
    file_name?: StringFilter<"DataUploadSession"> | string
    report_month?: StringFilter<"DataUploadSession"> | string
    total_records?: IntFilter<"DataUploadSession"> | number
    success_count?: IntFilter<"DataUploadSession"> | number
    error_count?: IntFilter<"DataUploadSession"> | number
    status?: EnumUploadStatusFilter<"DataUploadSession"> | $Enums.UploadStatus
    upload_summary?: JsonNullableFilter<"DataUploadSession">
    uploaded_by?: IntFilter<"DataUploadSession"> | number
    created_at?: DateTimeFilter<"DataUploadSession"> | Date | string
    completed_at?: DateTimeNullableFilter<"DataUploadSession"> | Date | string | null
    file_path?: StringNullableFilter<"DataUploadSession"> | string | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DataUploadSessionOrderByWithAggregationInput = {
    id?: SortOrder
    file_name?: SortOrder
    report_month?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    status?: SortOrder
    upload_summary?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    _count?: DataUploadSessionCountOrderByAggregateInput
    _avg?: DataUploadSessionAvgOrderByAggregateInput
    _max?: DataUploadSessionMaxOrderByAggregateInput
    _min?: DataUploadSessionMinOrderByAggregateInput
    _sum?: DataUploadSessionSumOrderByAggregateInput
  }

  export type DataUploadSessionScalarWhereWithAggregatesInput = {
    AND?: DataUploadSessionScalarWhereWithAggregatesInput | DataUploadSessionScalarWhereWithAggregatesInput[]
    OR?: DataUploadSessionScalarWhereWithAggregatesInput[]
    NOT?: DataUploadSessionScalarWhereWithAggregatesInput | DataUploadSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataUploadSession"> | number
    file_name?: StringWithAggregatesFilter<"DataUploadSession"> | string
    report_month?: StringWithAggregatesFilter<"DataUploadSession"> | string
    total_records?: IntWithAggregatesFilter<"DataUploadSession"> | number
    success_count?: IntWithAggregatesFilter<"DataUploadSession"> | number
    error_count?: IntWithAggregatesFilter<"DataUploadSession"> | number
    status?: EnumUploadStatusWithAggregatesFilter<"DataUploadSession"> | $Enums.UploadStatus
    upload_summary?: JsonNullableWithAggregatesFilter<"DataUploadSession">
    uploaded_by?: IntWithAggregatesFilter<"DataUploadSession"> | number
    created_at?: DateTimeWithAggregatesFilter<"DataUploadSession"> | Date | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"DataUploadSession"> | Date | string | null
    file_path?: StringNullableWithAggregatesFilter<"DataUploadSession"> | string | null
  }

  export type FormulaWhereInput = {
    AND?: FormulaWhereInput | FormulaWhereInput[]
    OR?: FormulaWhereInput[]
    NOT?: FormulaWhereInput | FormulaWhereInput[]
    id?: IntFilter<"Formula"> | number
    name?: StringFilter<"Formula"> | string
    description?: StringNullableFilter<"Formula"> | string | null
    structure?: JsonFilter<"Formula">
    created_at?: DateTimeFilter<"Formula"> | Date | string
    updated_at?: DateTimeFilter<"Formula"> | Date | string
  }

  export type FormulaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    structure?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FormulaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: FormulaWhereInput | FormulaWhereInput[]
    OR?: FormulaWhereInput[]
    NOT?: FormulaWhereInput | FormulaWhereInput[]
    description?: StringNullableFilter<"Formula"> | string | null
    structure?: JsonFilter<"Formula">
    created_at?: DateTimeFilter<"Formula"> | Date | string
    updated_at?: DateTimeFilter<"Formula"> | Date | string
  }, "id" | "name">

  export type FormulaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    structure?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FormulaCountOrderByAggregateInput
    _avg?: FormulaAvgOrderByAggregateInput
    _max?: FormulaMaxOrderByAggregateInput
    _min?: FormulaMinOrderByAggregateInput
    _sum?: FormulaSumOrderByAggregateInput
  }

  export type FormulaScalarWhereWithAggregatesInput = {
    AND?: FormulaScalarWhereWithAggregatesInput | FormulaScalarWhereWithAggregatesInput[]
    OR?: FormulaScalarWhereWithAggregatesInput[]
    NOT?: FormulaScalarWhereWithAggregatesInput | FormulaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Formula"> | number
    name?: StringWithAggregatesFilter<"Formula"> | string
    description?: StringNullableWithAggregatesFilter<"Formula"> | string | null
    structure?: JsonWithAggregatesFilter<"Formula">
    created_at?: DateTimeWithAggregatesFilter<"Formula"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Formula"> | Date | string
  }

  export type IndicatorWhereInput = {
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    id?: IntFilter<"Indicator"> | number
    name?: StringFilter<"Indicator"> | string
    description?: StringNullableFilter<"Indicator"> | string | null
    type?: StringFilter<"Indicator"> | string
    structure?: JsonNullableFilter<"Indicator">
    created_at?: DateTimeFilter<"Indicator"> | Date | string
    updated_at?: DateTimeFilter<"Indicator"> | Date | string
    code?: StringFilter<"Indicator"> | string
    applicable_facility_types?: JsonNullableFilter<"Indicator">
    conditions?: StringNullableFilter<"Indicator"> | string | null
    denominator_field_id?: IntNullableFilter<"Indicator"> | number | null
    denominator_label?: StringNullableFilter<"Indicator"> | string | null
    formula_config?: JsonNullableFilter<"Indicator">
    numerator_field_id?: IntNullableFilter<"Indicator"> | number | null
    numerator_label?: StringNullableFilter<"Indicator"> | string | null
    target_formula?: StringNullableFilter<"Indicator"> | string | null
    target_type?: EnumTargetTypeFilter<"Indicator"> | $Enums.TargetType
    target_value?: StringNullableFilter<"Indicator"> | string | null
    target_field_id?: IntNullableFilter<"Indicator"> | number | null
    source_of_verification?: StringNullableFilter<"Indicator"> | string | null
    facility_targets?: FacilityTargetListRelationFilter
    denominator_field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    numerator_field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    target_field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    remunerations?: IndicatorRemunerationListRelationFilter
    worker_allocations?: IndicatorWorkerAllocationListRelationFilter
    monthly_data?: MonthlyHealthDataListRelationFilter
    performance_calculations?: PerformanceCalculationListRelationFilter
  }

  export type IndicatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    structure?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    applicable_facility_types?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    denominator_field_id?: SortOrderInput | SortOrder
    denominator_label?: SortOrderInput | SortOrder
    formula_config?: SortOrderInput | SortOrder
    numerator_field_id?: SortOrderInput | SortOrder
    numerator_label?: SortOrderInput | SortOrder
    target_formula?: SortOrderInput | SortOrder
    target_type?: SortOrder
    target_value?: SortOrderInput | SortOrder
    target_field_id?: SortOrderInput | SortOrder
    source_of_verification?: SortOrderInput | SortOrder
    facility_targets?: FacilityTargetOrderByRelationAggregateInput
    denominator_field?: FieldOrderByWithRelationInput
    numerator_field?: FieldOrderByWithRelationInput
    target_field?: FieldOrderByWithRelationInput
    remunerations?: IndicatorRemunerationOrderByRelationAggregateInput
    worker_allocations?: IndicatorWorkerAllocationOrderByRelationAggregateInput
    monthly_data?: MonthlyHealthDataOrderByRelationAggregateInput
    performance_calculations?: PerformanceCalculationOrderByRelationAggregateInput
  }

  export type IndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: IndicatorWhereInput | IndicatorWhereInput[]
    OR?: IndicatorWhereInput[]
    NOT?: IndicatorWhereInput | IndicatorWhereInput[]
    name?: StringFilter<"Indicator"> | string
    description?: StringNullableFilter<"Indicator"> | string | null
    type?: StringFilter<"Indicator"> | string
    structure?: JsonNullableFilter<"Indicator">
    created_at?: DateTimeFilter<"Indicator"> | Date | string
    updated_at?: DateTimeFilter<"Indicator"> | Date | string
    applicable_facility_types?: JsonNullableFilter<"Indicator">
    conditions?: StringNullableFilter<"Indicator"> | string | null
    denominator_field_id?: IntNullableFilter<"Indicator"> | number | null
    denominator_label?: StringNullableFilter<"Indicator"> | string | null
    formula_config?: JsonNullableFilter<"Indicator">
    numerator_field_id?: IntNullableFilter<"Indicator"> | number | null
    numerator_label?: StringNullableFilter<"Indicator"> | string | null
    target_formula?: StringNullableFilter<"Indicator"> | string | null
    target_type?: EnumTargetTypeFilter<"Indicator"> | $Enums.TargetType
    target_value?: StringNullableFilter<"Indicator"> | string | null
    target_field_id?: IntNullableFilter<"Indicator"> | number | null
    source_of_verification?: StringNullableFilter<"Indicator"> | string | null
    facility_targets?: FacilityTargetListRelationFilter
    denominator_field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    numerator_field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    target_field?: XOR<FieldNullableScalarRelationFilter, FieldWhereInput> | null
    remunerations?: IndicatorRemunerationListRelationFilter
    worker_allocations?: IndicatorWorkerAllocationListRelationFilter
    monthly_data?: MonthlyHealthDataListRelationFilter
    performance_calculations?: PerformanceCalculationListRelationFilter
  }, "id" | "code">

  export type IndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    structure?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    applicable_facility_types?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    denominator_field_id?: SortOrderInput | SortOrder
    denominator_label?: SortOrderInput | SortOrder
    formula_config?: SortOrderInput | SortOrder
    numerator_field_id?: SortOrderInput | SortOrder
    numerator_label?: SortOrderInput | SortOrder
    target_formula?: SortOrderInput | SortOrder
    target_type?: SortOrder
    target_value?: SortOrderInput | SortOrder
    target_field_id?: SortOrderInput | SortOrder
    source_of_verification?: SortOrderInput | SortOrder
    _count?: IndicatorCountOrderByAggregateInput
    _avg?: IndicatorAvgOrderByAggregateInput
    _max?: IndicatorMaxOrderByAggregateInput
    _min?: IndicatorMinOrderByAggregateInput
    _sum?: IndicatorSumOrderByAggregateInput
  }

  export type IndicatorScalarWhereWithAggregatesInput = {
    AND?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    OR?: IndicatorScalarWhereWithAggregatesInput[]
    NOT?: IndicatorScalarWhereWithAggregatesInput | IndicatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Indicator"> | number
    name?: StringWithAggregatesFilter<"Indicator"> | string
    description?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    type?: StringWithAggregatesFilter<"Indicator"> | string
    structure?: JsonNullableWithAggregatesFilter<"Indicator">
    created_at?: DateTimeWithAggregatesFilter<"Indicator"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Indicator"> | Date | string
    code?: StringWithAggregatesFilter<"Indicator"> | string
    applicable_facility_types?: JsonNullableWithAggregatesFilter<"Indicator">
    conditions?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    denominator_field_id?: IntNullableWithAggregatesFilter<"Indicator"> | number | null
    denominator_label?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    formula_config?: JsonNullableWithAggregatesFilter<"Indicator">
    numerator_field_id?: IntNullableWithAggregatesFilter<"Indicator"> | number | null
    numerator_label?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    target_formula?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    target_type?: EnumTargetTypeWithAggregatesFilter<"Indicator"> | $Enums.TargetType
    target_value?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
    target_field_id?: IntNullableWithAggregatesFilter<"Indicator"> | number | null
    source_of_verification?: StringNullableWithAggregatesFilter<"Indicator"> | string | null
  }

  export type FieldWhereInput = {
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    id?: IntFilter<"Field"> | number
    code?: StringFilter<"Field"> | string
    name?: StringFilter<"Field"> | string
    description?: StringNullableFilter<"Field"> | string | null
    created_at?: DateTimeFilter<"Field"> | Date | string
    updated_at?: DateTimeFilter<"Field"> | Date | string
    calculation_formula?: StringNullableFilter<"Field"> | string | null
    default_value?: StringNullableFilter<"Field"> | string | null
    facility_type_targets?: JsonNullableFilter<"Field">
    field_type?: EnumFieldTypeFilter<"Field"> | $Enums.FieldType
    is_active?: BoolFilter<"Field"> | boolean
    sort_order?: IntFilter<"Field"> | number
    user_type?: EnumUserTypeFilter<"Field"> | $Enums.UserType
    validation_rules?: JsonNullableFilter<"Field">
    field_category?: EnumFieldCategoryFilter<"Field"> | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsListRelationFilter
    facility_field_mappings?: FacilityFieldMappingListRelationFilter
    field_values?: FieldValueListRelationFilter
    denominator_for_indicators?: IndicatorListRelationFilter
    numerator_for_indicators?: IndicatorListRelationFilter
    target_for_indicators?: IndicatorListRelationFilter
  }

  export type FieldOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    calculation_formula?: SortOrderInput | SortOrder
    default_value?: SortOrderInput | SortOrder
    facility_type_targets?: SortOrderInput | SortOrder
    field_type?: SortOrder
    is_active?: SortOrder
    sort_order?: SortOrder
    user_type?: SortOrder
    validation_rules?: SortOrderInput | SortOrder
    field_category?: SortOrder
    facility_field_defaults?: FacilityFieldDefaultsOrderByRelationAggregateInput
    facility_field_mappings?: FacilityFieldMappingOrderByRelationAggregateInput
    field_values?: FieldValueOrderByRelationAggregateInput
    denominator_for_indicators?: IndicatorOrderByRelationAggregateInput
    numerator_for_indicators?: IndicatorOrderByRelationAggregateInput
    target_for_indicators?: IndicatorOrderByRelationAggregateInput
  }

  export type FieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: FieldWhereInput | FieldWhereInput[]
    OR?: FieldWhereInput[]
    NOT?: FieldWhereInput | FieldWhereInput[]
    name?: StringFilter<"Field"> | string
    description?: StringNullableFilter<"Field"> | string | null
    created_at?: DateTimeFilter<"Field"> | Date | string
    updated_at?: DateTimeFilter<"Field"> | Date | string
    calculation_formula?: StringNullableFilter<"Field"> | string | null
    default_value?: StringNullableFilter<"Field"> | string | null
    facility_type_targets?: JsonNullableFilter<"Field">
    field_type?: EnumFieldTypeFilter<"Field"> | $Enums.FieldType
    is_active?: BoolFilter<"Field"> | boolean
    sort_order?: IntFilter<"Field"> | number
    user_type?: EnumUserTypeFilter<"Field"> | $Enums.UserType
    validation_rules?: JsonNullableFilter<"Field">
    field_category?: EnumFieldCategoryFilter<"Field"> | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsListRelationFilter
    facility_field_mappings?: FacilityFieldMappingListRelationFilter
    field_values?: FieldValueListRelationFilter
    denominator_for_indicators?: IndicatorListRelationFilter
    numerator_for_indicators?: IndicatorListRelationFilter
    target_for_indicators?: IndicatorListRelationFilter
  }, "id" | "code">

  export type FieldOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    calculation_formula?: SortOrderInput | SortOrder
    default_value?: SortOrderInput | SortOrder
    facility_type_targets?: SortOrderInput | SortOrder
    field_type?: SortOrder
    is_active?: SortOrder
    sort_order?: SortOrder
    user_type?: SortOrder
    validation_rules?: SortOrderInput | SortOrder
    field_category?: SortOrder
    _count?: FieldCountOrderByAggregateInput
    _avg?: FieldAvgOrderByAggregateInput
    _max?: FieldMaxOrderByAggregateInput
    _min?: FieldMinOrderByAggregateInput
    _sum?: FieldSumOrderByAggregateInput
  }

  export type FieldScalarWhereWithAggregatesInput = {
    AND?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    OR?: FieldScalarWhereWithAggregatesInput[]
    NOT?: FieldScalarWhereWithAggregatesInput | FieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Field"> | number
    code?: StringWithAggregatesFilter<"Field"> | string
    name?: StringWithAggregatesFilter<"Field"> | string
    description?: StringNullableWithAggregatesFilter<"Field"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Field"> | Date | string
    calculation_formula?: StringNullableWithAggregatesFilter<"Field"> | string | null
    default_value?: StringNullableWithAggregatesFilter<"Field"> | string | null
    facility_type_targets?: JsonNullableWithAggregatesFilter<"Field">
    field_type?: EnumFieldTypeWithAggregatesFilter<"Field"> | $Enums.FieldType
    is_active?: BoolWithAggregatesFilter<"Field"> | boolean
    sort_order?: IntWithAggregatesFilter<"Field"> | number
    user_type?: EnumUserTypeWithAggregatesFilter<"Field"> | $Enums.UserType
    validation_rules?: JsonNullableWithAggregatesFilter<"Field">
    field_category?: EnumFieldCategoryWithAggregatesFilter<"Field"> | $Enums.FieldCategory
  }

  export type FieldValueWhereInput = {
    AND?: FieldValueWhereInput | FieldValueWhereInput[]
    OR?: FieldValueWhereInput[]
    NOT?: FieldValueWhereInput | FieldValueWhereInput[]
    id?: IntFilter<"FieldValue"> | number
    field_id?: IntFilter<"FieldValue"> | number
    report_month?: StringFilter<"FieldValue"> | string
    string_value?: StringNullableFilter<"FieldValue"> | string | null
    numeric_value?: DecimalNullableFilter<"FieldValue"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableFilter<"FieldValue"> | boolean | null
    json_value?: JsonNullableFilter<"FieldValue">
    uploaded_by?: IntFilter<"FieldValue"> | number
    remarks?: StringNullableFilter<"FieldValue"> | string | null
    created_at?: DateTimeFilter<"FieldValue"> | Date | string
    updated_at?: DateTimeFilter<"FieldValue"> | Date | string
    is_override?: BoolFilter<"FieldValue"> | boolean
    override_reason?: StringNullableFilter<"FieldValue"> | string | null
    facility_id?: StringNullableFilter<"FieldValue"> | string | null
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FieldValueOrderByWithRelationInput = {
    id?: SortOrder
    field_id?: SortOrder
    report_month?: SortOrder
    string_value?: SortOrderInput | SortOrder
    numeric_value?: SortOrderInput | SortOrder
    boolean_value?: SortOrderInput | SortOrder
    json_value?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_override?: SortOrder
    override_reason?: SortOrderInput | SortOrder
    facility_id?: SortOrderInput | SortOrder
    facility?: FacilityOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type FieldValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    field_id_facility_id_report_month?: FieldValueField_idFacility_idReport_monthCompoundUniqueInput
    AND?: FieldValueWhereInput | FieldValueWhereInput[]
    OR?: FieldValueWhereInput[]
    NOT?: FieldValueWhereInput | FieldValueWhereInput[]
    field_id?: IntFilter<"FieldValue"> | number
    report_month?: StringFilter<"FieldValue"> | string
    string_value?: StringNullableFilter<"FieldValue"> | string | null
    numeric_value?: DecimalNullableFilter<"FieldValue"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableFilter<"FieldValue"> | boolean | null
    json_value?: JsonNullableFilter<"FieldValue">
    uploaded_by?: IntFilter<"FieldValue"> | number
    remarks?: StringNullableFilter<"FieldValue"> | string | null
    created_at?: DateTimeFilter<"FieldValue"> | Date | string
    updated_at?: DateTimeFilter<"FieldValue"> | Date | string
    is_override?: BoolFilter<"FieldValue"> | boolean
    override_reason?: StringNullableFilter<"FieldValue"> | string | null
    facility_id?: StringNullableFilter<"FieldValue"> | string | null
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "field_id_facility_id_report_month">

  export type FieldValueOrderByWithAggregationInput = {
    id?: SortOrder
    field_id?: SortOrder
    report_month?: SortOrder
    string_value?: SortOrderInput | SortOrder
    numeric_value?: SortOrderInput | SortOrder
    boolean_value?: SortOrderInput | SortOrder
    json_value?: SortOrderInput | SortOrder
    uploaded_by?: SortOrder
    remarks?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_override?: SortOrder
    override_reason?: SortOrderInput | SortOrder
    facility_id?: SortOrderInput | SortOrder
    _count?: FieldValueCountOrderByAggregateInput
    _avg?: FieldValueAvgOrderByAggregateInput
    _max?: FieldValueMaxOrderByAggregateInput
    _min?: FieldValueMinOrderByAggregateInput
    _sum?: FieldValueSumOrderByAggregateInput
  }

  export type FieldValueScalarWhereWithAggregatesInput = {
    AND?: FieldValueScalarWhereWithAggregatesInput | FieldValueScalarWhereWithAggregatesInput[]
    OR?: FieldValueScalarWhereWithAggregatesInput[]
    NOT?: FieldValueScalarWhereWithAggregatesInput | FieldValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FieldValue"> | number
    field_id?: IntWithAggregatesFilter<"FieldValue"> | number
    report_month?: StringWithAggregatesFilter<"FieldValue"> | string
    string_value?: StringNullableWithAggregatesFilter<"FieldValue"> | string | null
    numeric_value?: DecimalNullableWithAggregatesFilter<"FieldValue"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableWithAggregatesFilter<"FieldValue"> | boolean | null
    json_value?: JsonNullableWithAggregatesFilter<"FieldValue">
    uploaded_by?: IntWithAggregatesFilter<"FieldValue"> | number
    remarks?: StringNullableWithAggregatesFilter<"FieldValue"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"FieldValue"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FieldValue"> | Date | string
    is_override?: BoolWithAggregatesFilter<"FieldValue"> | boolean
    override_reason?: StringNullableWithAggregatesFilter<"FieldValue"> | string | null
    facility_id?: StringNullableWithAggregatesFilter<"FieldValue"> | string | null
  }

  export type FacilityFieldDefaultsWhereInput = {
    AND?: FacilityFieldDefaultsWhereInput | FacilityFieldDefaultsWhereInput[]
    OR?: FacilityFieldDefaultsWhereInput[]
    NOT?: FacilityFieldDefaultsWhereInput | FacilityFieldDefaultsWhereInput[]
    id?: IntFilter<"FacilityFieldDefaults"> | number
    field_id?: IntFilter<"FacilityFieldDefaults"> | number
    string_value?: StringNullableFilter<"FacilityFieldDefaults"> | string | null
    numeric_value?: DecimalNullableFilter<"FacilityFieldDefaults"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableFilter<"FacilityFieldDefaults"> | boolean | null
    json_value?: JsonNullableFilter<"FacilityFieldDefaults">
    is_active?: BoolFilter<"FacilityFieldDefaults"> | boolean
    created_at?: DateTimeFilter<"FacilityFieldDefaults"> | Date | string
    updated_at?: DateTimeFilter<"FacilityFieldDefaults"> | Date | string
    facility_id?: StringFilter<"FacilityFieldDefaults"> | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
  }

  export type FacilityFieldDefaultsOrderByWithRelationInput = {
    id?: SortOrder
    field_id?: SortOrder
    string_value?: SortOrderInput | SortOrder
    numeric_value?: SortOrderInput | SortOrder
    boolean_value?: SortOrderInput | SortOrder
    json_value?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
  }

  export type FacilityFieldDefaultsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    field_id_facility_id?: FacilityFieldDefaultsField_idFacility_idCompoundUniqueInput
    AND?: FacilityFieldDefaultsWhereInput | FacilityFieldDefaultsWhereInput[]
    OR?: FacilityFieldDefaultsWhereInput[]
    NOT?: FacilityFieldDefaultsWhereInput | FacilityFieldDefaultsWhereInput[]
    field_id?: IntFilter<"FacilityFieldDefaults"> | number
    string_value?: StringNullableFilter<"FacilityFieldDefaults"> | string | null
    numeric_value?: DecimalNullableFilter<"FacilityFieldDefaults"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableFilter<"FacilityFieldDefaults"> | boolean | null
    json_value?: JsonNullableFilter<"FacilityFieldDefaults">
    is_active?: BoolFilter<"FacilityFieldDefaults"> | boolean
    created_at?: DateTimeFilter<"FacilityFieldDefaults"> | Date | string
    updated_at?: DateTimeFilter<"FacilityFieldDefaults"> | Date | string
    facility_id?: StringFilter<"FacilityFieldDefaults"> | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
  }, "id" | "field_id_facility_id">

  export type FacilityFieldDefaultsOrderByWithAggregationInput = {
    id?: SortOrder
    field_id?: SortOrder
    string_value?: SortOrderInput | SortOrder
    numeric_value?: SortOrderInput | SortOrder
    boolean_value?: SortOrderInput | SortOrder
    json_value?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
    _count?: FacilityFieldDefaultsCountOrderByAggregateInput
    _avg?: FacilityFieldDefaultsAvgOrderByAggregateInput
    _max?: FacilityFieldDefaultsMaxOrderByAggregateInput
    _min?: FacilityFieldDefaultsMinOrderByAggregateInput
    _sum?: FacilityFieldDefaultsSumOrderByAggregateInput
  }

  export type FacilityFieldDefaultsScalarWhereWithAggregatesInput = {
    AND?: FacilityFieldDefaultsScalarWhereWithAggregatesInput | FacilityFieldDefaultsScalarWhereWithAggregatesInput[]
    OR?: FacilityFieldDefaultsScalarWhereWithAggregatesInput[]
    NOT?: FacilityFieldDefaultsScalarWhereWithAggregatesInput | FacilityFieldDefaultsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacilityFieldDefaults"> | number
    field_id?: IntWithAggregatesFilter<"FacilityFieldDefaults"> | number
    string_value?: StringNullableWithAggregatesFilter<"FacilityFieldDefaults"> | string | null
    numeric_value?: DecimalNullableWithAggregatesFilter<"FacilityFieldDefaults"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableWithAggregatesFilter<"FacilityFieldDefaults"> | boolean | null
    json_value?: JsonNullableWithAggregatesFilter<"FacilityFieldDefaults">
    is_active?: BoolWithAggregatesFilter<"FacilityFieldDefaults"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"FacilityFieldDefaults"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FacilityFieldDefaults"> | Date | string
    facility_id?: StringWithAggregatesFilter<"FacilityFieldDefaults"> | string
  }

  export type FacilityFieldMappingWhereInput = {
    AND?: FacilityFieldMappingWhereInput | FacilityFieldMappingWhereInput[]
    OR?: FacilityFieldMappingWhereInput[]
    NOT?: FacilityFieldMappingWhereInput | FacilityFieldMappingWhereInput[]
    id?: IntFilter<"FacilityFieldMapping"> | number
    field_id?: IntFilter<"FacilityFieldMapping"> | number
    is_required?: BoolFilter<"FacilityFieldMapping"> | boolean
    display_order?: IntFilter<"FacilityFieldMapping"> | number
    created_at?: DateTimeFilter<"FacilityFieldMapping"> | Date | string
    updated_at?: DateTimeFilter<"FacilityFieldMapping"> | Date | string
    facility_type_id?: StringFilter<"FacilityFieldMapping"> | string
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
  }

  export type FacilityFieldMappingOrderByWithRelationInput = {
    id?: SortOrder
    field_id?: SortOrder
    is_required?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
    facility_type?: FacilityTypeOrderByWithRelationInput
    field?: FieldOrderByWithRelationInput
  }

  export type FacilityFieldMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_type_id_field_id?: FacilityFieldMappingFacility_type_idField_idCompoundUniqueInput
    AND?: FacilityFieldMappingWhereInput | FacilityFieldMappingWhereInput[]
    OR?: FacilityFieldMappingWhereInput[]
    NOT?: FacilityFieldMappingWhereInput | FacilityFieldMappingWhereInput[]
    field_id?: IntFilter<"FacilityFieldMapping"> | number
    is_required?: BoolFilter<"FacilityFieldMapping"> | boolean
    display_order?: IntFilter<"FacilityFieldMapping"> | number
    created_at?: DateTimeFilter<"FacilityFieldMapping"> | Date | string
    updated_at?: DateTimeFilter<"FacilityFieldMapping"> | Date | string
    facility_type_id?: StringFilter<"FacilityFieldMapping"> | string
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
    field?: XOR<FieldScalarRelationFilter, FieldWhereInput>
  }, "id" | "facility_type_id_field_id">

  export type FacilityFieldMappingOrderByWithAggregationInput = {
    id?: SortOrder
    field_id?: SortOrder
    is_required?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
    _count?: FacilityFieldMappingCountOrderByAggregateInput
    _avg?: FacilityFieldMappingAvgOrderByAggregateInput
    _max?: FacilityFieldMappingMaxOrderByAggregateInput
    _min?: FacilityFieldMappingMinOrderByAggregateInput
    _sum?: FacilityFieldMappingSumOrderByAggregateInput
  }

  export type FacilityFieldMappingScalarWhereWithAggregatesInput = {
    AND?: FacilityFieldMappingScalarWhereWithAggregatesInput | FacilityFieldMappingScalarWhereWithAggregatesInput[]
    OR?: FacilityFieldMappingScalarWhereWithAggregatesInput[]
    NOT?: FacilityFieldMappingScalarWhereWithAggregatesInput | FacilityFieldMappingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacilityFieldMapping"> | number
    field_id?: IntWithAggregatesFilter<"FacilityFieldMapping"> | number
    is_required?: BoolWithAggregatesFilter<"FacilityFieldMapping"> | boolean
    display_order?: IntWithAggregatesFilter<"FacilityFieldMapping"> | number
    created_at?: DateTimeWithAggregatesFilter<"FacilityFieldMapping"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FacilityFieldMapping"> | Date | string
    facility_type_id?: StringWithAggregatesFilter<"FacilityFieldMapping"> | string
  }

  export type sub_centreWhereInput = {
    AND?: sub_centreWhereInput | sub_centreWhereInput[]
    OR?: sub_centreWhereInput[]
    NOT?: sub_centreWhereInput | sub_centreWhereInput[]
    id?: IntFilter<"sub_centre"> | number
    name?: StringFilter<"sub_centre"> | string
    created_at?: DateTimeFilter<"sub_centre"> | Date | string
    updated_at?: DateTimeFilter<"sub_centre"> | Date | string
    facility_id?: StringFilter<"sub_centre"> | string
    monthly_health_data?: MonthlyHealthDataListRelationFilter
    performance_calculations?: PerformanceCalculationListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
  }

  export type sub_centreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
    monthly_health_data?: MonthlyHealthDataOrderByRelationAggregateInput
    performance_calculations?: PerformanceCalculationOrderByRelationAggregateInput
    facility?: FacilityOrderByWithRelationInput
  }

  export type sub_centreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sub_centreWhereInput | sub_centreWhereInput[]
    OR?: sub_centreWhereInput[]
    NOT?: sub_centreWhereInput | sub_centreWhereInput[]
    name?: StringFilter<"sub_centre"> | string
    created_at?: DateTimeFilter<"sub_centre"> | Date | string
    updated_at?: DateTimeFilter<"sub_centre"> | Date | string
    facility_id?: StringFilter<"sub_centre"> | string
    monthly_health_data?: MonthlyHealthDataListRelationFilter
    performance_calculations?: PerformanceCalculationListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
  }, "id">

  export type sub_centreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
    _count?: sub_centreCountOrderByAggregateInput
    _avg?: sub_centreAvgOrderByAggregateInput
    _max?: sub_centreMaxOrderByAggregateInput
    _min?: sub_centreMinOrderByAggregateInput
    _sum?: sub_centreSumOrderByAggregateInput
  }

  export type sub_centreScalarWhereWithAggregatesInput = {
    AND?: sub_centreScalarWhereWithAggregatesInput | sub_centreScalarWhereWithAggregatesInput[]
    OR?: sub_centreScalarWhereWithAggregatesInput[]
    NOT?: sub_centreScalarWhereWithAggregatesInput | sub_centreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sub_centre"> | number
    name?: StringWithAggregatesFilter<"sub_centre"> | string
    created_at?: DateTimeWithAggregatesFilter<"sub_centre"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"sub_centre"> | Date | string
    facility_id?: StringWithAggregatesFilter<"sub_centre"> | string
  }

  export type HealthWorkerWhereInput = {
    AND?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    OR?: HealthWorkerWhereInput[]
    NOT?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    id?: IntFilter<"HealthWorker"> | number
    facility_id?: StringFilter<"HealthWorker"> | string
    name?: StringFilter<"HealthWorker"> | string
    worker_type?: StringFilter<"HealthWorker"> | string
    allocated_amount?: DecimalFilter<"HealthWorker"> | Decimal | DecimalJsLike | number | string
    contact_number?: StringNullableFilter<"HealthWorker"> | string | null
    email?: StringNullableFilter<"HealthWorker"> | string | null
    is_active?: BoolFilter<"HealthWorker"> | boolean
    created_at?: DateTimeFilter<"HealthWorker"> | Date | string
    updated_at?: DateTimeFilter<"HealthWorker"> | Date | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    remuneration_calculations?: WorkerRemunerationListRelationFilter
  }

  export type HealthWorkerOrderByWithRelationInput = {
    id?: SortOrder
    facility_id?: SortOrder
    name?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    contact_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    remuneration_calculations?: WorkerRemunerationOrderByRelationAggregateInput
  }

  export type HealthWorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    OR?: HealthWorkerWhereInput[]
    NOT?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    facility_id?: StringFilter<"HealthWorker"> | string
    name?: StringFilter<"HealthWorker"> | string
    worker_type?: StringFilter<"HealthWorker"> | string
    allocated_amount?: DecimalFilter<"HealthWorker"> | Decimal | DecimalJsLike | number | string
    contact_number?: StringNullableFilter<"HealthWorker"> | string | null
    email?: StringNullableFilter<"HealthWorker"> | string | null
    is_active?: BoolFilter<"HealthWorker"> | boolean
    created_at?: DateTimeFilter<"HealthWorker"> | Date | string
    updated_at?: DateTimeFilter<"HealthWorker"> | Date | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    remuneration_calculations?: WorkerRemunerationListRelationFilter
  }, "id">

  export type HealthWorkerOrderByWithAggregationInput = {
    id?: SortOrder
    facility_id?: SortOrder
    name?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    contact_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: HealthWorkerCountOrderByAggregateInput
    _avg?: HealthWorkerAvgOrderByAggregateInput
    _max?: HealthWorkerMaxOrderByAggregateInput
    _min?: HealthWorkerMinOrderByAggregateInput
    _sum?: HealthWorkerSumOrderByAggregateInput
  }

  export type HealthWorkerScalarWhereWithAggregatesInput = {
    AND?: HealthWorkerScalarWhereWithAggregatesInput | HealthWorkerScalarWhereWithAggregatesInput[]
    OR?: HealthWorkerScalarWhereWithAggregatesInput[]
    NOT?: HealthWorkerScalarWhereWithAggregatesInput | HealthWorkerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthWorker"> | number
    facility_id?: StringWithAggregatesFilter<"HealthWorker"> | string
    name?: StringWithAggregatesFilter<"HealthWorker"> | string
    worker_type?: StringWithAggregatesFilter<"HealthWorker"> | string
    allocated_amount?: DecimalWithAggregatesFilter<"HealthWorker"> | Decimal | DecimalJsLike | number | string
    contact_number?: StringNullableWithAggregatesFilter<"HealthWorker"> | string | null
    email?: StringNullableWithAggregatesFilter<"HealthWorker"> | string | null
    is_active?: BoolWithAggregatesFilter<"HealthWorker"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"HealthWorker"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"HealthWorker"> | Date | string
  }

  export type RemunerationCalculationWhereInput = {
    AND?: RemunerationCalculationWhereInput | RemunerationCalculationWhereInput[]
    OR?: RemunerationCalculationWhereInput[]
    NOT?: RemunerationCalculationWhereInput | RemunerationCalculationWhereInput[]
    id?: IntFilter<"RemunerationCalculation"> | number
    facility_id?: StringFilter<"RemunerationCalculation"> | string
    report_month?: StringFilter<"RemunerationCalculation"> | string
    performance_percentage?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFilter<"RemunerationCalculation"> | number
    asha_workers_count?: IntFilter<"RemunerationCalculation"> | number
    calculated_at?: DateTimeFilter<"RemunerationCalculation"> | Date | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
  }

  export type RemunerationCalculationOrderByWithRelationInput = {
    id?: SortOrder
    facility_id?: SortOrder
    report_month?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
    calculated_at?: SortOrder
    facility?: FacilityOrderByWithRelationInput
  }

  export type RemunerationCalculationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_id_report_month?: RemunerationCalculationFacility_idReport_monthCompoundUniqueInput
    AND?: RemunerationCalculationWhereInput | RemunerationCalculationWhereInput[]
    OR?: RemunerationCalculationWhereInput[]
    NOT?: RemunerationCalculationWhereInput | RemunerationCalculationWhereInput[]
    facility_id?: StringFilter<"RemunerationCalculation"> | string
    report_month?: StringFilter<"RemunerationCalculation"> | string
    performance_percentage?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFilter<"RemunerationCalculation"> | number
    asha_workers_count?: IntFilter<"RemunerationCalculation"> | number
    calculated_at?: DateTimeFilter<"RemunerationCalculation"> | Date | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
  }, "id" | "facility_id_report_month">

  export type RemunerationCalculationOrderByWithAggregationInput = {
    id?: SortOrder
    facility_id?: SortOrder
    report_month?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
    calculated_at?: SortOrder
    _count?: RemunerationCalculationCountOrderByAggregateInput
    _avg?: RemunerationCalculationAvgOrderByAggregateInput
    _max?: RemunerationCalculationMaxOrderByAggregateInput
    _min?: RemunerationCalculationMinOrderByAggregateInput
    _sum?: RemunerationCalculationSumOrderByAggregateInput
  }

  export type RemunerationCalculationScalarWhereWithAggregatesInput = {
    AND?: RemunerationCalculationScalarWhereWithAggregatesInput | RemunerationCalculationScalarWhereWithAggregatesInput[]
    OR?: RemunerationCalculationScalarWhereWithAggregatesInput[]
    NOT?: RemunerationCalculationScalarWhereWithAggregatesInput | RemunerationCalculationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RemunerationCalculation"> | number
    facility_id?: StringWithAggregatesFilter<"RemunerationCalculation"> | string
    report_month?: StringWithAggregatesFilter<"RemunerationCalculation"> | string
    performance_percentage?: DecimalWithAggregatesFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalWithAggregatesFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalWithAggregatesFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalWithAggregatesFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntWithAggregatesFilter<"RemunerationCalculation"> | number
    asha_workers_count?: IntWithAggregatesFilter<"RemunerationCalculation"> | number
    calculated_at?: DateTimeWithAggregatesFilter<"RemunerationCalculation"> | Date | string
  }

  export type WorkerRemunerationWhereInput = {
    AND?: WorkerRemunerationWhereInput | WorkerRemunerationWhereInput[]
    OR?: WorkerRemunerationWhereInput[]
    NOT?: WorkerRemunerationWhereInput | WorkerRemunerationWhereInput[]
    id?: IntFilter<"WorkerRemuneration"> | number
    health_worker_id?: IntFilter<"WorkerRemuneration"> | number
    report_month?: StringFilter<"WorkerRemuneration"> | string
    allocated_amount?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFilter<"WorkerRemuneration"> | Date | string
    health_worker?: XOR<HealthWorkerScalarRelationFilter, HealthWorkerWhereInput>
  }

  export type WorkerRemunerationOrderByWithRelationInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    report_month?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
    calculated_at?: SortOrder
    health_worker?: HealthWorkerOrderByWithRelationInput
  }

  export type WorkerRemunerationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    health_worker_id_report_month?: WorkerRemunerationHealth_worker_idReport_monthCompoundUniqueInput
    AND?: WorkerRemunerationWhereInput | WorkerRemunerationWhereInput[]
    OR?: WorkerRemunerationWhereInput[]
    NOT?: WorkerRemunerationWhereInput | WorkerRemunerationWhereInput[]
    health_worker_id?: IntFilter<"WorkerRemuneration"> | number
    report_month?: StringFilter<"WorkerRemuneration"> | string
    allocated_amount?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFilter<"WorkerRemuneration"> | Date | string
    health_worker?: XOR<HealthWorkerScalarRelationFilter, HealthWorkerWhereInput>
  }, "id" | "health_worker_id_report_month">

  export type WorkerRemunerationOrderByWithAggregationInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    report_month?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
    calculated_at?: SortOrder
    _count?: WorkerRemunerationCountOrderByAggregateInput
    _avg?: WorkerRemunerationAvgOrderByAggregateInput
    _max?: WorkerRemunerationMaxOrderByAggregateInput
    _min?: WorkerRemunerationMinOrderByAggregateInput
    _sum?: WorkerRemunerationSumOrderByAggregateInput
  }

  export type WorkerRemunerationScalarWhereWithAggregatesInput = {
    AND?: WorkerRemunerationScalarWhereWithAggregatesInput | WorkerRemunerationScalarWhereWithAggregatesInput[]
    OR?: WorkerRemunerationScalarWhereWithAggregatesInput[]
    NOT?: WorkerRemunerationScalarWhereWithAggregatesInput | WorkerRemunerationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkerRemuneration"> | number
    health_worker_id?: IntWithAggregatesFilter<"WorkerRemuneration"> | number
    report_month?: StringWithAggregatesFilter<"WorkerRemuneration"> | string
    allocated_amount?: DecimalWithAggregatesFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalWithAggregatesFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalWithAggregatesFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeWithAggregatesFilter<"WorkerRemuneration"> | Date | string
  }

  export type WorkerAllocationConfigWhereInput = {
    AND?: WorkerAllocationConfigWhereInput | WorkerAllocationConfigWhereInput[]
    OR?: WorkerAllocationConfigWhereInput[]
    NOT?: WorkerAllocationConfigWhereInput | WorkerAllocationConfigWhereInput[]
    id?: IntFilter<"WorkerAllocationConfig"> | number
    facility_type_id?: StringFilter<"WorkerAllocationConfig"> | string
    worker_type?: StringFilter<"WorkerAllocationConfig"> | string
    worker_role?: StringFilter<"WorkerAllocationConfig"> | string
    max_count?: IntFilter<"WorkerAllocationConfig"> | number
    allocated_amount?: DecimalFilter<"WorkerAllocationConfig"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WorkerAllocationConfig"> | string | null
    is_active?: BoolFilter<"WorkerAllocationConfig"> | boolean
    created_at?: DateTimeFilter<"WorkerAllocationConfig"> | Date | string
    updated_at?: DateTimeFilter<"WorkerAllocationConfig"> | Date | string
    facility_allocations?: FacilityWorkerAllocationListRelationFilter
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
  }

  export type WorkerAllocationConfigOrderByWithRelationInput = {
    id?: SortOrder
    facility_type_id?: SortOrder
    worker_type?: SortOrder
    worker_role?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_allocations?: FacilityWorkerAllocationOrderByRelationAggregateInput
    facility_type?: FacilityTypeOrderByWithRelationInput
  }

  export type WorkerAllocationConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_type_id_worker_type_worker_role?: WorkerAllocationConfigFacility_type_idWorker_typeWorker_roleCompoundUniqueInput
    AND?: WorkerAllocationConfigWhereInput | WorkerAllocationConfigWhereInput[]
    OR?: WorkerAllocationConfigWhereInput[]
    NOT?: WorkerAllocationConfigWhereInput | WorkerAllocationConfigWhereInput[]
    facility_type_id?: StringFilter<"WorkerAllocationConfig"> | string
    worker_type?: StringFilter<"WorkerAllocationConfig"> | string
    worker_role?: StringFilter<"WorkerAllocationConfig"> | string
    max_count?: IntFilter<"WorkerAllocationConfig"> | number
    allocated_amount?: DecimalFilter<"WorkerAllocationConfig"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WorkerAllocationConfig"> | string | null
    is_active?: BoolFilter<"WorkerAllocationConfig"> | boolean
    created_at?: DateTimeFilter<"WorkerAllocationConfig"> | Date | string
    updated_at?: DateTimeFilter<"WorkerAllocationConfig"> | Date | string
    facility_allocations?: FacilityWorkerAllocationListRelationFilter
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
  }, "id" | "facility_type_id_worker_type_worker_role">

  export type WorkerAllocationConfigOrderByWithAggregationInput = {
    id?: SortOrder
    facility_type_id?: SortOrder
    worker_type?: SortOrder
    worker_role?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
    description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WorkerAllocationConfigCountOrderByAggregateInput
    _avg?: WorkerAllocationConfigAvgOrderByAggregateInput
    _max?: WorkerAllocationConfigMaxOrderByAggregateInput
    _min?: WorkerAllocationConfigMinOrderByAggregateInput
    _sum?: WorkerAllocationConfigSumOrderByAggregateInput
  }

  export type WorkerAllocationConfigScalarWhereWithAggregatesInput = {
    AND?: WorkerAllocationConfigScalarWhereWithAggregatesInput | WorkerAllocationConfigScalarWhereWithAggregatesInput[]
    OR?: WorkerAllocationConfigScalarWhereWithAggregatesInput[]
    NOT?: WorkerAllocationConfigScalarWhereWithAggregatesInput | WorkerAllocationConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkerAllocationConfig"> | number
    facility_type_id?: StringWithAggregatesFilter<"WorkerAllocationConfig"> | string
    worker_type?: StringWithAggregatesFilter<"WorkerAllocationConfig"> | string
    worker_role?: StringWithAggregatesFilter<"WorkerAllocationConfig"> | string
    max_count?: IntWithAggregatesFilter<"WorkerAllocationConfig"> | number
    allocated_amount?: DecimalWithAggregatesFilter<"WorkerAllocationConfig"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"WorkerAllocationConfig"> | string | null
    is_active?: BoolWithAggregatesFilter<"WorkerAllocationConfig"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"WorkerAllocationConfig"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"WorkerAllocationConfig"> | Date | string
  }

  export type FacilityWorkerAllocationWhereInput = {
    AND?: FacilityWorkerAllocationWhereInput | FacilityWorkerAllocationWhereInput[]
    OR?: FacilityWorkerAllocationWhereInput[]
    NOT?: FacilityWorkerAllocationWhereInput | FacilityWorkerAllocationWhereInput[]
    id?: IntFilter<"FacilityWorkerAllocation"> | number
    facility_id?: StringFilter<"FacilityWorkerAllocation"> | string
    worker_allocation_config_id?: IntFilter<"FacilityWorkerAllocation"> | number
    worker_count?: IntFilter<"FacilityWorkerAllocation"> | number
    total_allocated_amount?: DecimalFilter<"FacilityWorkerAllocation"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"FacilityWorkerAllocation"> | boolean
    created_at?: DateTimeFilter<"FacilityWorkerAllocation"> | Date | string
    updated_at?: DateTimeFilter<"FacilityWorkerAllocation"> | Date | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    worker_allocation_config?: XOR<WorkerAllocationConfigScalarRelationFilter, WorkerAllocationConfigWhereInput>
  }

  export type FacilityWorkerAllocationOrderByWithRelationInput = {
    id?: SortOrder
    facility_id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    worker_allocation_config?: WorkerAllocationConfigOrderByWithRelationInput
  }

  export type FacilityWorkerAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_id_worker_allocation_config_id?: FacilityWorkerAllocationFacility_idWorker_allocation_config_idCompoundUniqueInput
    AND?: FacilityWorkerAllocationWhereInput | FacilityWorkerAllocationWhereInput[]
    OR?: FacilityWorkerAllocationWhereInput[]
    NOT?: FacilityWorkerAllocationWhereInput | FacilityWorkerAllocationWhereInput[]
    facility_id?: StringFilter<"FacilityWorkerAllocation"> | string
    worker_allocation_config_id?: IntFilter<"FacilityWorkerAllocation"> | number
    worker_count?: IntFilter<"FacilityWorkerAllocation"> | number
    total_allocated_amount?: DecimalFilter<"FacilityWorkerAllocation"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"FacilityWorkerAllocation"> | boolean
    created_at?: DateTimeFilter<"FacilityWorkerAllocation"> | Date | string
    updated_at?: DateTimeFilter<"FacilityWorkerAllocation"> | Date | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    worker_allocation_config?: XOR<WorkerAllocationConfigScalarRelationFilter, WorkerAllocationConfigWhereInput>
  }, "id" | "facility_id_worker_allocation_config_id">

  export type FacilityWorkerAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    facility_id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FacilityWorkerAllocationCountOrderByAggregateInput
    _avg?: FacilityWorkerAllocationAvgOrderByAggregateInput
    _max?: FacilityWorkerAllocationMaxOrderByAggregateInput
    _min?: FacilityWorkerAllocationMinOrderByAggregateInput
    _sum?: FacilityWorkerAllocationSumOrderByAggregateInput
  }

  export type FacilityWorkerAllocationScalarWhereWithAggregatesInput = {
    AND?: FacilityWorkerAllocationScalarWhereWithAggregatesInput | FacilityWorkerAllocationScalarWhereWithAggregatesInput[]
    OR?: FacilityWorkerAllocationScalarWhereWithAggregatesInput[]
    NOT?: FacilityWorkerAllocationScalarWhereWithAggregatesInput | FacilityWorkerAllocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacilityWorkerAllocation"> | number
    facility_id?: StringWithAggregatesFilter<"FacilityWorkerAllocation"> | string
    worker_allocation_config_id?: IntWithAggregatesFilter<"FacilityWorkerAllocation"> | number
    worker_count?: IntWithAggregatesFilter<"FacilityWorkerAllocation"> | number
    total_allocated_amount?: DecimalWithAggregatesFilter<"FacilityWorkerAllocation"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolWithAggregatesFilter<"FacilityWorkerAllocation"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"FacilityWorkerAllocation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FacilityWorkerAllocation"> | Date | string
  }

  export type FacilityTypeRemunerationWhereInput = {
    AND?: FacilityTypeRemunerationWhereInput | FacilityTypeRemunerationWhereInput[]
    OR?: FacilityTypeRemunerationWhereInput[]
    NOT?: FacilityTypeRemunerationWhereInput | FacilityTypeRemunerationWhereInput[]
    id?: IntFilter<"FacilityTypeRemuneration"> | number
    total_amount?: DecimalFilter<"FacilityTypeRemuneration"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFilter<"FacilityTypeRemuneration"> | Date | string
    effective_to?: DateTimeNullableFilter<"FacilityTypeRemuneration"> | Date | string | null
    created_at?: DateTimeFilter<"FacilityTypeRemuneration"> | Date | string
    updated_at?: DateTimeFilter<"FacilityTypeRemuneration"> | Date | string
    facility_type_id?: StringFilter<"FacilityTypeRemuneration"> | string
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
    indicator_remunerations?: IndicatorRemunerationListRelationFilter
  }

  export type FacilityTypeRemunerationOrderByWithRelationInput = {
    id?: SortOrder
    total_amount?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
    facility_type?: FacilityTypeOrderByWithRelationInput
    indicator_remunerations?: IndicatorRemunerationOrderByRelationAggregateInput
  }

  export type FacilityTypeRemunerationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_type_id?: string
    AND?: FacilityTypeRemunerationWhereInput | FacilityTypeRemunerationWhereInput[]
    OR?: FacilityTypeRemunerationWhereInput[]
    NOT?: FacilityTypeRemunerationWhereInput | FacilityTypeRemunerationWhereInput[]
    total_amount?: DecimalFilter<"FacilityTypeRemuneration"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFilter<"FacilityTypeRemuneration"> | Date | string
    effective_to?: DateTimeNullableFilter<"FacilityTypeRemuneration"> | Date | string | null
    created_at?: DateTimeFilter<"FacilityTypeRemuneration"> | Date | string
    updated_at?: DateTimeFilter<"FacilityTypeRemuneration"> | Date | string
    facility_type?: XOR<FacilityTypeScalarRelationFilter, FacilityTypeWhereInput>
    indicator_remunerations?: IndicatorRemunerationListRelationFilter
  }, "id" | "facility_type_id">

  export type FacilityTypeRemunerationOrderByWithAggregationInput = {
    id?: SortOrder
    total_amount?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
    _count?: FacilityTypeRemunerationCountOrderByAggregateInput
    _avg?: FacilityTypeRemunerationAvgOrderByAggregateInput
    _max?: FacilityTypeRemunerationMaxOrderByAggregateInput
    _min?: FacilityTypeRemunerationMinOrderByAggregateInput
    _sum?: FacilityTypeRemunerationSumOrderByAggregateInput
  }

  export type FacilityTypeRemunerationScalarWhereWithAggregatesInput = {
    AND?: FacilityTypeRemunerationScalarWhereWithAggregatesInput | FacilityTypeRemunerationScalarWhereWithAggregatesInput[]
    OR?: FacilityTypeRemunerationScalarWhereWithAggregatesInput[]
    NOT?: FacilityTypeRemunerationScalarWhereWithAggregatesInput | FacilityTypeRemunerationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacilityTypeRemuneration"> | number
    total_amount?: DecimalWithAggregatesFilter<"FacilityTypeRemuneration"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeWithAggregatesFilter<"FacilityTypeRemuneration"> | Date | string
    effective_to?: DateTimeNullableWithAggregatesFilter<"FacilityTypeRemuneration"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"FacilityTypeRemuneration"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FacilityTypeRemuneration"> | Date | string
    facility_type_id?: StringWithAggregatesFilter<"FacilityTypeRemuneration"> | string
  }

  export type IndicatorRemunerationWhereInput = {
    AND?: IndicatorRemunerationWhereInput | IndicatorRemunerationWhereInput[]
    OR?: IndicatorRemunerationWhereInput[]
    NOT?: IndicatorRemunerationWhereInput | IndicatorRemunerationWhereInput[]
    id?: IntFilter<"IndicatorRemuneration"> | number
    facility_type_remuneration_id?: IntFilter<"IndicatorRemuneration"> | number
    indicator_id?: IntFilter<"IndicatorRemuneration"> | number
    base_amount?: DecimalFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string
    conditional_amount?: DecimalNullableFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string | null
    condition_type?: StringNullableFilter<"IndicatorRemuneration"> | string | null
    created_at?: DateTimeFilter<"IndicatorRemuneration"> | Date | string
    updated_at?: DateTimeFilter<"IndicatorRemuneration"> | Date | string
    remuneration_system_id?: StringNullableFilter<"IndicatorRemuneration"> | string | null
    facility_type_remuneration?: XOR<FacilityTypeRemunerationScalarRelationFilter, FacilityTypeRemunerationWhereInput>
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    remuneration_system?: XOR<RemunerationSystemNullableScalarRelationFilter, RemunerationSystemWhereInput> | null
  }

  export type IndicatorRemunerationOrderByWithRelationInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrderInput | SortOrder
    condition_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    remuneration_system_id?: SortOrderInput | SortOrder
    facility_type_remuneration?: FacilityTypeRemunerationOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
    remuneration_system?: RemunerationSystemOrderByWithRelationInput
  }

  export type IndicatorRemunerationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_type_remuneration_id_indicator_id?: IndicatorRemunerationFacility_type_remuneration_idIndicator_idCompoundUniqueInput
    AND?: IndicatorRemunerationWhereInput | IndicatorRemunerationWhereInput[]
    OR?: IndicatorRemunerationWhereInput[]
    NOT?: IndicatorRemunerationWhereInput | IndicatorRemunerationWhereInput[]
    facility_type_remuneration_id?: IntFilter<"IndicatorRemuneration"> | number
    indicator_id?: IntFilter<"IndicatorRemuneration"> | number
    base_amount?: DecimalFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string
    conditional_amount?: DecimalNullableFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string | null
    condition_type?: StringNullableFilter<"IndicatorRemuneration"> | string | null
    created_at?: DateTimeFilter<"IndicatorRemuneration"> | Date | string
    updated_at?: DateTimeFilter<"IndicatorRemuneration"> | Date | string
    remuneration_system_id?: StringNullableFilter<"IndicatorRemuneration"> | string | null
    facility_type_remuneration?: XOR<FacilityTypeRemunerationScalarRelationFilter, FacilityTypeRemunerationWhereInput>
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    remuneration_system?: XOR<RemunerationSystemNullableScalarRelationFilter, RemunerationSystemWhereInput> | null
  }, "id" | "facility_type_remuneration_id_indicator_id">

  export type IndicatorRemunerationOrderByWithAggregationInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrderInput | SortOrder
    condition_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    remuneration_system_id?: SortOrderInput | SortOrder
    _count?: IndicatorRemunerationCountOrderByAggregateInput
    _avg?: IndicatorRemunerationAvgOrderByAggregateInput
    _max?: IndicatorRemunerationMaxOrderByAggregateInput
    _min?: IndicatorRemunerationMinOrderByAggregateInput
    _sum?: IndicatorRemunerationSumOrderByAggregateInput
  }

  export type IndicatorRemunerationScalarWhereWithAggregatesInput = {
    AND?: IndicatorRemunerationScalarWhereWithAggregatesInput | IndicatorRemunerationScalarWhereWithAggregatesInput[]
    OR?: IndicatorRemunerationScalarWhereWithAggregatesInput[]
    NOT?: IndicatorRemunerationScalarWhereWithAggregatesInput | IndicatorRemunerationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IndicatorRemuneration"> | number
    facility_type_remuneration_id?: IntWithAggregatesFilter<"IndicatorRemuneration"> | number
    indicator_id?: IntWithAggregatesFilter<"IndicatorRemuneration"> | number
    base_amount?: DecimalWithAggregatesFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string
    conditional_amount?: DecimalNullableWithAggregatesFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string | null
    condition_type?: StringNullableWithAggregatesFilter<"IndicatorRemuneration"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"IndicatorRemuneration"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"IndicatorRemuneration"> | Date | string
    remuneration_system_id?: StringNullableWithAggregatesFilter<"IndicatorRemuneration"> | string | null
  }

  export type PerformanceCalculationWhereInput = {
    AND?: PerformanceCalculationWhereInput | PerformanceCalculationWhereInput[]
    OR?: PerformanceCalculationWhereInput[]
    NOT?: PerformanceCalculationWhereInput | PerformanceCalculationWhereInput[]
    id?: IntFilter<"PerformanceCalculation"> | number
    sub_centre_id?: IntNullableFilter<"PerformanceCalculation"> | number | null
    indicator_id?: IntFilter<"PerformanceCalculation"> | number
    report_month?: StringFilter<"PerformanceCalculation"> | string
    numerator?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    achievement?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFilter<"PerformanceCalculation"> | Date | string
    facility_id?: StringNullableFilter<"PerformanceCalculation"> | string | null
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    sub_centre?: XOR<Sub_centreNullableScalarRelationFilter, sub_centreWhereInput> | null
  }

  export type PerformanceCalculationOrderByWithRelationInput = {
    id?: SortOrder
    sub_centre_id?: SortOrderInput | SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    numerator?: SortOrderInput | SortOrder
    denominator?: SortOrderInput | SortOrder
    achievement?: SortOrderInput | SortOrder
    target_value?: SortOrderInput | SortOrder
    remuneration_amount?: SortOrderInput | SortOrder
    calculated_at?: SortOrder
    facility_id?: SortOrderInput | SortOrder
    facility?: FacilityOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
    sub_centre?: sub_centreOrderByWithRelationInput
  }

  export type PerformanceCalculationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_id_sub_centre_id_indicator_id_report_month?: PerformanceCalculationFacility_idSub_centre_idIndicator_idReport_monthCompoundUniqueInput
    AND?: PerformanceCalculationWhereInput | PerformanceCalculationWhereInput[]
    OR?: PerformanceCalculationWhereInput[]
    NOT?: PerformanceCalculationWhereInput | PerformanceCalculationWhereInput[]
    sub_centre_id?: IntNullableFilter<"PerformanceCalculation"> | number | null
    indicator_id?: IntFilter<"PerformanceCalculation"> | number
    report_month?: StringFilter<"PerformanceCalculation"> | string
    numerator?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    achievement?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFilter<"PerformanceCalculation"> | Date | string
    facility_id?: StringNullableFilter<"PerformanceCalculation"> | string | null
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
    sub_centre?: XOR<Sub_centreNullableScalarRelationFilter, sub_centreWhereInput> | null
  }, "id" | "facility_id_sub_centre_id_indicator_id_report_month">

  export type PerformanceCalculationOrderByWithAggregationInput = {
    id?: SortOrder
    sub_centre_id?: SortOrderInput | SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    numerator?: SortOrderInput | SortOrder
    denominator?: SortOrderInput | SortOrder
    achievement?: SortOrderInput | SortOrder
    target_value?: SortOrderInput | SortOrder
    remuneration_amount?: SortOrderInput | SortOrder
    calculated_at?: SortOrder
    facility_id?: SortOrderInput | SortOrder
    _count?: PerformanceCalculationCountOrderByAggregateInput
    _avg?: PerformanceCalculationAvgOrderByAggregateInput
    _max?: PerformanceCalculationMaxOrderByAggregateInput
    _min?: PerformanceCalculationMinOrderByAggregateInput
    _sum?: PerformanceCalculationSumOrderByAggregateInput
  }

  export type PerformanceCalculationScalarWhereWithAggregatesInput = {
    AND?: PerformanceCalculationScalarWhereWithAggregatesInput | PerformanceCalculationScalarWhereWithAggregatesInput[]
    OR?: PerformanceCalculationScalarWhereWithAggregatesInput[]
    NOT?: PerformanceCalculationScalarWhereWithAggregatesInput | PerformanceCalculationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceCalculation"> | number
    sub_centre_id?: IntNullableWithAggregatesFilter<"PerformanceCalculation"> | number | null
    indicator_id?: IntWithAggregatesFilter<"PerformanceCalculation"> | number
    report_month?: StringWithAggregatesFilter<"PerformanceCalculation"> | string
    numerator?: DecimalNullableWithAggregatesFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableWithAggregatesFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    achievement?: DecimalNullableWithAggregatesFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableWithAggregatesFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: DecimalNullableWithAggregatesFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeWithAggregatesFilter<"PerformanceCalculation"> | Date | string
    facility_id?: StringNullableWithAggregatesFilter<"PerformanceCalculation"> | string | null
  }

  export type FacilityTargetWhereInput = {
    AND?: FacilityTargetWhereInput | FacilityTargetWhereInput[]
    OR?: FacilityTargetWhereInput[]
    NOT?: FacilityTargetWhereInput | FacilityTargetWhereInput[]
    id?: IntFilter<"FacilityTarget"> | number
    indicator_id?: IntFilter<"FacilityTarget"> | number
    report_month?: StringFilter<"FacilityTarget"> | string
    target_value?: DecimalFilter<"FacilityTarget"> | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFilter<"FacilityTarget"> | string
    denominator_label?: StringFilter<"FacilityTarget"> | string
    created_at?: DateTimeFilter<"FacilityTarget"> | Date | string
    updated_at?: DateTimeFilter<"FacilityTarget"> | Date | string
    facility_id?: StringFilter<"FacilityTarget"> | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
  }

  export type FacilityTargetOrderByWithRelationInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    target_value?: SortOrder
    numerator_label?: SortOrder
    denominator_label?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    indicator?: IndicatorOrderByWithRelationInput
  }

  export type FacilityTargetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    facility_id_indicator_id_report_month?: FacilityTargetFacility_idIndicator_idReport_monthCompoundUniqueInput
    AND?: FacilityTargetWhereInput | FacilityTargetWhereInput[]
    OR?: FacilityTargetWhereInput[]
    NOT?: FacilityTargetWhereInput | FacilityTargetWhereInput[]
    indicator_id?: IntFilter<"FacilityTarget"> | number
    report_month?: StringFilter<"FacilityTarget"> | string
    target_value?: DecimalFilter<"FacilityTarget"> | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFilter<"FacilityTarget"> | string
    denominator_label?: StringFilter<"FacilityTarget"> | string
    created_at?: DateTimeFilter<"FacilityTarget"> | Date | string
    updated_at?: DateTimeFilter<"FacilityTarget"> | Date | string
    facility_id?: StringFilter<"FacilityTarget"> | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
  }, "id" | "facility_id_indicator_id_report_month">

  export type FacilityTargetOrderByWithAggregationInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    target_value?: SortOrder
    numerator_label?: SortOrder
    denominator_label?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
    _count?: FacilityTargetCountOrderByAggregateInput
    _avg?: FacilityTargetAvgOrderByAggregateInput
    _max?: FacilityTargetMaxOrderByAggregateInput
    _min?: FacilityTargetMinOrderByAggregateInput
    _sum?: FacilityTargetSumOrderByAggregateInput
  }

  export type FacilityTargetScalarWhereWithAggregatesInput = {
    AND?: FacilityTargetScalarWhereWithAggregatesInput | FacilityTargetScalarWhereWithAggregatesInput[]
    OR?: FacilityTargetScalarWhereWithAggregatesInput[]
    NOT?: FacilityTargetScalarWhereWithAggregatesInput | FacilityTargetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FacilityTarget"> | number
    indicator_id?: IntWithAggregatesFilter<"FacilityTarget"> | number
    report_month?: StringWithAggregatesFilter<"FacilityTarget"> | string
    target_value?: DecimalWithAggregatesFilter<"FacilityTarget"> | Decimal | DecimalJsLike | number | string
    numerator_label?: StringWithAggregatesFilter<"FacilityTarget"> | string
    denominator_label?: StringWithAggregatesFilter<"FacilityTarget"> | string
    created_at?: DateTimeWithAggregatesFilter<"FacilityTarget"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FacilityTarget"> | Date | string
    facility_id?: StringWithAggregatesFilter<"FacilityTarget"> | string
  }

  export type IndicatorWorkerAllocationWhereInput = {
    AND?: IndicatorWorkerAllocationWhereInput | IndicatorWorkerAllocationWhereInput[]
    OR?: IndicatorWorkerAllocationWhereInput[]
    NOT?: IndicatorWorkerAllocationWhereInput | IndicatorWorkerAllocationWhereInput[]
    id?: StringFilter<"IndicatorWorkerAllocation"> | string
    indicator_id?: IntFilter<"IndicatorWorkerAllocation"> | number
    worker_type?: StringFilter<"IndicatorWorkerAllocation"> | string
    allocated_amount?: IntFilter<"IndicatorWorkerAllocation"> | number
    created_at?: DateTimeFilter<"IndicatorWorkerAllocation"> | Date | string
    updated_at?: DateTimeFilter<"IndicatorWorkerAllocation"> | Date | string
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
  }

  export type IndicatorWorkerAllocationOrderByWithRelationInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    indicator?: IndicatorOrderByWithRelationInput
  }

  export type IndicatorWorkerAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    indicator_id_worker_type?: IndicatorWorkerAllocationIndicator_idWorker_typeCompoundUniqueInput
    AND?: IndicatorWorkerAllocationWhereInput | IndicatorWorkerAllocationWhereInput[]
    OR?: IndicatorWorkerAllocationWhereInput[]
    NOT?: IndicatorWorkerAllocationWhereInput | IndicatorWorkerAllocationWhereInput[]
    indicator_id?: IntFilter<"IndicatorWorkerAllocation"> | number
    worker_type?: StringFilter<"IndicatorWorkerAllocation"> | string
    allocated_amount?: IntFilter<"IndicatorWorkerAllocation"> | number
    created_at?: DateTimeFilter<"IndicatorWorkerAllocation"> | Date | string
    updated_at?: DateTimeFilter<"IndicatorWorkerAllocation"> | Date | string
    indicator?: XOR<IndicatorScalarRelationFilter, IndicatorWhereInput>
  }, "id" | "indicator_id_worker_type">

  export type IndicatorWorkerAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: IndicatorWorkerAllocationCountOrderByAggregateInput
    _avg?: IndicatorWorkerAllocationAvgOrderByAggregateInput
    _max?: IndicatorWorkerAllocationMaxOrderByAggregateInput
    _min?: IndicatorWorkerAllocationMinOrderByAggregateInput
    _sum?: IndicatorWorkerAllocationSumOrderByAggregateInput
  }

  export type IndicatorWorkerAllocationScalarWhereWithAggregatesInput = {
    AND?: IndicatorWorkerAllocationScalarWhereWithAggregatesInput | IndicatorWorkerAllocationScalarWhereWithAggregatesInput[]
    OR?: IndicatorWorkerAllocationScalarWhereWithAggregatesInput[]
    NOT?: IndicatorWorkerAllocationScalarWhereWithAggregatesInput | IndicatorWorkerAllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicatorWorkerAllocation"> | string
    indicator_id?: IntWithAggregatesFilter<"IndicatorWorkerAllocation"> | number
    worker_type?: StringWithAggregatesFilter<"IndicatorWorkerAllocation"> | string
    allocated_amount?: IntWithAggregatesFilter<"IndicatorWorkerAllocation"> | number
    created_at?: DateTimeWithAggregatesFilter<"IndicatorWorkerAllocation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"IndicatorWorkerAllocation"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    created_at?: DateTimeFilter<"SystemSetting"> | Date | string
    updated_at?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    created_at?: DateTimeFilter<"SystemSetting"> | Date | string
    updated_at?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    created_at?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    upload_sessions?: DataUploadSessionCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataCreateNestedManyWithoutUploaderInput
    facility?: FacilityCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    facility_id?: string | null
    upload_sessions?: DataUploadSessionUncheckedCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUpdateManyWithoutUploaderNestedInput
    facility?: FacilityUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUncheckedUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUncheckedUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    facility_id?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DistrictCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    facilities?: FacilityCreateNestedManyWithoutDistrictInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutDistrictInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutDistrictNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutDistrictNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DistrictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationSystemCreateInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    indicator_remunerations?: IndicatorRemunerationCreateNestedManyWithoutRemuneration_systemInput
  }

  export type RemunerationSystemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    indicator_remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutRemuneration_systemInput
  }

  export type RemunerationSystemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator_remunerations?: IndicatorRemunerationUpdateManyWithoutRemuneration_systemNestedInput
  }

  export type RemunerationSystemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator_remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutRemuneration_systemNestedInput
  }

  export type RemunerationSystemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RemunerationSystemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationSystemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTypeCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityCreateNestedManyWithoutFacility_typeInput
    field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationCreateNestedOneWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutFacility_typeInput
    field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationUncheckedCreateNestedOneWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigUncheckedCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutFacility_typeNestedInput
    field_mappings?: FacilityFieldMappingUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUpdateOneWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUpdateManyWithoutFacility_typeNestedInput
  }

  export type FacilityTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutFacility_typeNestedInput
    field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUncheckedUpdateOneWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeNestedInput
  }

  export type FacilityTypeCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
  }

  export type FacilityTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
  }

  export type FacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyHealthDataCreateInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    approver?: UserCreateNestedOneWithoutApproved_dataInput
    district: DistrictCreateNestedOneWithoutMonthly_dataInput
    facility?: FacilityCreateNestedOneWithoutMonthly_dataInput
    indicator?: IndicatorCreateNestedOneWithoutMonthly_dataInput
    sub_centre?: sub_centreCreateNestedOneWithoutMonthly_health_dataInput
    uploader: UserCreateNestedOneWithoutUploaded_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataUpdateInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approver?: UserUpdateOneWithoutApproved_dataNestedInput
    district?: DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput
    facility?: FacilityUpdateOneWithoutMonthly_dataNestedInput
    indicator?: IndicatorUpdateOneWithoutMonthly_dataNestedInput
    sub_centre?: sub_centreUpdateOneWithoutMonthly_health_dataNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploaded_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataCreateManyInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataUpdateManyMutationInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type MonthlyHealthDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataUploadSessionCreateInput = {
    file_name: string
    report_month: string
    total_records: number
    success_count?: number
    error_count?: number
    status?: $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    completed_at?: Date | string | null
    file_path?: string | null
    uploader: UserCreateNestedOneWithoutUpload_sessionsInput
  }

  export type DataUploadSessionUncheckedCreateInput = {
    id?: number
    file_name: string
    report_month: string
    total_records: number
    success_count?: number
    error_count?: number
    status?: $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    created_at?: Date | string
    completed_at?: Date | string | null
    file_path?: string | null
  }

  export type DataUploadSessionUpdateInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    uploader?: UserUpdateOneRequiredWithoutUpload_sessionsNestedInput
  }

  export type DataUploadSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataUploadSessionCreateManyInput = {
    id?: number
    file_name: string
    report_month: string
    total_records: number
    success_count?: number
    error_count?: number
    status?: $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    created_at?: Date | string
    completed_at?: Date | string | null
    file_path?: string | null
  }

  export type DataUploadSessionUpdateManyMutationInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataUploadSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormulaCreateInput = {
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FormulaUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FormulaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormulaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormulaCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FormulaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormulaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorCreateInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
  }

  export type IndicatorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldCreateInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFieldInput
    field_values?: FieldValueCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldCreateManyInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
  }

  export type FieldUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
  }

  export type FieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
  }

  export type FieldValueCreateInput = {
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility?: FacilityCreateNestedOneWithoutField_valuesInput
    field: FieldCreateNestedOneWithoutField_valuesInput
    uploader: UserCreateNestedOneWithoutField_valuesInput
  }

  export type FieldValueUncheckedCreateInput = {
    id?: number
    field_id: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility_id?: string | null
  }

  export type FieldValueUpdateInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutField_valuesNestedInput
    field?: FieldUpdateOneRequiredWithoutField_valuesNestedInput
    uploader?: UserUpdateOneRequiredWithoutField_valuesNestedInput
  }

  export type FieldValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldValueCreateManyInput = {
    id?: number
    field_id: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility_id?: string | null
  }

  export type FieldValueUpdateManyMutationInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityFieldDefaultsCreateInput = {
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutFacility_field_defaultsInput
    field: FieldCreateNestedOneWithoutFacility_field_defaultsInput
  }

  export type FacilityFieldDefaultsUncheckedCreateInput = {
    id?: number
    field_id: number
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityFieldDefaultsUpdateInput = {
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutFacility_field_defaultsNestedInput
    field?: FieldUpdateOneRequiredWithoutFacility_field_defaultsNestedInput
  }

  export type FacilityFieldDefaultsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityFieldDefaultsCreateManyInput = {
    id?: number
    field_id: number
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityFieldDefaultsUpdateManyMutationInput = {
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityFieldDefaultsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityFieldMappingCreateInput = {
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    facility_type: FacilityTypeCreateNestedOneWithoutField_mappingsInput
    field: FieldCreateNestedOneWithoutFacility_field_mappingsInput
  }

  export type FacilityFieldMappingUncheckedCreateInput = {
    id?: number
    field_id: number
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
  }

  export type FacilityFieldMappingUpdateInput = {
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type?: FacilityTypeUpdateOneRequiredWithoutField_mappingsNestedInput
    field?: FieldUpdateOneRequiredWithoutFacility_field_mappingsNestedInput
  }

  export type FacilityFieldMappingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityFieldMappingCreateManyInput = {
    id?: number
    field_id: number
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
  }

  export type FacilityFieldMappingUpdateManyMutationInput = {
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityFieldMappingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type sub_centreCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    monthly_health_data?: MonthlyHealthDataCreateNestedManyWithoutSub_centreInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutSub_centreInput
    facility: FacilityCreateNestedOneWithoutSub_centresInput
  }

  export type sub_centreUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    facility_id: string
    monthly_health_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutSub_centreInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutSub_centreInput
  }

  export type sub_centreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_health_data?: MonthlyHealthDataUpdateManyWithoutSub_centreNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutSub_centreNestedInput
    facility?: FacilityUpdateOneRequiredWithoutSub_centresNestedInput
  }

  export type sub_centreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
    monthly_health_data?: MonthlyHealthDataUncheckedUpdateManyWithoutSub_centreNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutSub_centreNestedInput
  }

  export type sub_centreCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    facility_id: string
  }

  export type sub_centreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_centreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type HealthWorkerCreateInput = {
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutHealth_workersInput
    remuneration_calculations?: WorkerRemunerationCreateNestedManyWithoutHealth_workerInput
  }

  export type HealthWorkerUncheckedCreateInput = {
    id?: number
    facility_id: string
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_calculations?: WorkerRemunerationUncheckedCreateNestedManyWithoutHealth_workerInput
  }

  export type HealthWorkerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutHealth_workersNestedInput
    remuneration_calculations?: WorkerRemunerationUpdateManyWithoutHealth_workerNestedInput
  }

  export type HealthWorkerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_calculations?: WorkerRemunerationUncheckedUpdateManyWithoutHealth_workerNestedInput
  }

  export type HealthWorkerCreateManyInput = {
    id?: number
    facility_id: string
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type HealthWorkerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthWorkerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationCalculationCreateInput = {
    report_month: string
    performance_percentage: Decimal | DecimalJsLike | number | string
    facility_remuneration: Decimal | DecimalJsLike | number | string
    total_worker_remuneration: Decimal | DecimalJsLike | number | string
    total_remuneration: Decimal | DecimalJsLike | number | string
    health_workers_count?: number
    asha_workers_count?: number
    calculated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutRemuneration_calculationsInput
  }

  export type RemunerationCalculationUncheckedCreateInput = {
    id?: number
    facility_id: string
    report_month: string
    performance_percentage: Decimal | DecimalJsLike | number | string
    facility_remuneration: Decimal | DecimalJsLike | number | string
    total_worker_remuneration: Decimal | DecimalJsLike | number | string
    total_remuneration: Decimal | DecimalJsLike | number | string
    health_workers_count?: number
    asha_workers_count?: number
    calculated_at?: Date | string
  }

  export type RemunerationCalculationUpdateInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutRemuneration_calculationsNestedInput
  }

  export type RemunerationCalculationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationCalculationCreateManyInput = {
    id?: number
    facility_id: string
    report_month: string
    performance_percentage: Decimal | DecimalJsLike | number | string
    facility_remuneration: Decimal | DecimalJsLike | number | string
    total_worker_remuneration: Decimal | DecimalJsLike | number | string
    total_remuneration: Decimal | DecimalJsLike | number | string
    health_workers_count?: number
    asha_workers_count?: number
    calculated_at?: Date | string
  }

  export type RemunerationCalculationUpdateManyMutationInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationCalculationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerRemunerationCreateInput = {
    report_month: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    performance_percentage: Decimal | DecimalJsLike | number | string
    calculated_amount: Decimal | DecimalJsLike | number | string
    calculated_at?: Date | string
    health_worker: HealthWorkerCreateNestedOneWithoutRemuneration_calculationsInput
  }

  export type WorkerRemunerationUncheckedCreateInput = {
    id?: number
    health_worker_id: number
    report_month: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    performance_percentage: Decimal | DecimalJsLike | number | string
    calculated_amount: Decimal | DecimalJsLike | number | string
    calculated_at?: Date | string
  }

  export type WorkerRemunerationUpdateInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    health_worker?: HealthWorkerUpdateOneRequiredWithoutRemuneration_calculationsNestedInput
  }

  export type WorkerRemunerationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    health_worker_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerRemunerationCreateManyInput = {
    id?: number
    health_worker_id: number
    report_month: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    performance_percentage: Decimal | DecimalJsLike | number | string
    calculated_amount: Decimal | DecimalJsLike | number | string
    calculated_at?: Date | string
  }

  export type WorkerRemunerationUpdateManyMutationInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerRemunerationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    health_worker_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerAllocationConfigCreateInput = {
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutWorker_allocation_configInput
    facility_type: FacilityTypeCreateNestedOneWithoutWorker_allocationsInput
  }

  export type WorkerAllocationConfigUncheckedCreateInput = {
    id?: number
    facility_type_id: string
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutWorker_allocation_configInput
  }

  export type WorkerAllocationConfigUpdateInput = {
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_allocations?: FacilityWorkerAllocationUpdateManyWithoutWorker_allocation_configNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutWorker_allocationsNestedInput
  }

  export type WorkerAllocationConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutWorker_allocation_configNestedInput
  }

  export type WorkerAllocationConfigCreateManyInput = {
    id?: number
    facility_type_id: string
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkerAllocationConfigUpdateManyMutationInput = {
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerAllocationConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationCreateInput = {
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutWorker_allocationsInput
    worker_allocation_config: WorkerAllocationConfigCreateNestedOneWithoutFacility_allocationsInput
  }

  export type FacilityWorkerAllocationUncheckedCreateInput = {
    id?: number
    facility_id: string
    worker_allocation_config_id: number
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityWorkerAllocationUpdateInput = {
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutWorker_allocationsNestedInput
    worker_allocation_config?: WorkerAllocationConfigUpdateOneRequiredWithoutFacility_allocationsNestedInput
  }

  export type FacilityWorkerAllocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    worker_allocation_config_id?: IntFieldUpdateOperationsInput | number
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationCreateManyInput = {
    id?: number
    facility_id: string
    worker_allocation_config_id: number
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityWorkerAllocationUpdateManyMutationInput = {
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    worker_allocation_config_id?: IntFieldUpdateOperationsInput | number
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTypeRemunerationCreateInput = {
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type: FacilityTypeCreateNestedOneWithoutRemunerationsInput
    indicator_remunerations?: IndicatorRemunerationCreateNestedManyWithoutFacility_type_remunerationInput
  }

  export type FacilityTypeRemunerationUncheckedCreateInput = {
    id?: number
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
    indicator_remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutFacility_type_remunerationInput
  }

  export type FacilityTypeRemunerationUpdateInput = {
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type?: FacilityTypeUpdateOneRequiredWithoutRemunerationsNestedInput
    indicator_remunerations?: IndicatorRemunerationUpdateManyWithoutFacility_type_remunerationNestedInput
  }

  export type FacilityTypeRemunerationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    indicator_remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutFacility_type_remunerationNestedInput
  }

  export type FacilityTypeRemunerationCreateManyInput = {
    id?: number
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
  }

  export type FacilityTypeRemunerationUpdateManyMutationInput = {
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTypeRemunerationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorRemunerationCreateInput = {
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_remuneration: FacilityTypeRemunerationCreateNestedOneWithoutIndicator_remunerationsInput
    indicator: IndicatorCreateNestedOneWithoutRemunerationsInput
    remuneration_system?: RemunerationSystemCreateNestedOneWithoutIndicator_remunerationsInput
  }

  export type IndicatorRemunerationUncheckedCreateInput = {
    id?: number
    facility_type_remuneration_id: number
    indicator_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_system_id?: string | null
  }

  export type IndicatorRemunerationUpdateInput = {
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_remuneration?: FacilityTypeRemunerationUpdateOneRequiredWithoutIndicator_remunerationsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutRemunerationsNestedInput
    remuneration_system?: RemunerationSystemUpdateOneWithoutIndicator_remunerationsNestedInput
  }

  export type IndicatorRemunerationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_remuneration_id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_system_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorRemunerationCreateManyInput = {
    id?: number
    facility_type_remuneration_id: number
    indicator_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_system_id?: string | null
  }

  export type IndicatorRemunerationUpdateManyMutationInput = {
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorRemunerationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_remuneration_id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_system_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceCalculationCreateInput = {
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility?: FacilityCreateNestedOneWithoutPerformance_calculationsInput
    indicator: IndicatorCreateNestedOneWithoutPerformance_calculationsInput
    sub_centre?: sub_centreCreateNestedOneWithoutPerformance_calculationsInput
  }

  export type PerformanceCalculationUncheckedCreateInput = {
    id?: number
    sub_centre_id?: number | null
    indicator_id: number
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility_id?: string | null
  }

  export type PerformanceCalculationUpdateInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneWithoutPerformance_calculationsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutPerformance_calculationsNestedInput
    sub_centre?: sub_centreUpdateOneWithoutPerformance_calculationsNestedInput
  }

  export type PerformanceCalculationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceCalculationCreateManyInput = {
    id?: number
    sub_centre_id?: number | null
    indicator_id: number
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility_id?: string | null
  }

  export type PerformanceCalculationUpdateManyMutationInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCalculationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityTargetCreateInput = {
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutFacility_targetsInput
    indicator: IndicatorCreateNestedOneWithoutFacility_targetsInput
  }

  export type FacilityTargetUncheckedCreateInput = {
    id?: number
    indicator_id: number
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityTargetUpdateInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutFacility_targetsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutFacility_targetsNestedInput
  }

  export type FacilityTargetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityTargetCreateManyInput = {
    id?: number
    indicator_id: number
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityTargetUpdateManyMutationInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTargetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorWorkerAllocationCreateInput = {
    id?: string
    worker_type: string
    allocated_amount: number
    created_at?: Date | string
    updated_at?: Date | string
    indicator: IndicatorCreateNestedOneWithoutWorker_allocationsInput
  }

  export type IndicatorWorkerAllocationUncheckedCreateInput = {
    id?: string
    indicator_id: number
    worker_type: string
    allocated_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IndicatorWorkerAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutWorker_allocationsNestedInput
  }

  export type IndicatorWorkerAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator_id?: IntFieldUpdateOperationsInput | number
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorWorkerAllocationCreateManyInput = {
    id?: string
    indicator_id: number
    worker_type: string
    allocated_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IndicatorWorkerAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorWorkerAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    indicator_id?: IntFieldUpdateOperationsInput | number
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DataUploadSessionListRelationFilter = {
    every?: DataUploadSessionWhereInput
    some?: DataUploadSessionWhereInput
    none?: DataUploadSessionWhereInput
  }

  export type FieldValueListRelationFilter = {
    every?: FieldValueWhereInput
    some?: FieldValueWhereInput
    none?: FieldValueWhereInput
  }

  export type MonthlyHealthDataListRelationFilter = {
    every?: MonthlyHealthDataWhereInput
    some?: MonthlyHealthDataWhereInput
    none?: MonthlyHealthDataWhereInput
  }

  export type FacilityNullableScalarRelationFilter = {
    is?: FacilityWhereInput | null
    isNot?: FacilityWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DataUploadSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonthlyHealthDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    facility_id?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    facility_id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    last_login?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    facility_id?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FacilityListRelationFilter = {
    every?: FacilityWhereInput
    some?: FacilityWhereInput
    none?: FacilityWhereInput
  }

  export type FacilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IndicatorRemunerationListRelationFilter = {
    every?: IndicatorRemunerationWhereInput
    some?: IndicatorRemunerationWhereInput
    none?: IndicatorRemunerationWhereInput
  }

  export type IndicatorRemunerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RemunerationSystemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RemunerationSystemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RemunerationSystemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FacilityFieldMappingListRelationFilter = {
    every?: FacilityFieldMappingWhereInput
    some?: FacilityFieldMappingWhereInput
    none?: FacilityFieldMappingWhereInput
  }

  export type FacilityTypeRemunerationNullableScalarRelationFilter = {
    is?: FacilityTypeRemunerationWhereInput | null
    isNot?: FacilityTypeRemunerationWhereInput | null
  }

  export type WorkerAllocationConfigListRelationFilter = {
    every?: WorkerAllocationConfigWhereInput
    some?: WorkerAllocationConfigWhereInput
    none?: WorkerAllocationConfigWhereInput
  }

  export type FacilityFieldMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerAllocationConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrder
    display_name?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrder
    display_name?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrder
    display_name?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
  }

  export type DistrictScalarRelationFilter = {
    is?: DistrictWhereInput
    isNot?: DistrictWhereInput
  }

  export type FacilityTypeScalarRelationFilter = {
    is?: FacilityTypeWhereInput
    isNot?: FacilityTypeWhereInput
  }

  export type FacilityFieldDefaultsListRelationFilter = {
    every?: FacilityFieldDefaultsWhereInput
    some?: FacilityFieldDefaultsWhereInput
    none?: FacilityFieldDefaultsWhereInput
  }

  export type FacilityTargetListRelationFilter = {
    every?: FacilityTargetWhereInput
    some?: FacilityTargetWhereInput
    none?: FacilityTargetWhereInput
  }

  export type FacilityWorkerAllocationListRelationFilter = {
    every?: FacilityWorkerAllocationWhereInput
    some?: FacilityWorkerAllocationWhereInput
    none?: FacilityWorkerAllocationWhereInput
  }

  export type HealthWorkerListRelationFilter = {
    every?: HealthWorkerWhereInput
    some?: HealthWorkerWhereInput
    none?: HealthWorkerWhereInput
  }

  export type PerformanceCalculationListRelationFilter = {
    every?: PerformanceCalculationWhereInput
    some?: PerformanceCalculationWhereInput
    none?: PerformanceCalculationWhereInput
  }

  export type RemunerationCalculationListRelationFilter = {
    every?: RemunerationCalculationWhereInput
    some?: RemunerationCalculationWhereInput
    none?: RemunerationCalculationWhereInput
  }

  export type Sub_centreListRelationFilter = {
    every?: sub_centreWhereInput
    some?: sub_centreWhereInput
    none?: sub_centreWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type FacilityFieldDefaultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityTargetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityWorkerAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthWorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceCalculationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RemunerationCalculationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sub_centreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityNameDistrict_idCompoundUniqueInput = {
    name: string
    district_id: string
  }

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrder
    display_name?: SortOrder
    district_id?: SortOrder
    facility_type_id?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrder
    display_name?: SortOrder
    district_id?: SortOrder
    facility_type_id?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    description?: SortOrder
    display_name?: SortOrder
    district_id?: SortOrder
    facility_type_id?: SortOrder
    is_active?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumDataQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.DataQuality | EnumDataQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataQualityFilter<$PrismaModel> | $Enums.DataQuality
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type IndicatorNullableScalarRelationFilter = {
    is?: IndicatorWhereInput | null
    isNot?: IndicatorWhereInput | null
  }

  export type Sub_centreNullableScalarRelationFilter = {
    is?: sub_centreWhereInput | null
    isNot?: sub_centreWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MonthlyHealthDataFacility_idSub_centre_idIndicator_idReport_monthCompoundUniqueInput = {
    facility_id: string
    sub_centre_id: number
    indicator_id: number
    report_month: string
  }

  export type MonthlyHealthDataCountOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    report_month?: SortOrder
    value?: SortOrder
    data_quality?: SortOrder
    remarks?: SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    achievement?: SortOrder
    denominator?: SortOrder
    numerator?: SortOrder
    target_value?: SortOrder
    indicator_id?: SortOrder
    district_id?: SortOrder
    facility_id?: SortOrder
  }

  export type MonthlyHealthDataAvgOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    value?: SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrder
    achievement?: SortOrder
    denominator?: SortOrder
    numerator?: SortOrder
    target_value?: SortOrder
    indicator_id?: SortOrder
  }

  export type MonthlyHealthDataMaxOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    report_month?: SortOrder
    value?: SortOrder
    data_quality?: SortOrder
    remarks?: SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    achievement?: SortOrder
    denominator?: SortOrder
    numerator?: SortOrder
    target_value?: SortOrder
    indicator_id?: SortOrder
    district_id?: SortOrder
    facility_id?: SortOrder
  }

  export type MonthlyHealthDataMinOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    report_month?: SortOrder
    value?: SortOrder
    data_quality?: SortOrder
    remarks?: SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    achievement?: SortOrder
    denominator?: SortOrder
    numerator?: SortOrder
    target_value?: SortOrder
    indicator_id?: SortOrder
    district_id?: SortOrder
    facility_id?: SortOrder
  }

  export type MonthlyHealthDataSumOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    value?: SortOrder
    uploaded_by?: SortOrder
    approved_by?: SortOrder
    achievement?: SortOrder
    denominator?: SortOrder
    numerator?: SortOrder
    target_value?: SortOrder
    indicator_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumDataQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataQuality | EnumDataQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataQualityWithAggregatesFilter<$PrismaModel> | $Enums.DataQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataQualityFilter<$PrismaModel>
    _max?: NestedEnumDataQualityFilter<$PrismaModel>
  }

  export type EnumUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusFilter<$PrismaModel> | $Enums.UploadStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DataUploadSessionCountOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    report_month?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    status?: SortOrder
    upload_summary?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrder
    file_path?: SortOrder
  }

  export type DataUploadSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    uploaded_by?: SortOrder
  }

  export type DataUploadSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    report_month?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    status?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrder
    file_path?: SortOrder
  }

  export type DataUploadSessionMinOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    report_month?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    status?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    completed_at?: SortOrder
    file_path?: SortOrder
  }

  export type DataUploadSessionSumOrderByAggregateInput = {
    id?: SortOrder
    total_records?: SortOrder
    success_count?: SortOrder
    error_count?: SortOrder
    uploaded_by?: SortOrder
  }

  export type EnumUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.UploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumUploadStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FormulaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    structure?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FormulaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FormulaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FormulaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FormulaSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeFilter<$PrismaModel> | $Enums.TargetType
  }

  export type FieldNullableScalarRelationFilter = {
    is?: FieldWhereInput | null
    isNot?: FieldWhereInput | null
  }

  export type IndicatorWorkerAllocationListRelationFilter = {
    every?: IndicatorWorkerAllocationWhereInput
    some?: IndicatorWorkerAllocationWhereInput
    none?: IndicatorWorkerAllocationWhereInput
  }

  export type IndicatorWorkerAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    structure?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    applicable_facility_types?: SortOrder
    conditions?: SortOrder
    denominator_field_id?: SortOrder
    denominator_label?: SortOrder
    formula_config?: SortOrder
    numerator_field_id?: SortOrder
    numerator_label?: SortOrder
    target_formula?: SortOrder
    target_type?: SortOrder
    target_value?: SortOrder
    target_field_id?: SortOrder
    source_of_verification?: SortOrder
  }

  export type IndicatorAvgOrderByAggregateInput = {
    id?: SortOrder
    denominator_field_id?: SortOrder
    numerator_field_id?: SortOrder
    target_field_id?: SortOrder
  }

  export type IndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    conditions?: SortOrder
    denominator_field_id?: SortOrder
    denominator_label?: SortOrder
    numerator_field_id?: SortOrder
    numerator_label?: SortOrder
    target_formula?: SortOrder
    target_type?: SortOrder
    target_value?: SortOrder
    target_field_id?: SortOrder
    source_of_verification?: SortOrder
  }

  export type IndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    code?: SortOrder
    conditions?: SortOrder
    denominator_field_id?: SortOrder
    denominator_label?: SortOrder
    numerator_field_id?: SortOrder
    numerator_label?: SortOrder
    target_formula?: SortOrder
    target_type?: SortOrder
    target_value?: SortOrder
    target_field_id?: SortOrder
    source_of_verification?: SortOrder
  }

  export type IndicatorSumOrderByAggregateInput = {
    id?: SortOrder
    denominator_field_id?: SortOrder
    numerator_field_id?: SortOrder
    target_field_id?: SortOrder
  }

  export type EnumTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumTargetTypeFilter<$PrismaModel>
  }

  export type EnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type EnumFieldCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldCategory | EnumFieldCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldCategoryFilter<$PrismaModel> | $Enums.FieldCategory
  }

  export type IndicatorListRelationFilter = {
    every?: IndicatorWhereInput
    some?: IndicatorWhereInput
    none?: IndicatorWhereInput
  }

  export type IndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FieldCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    calculation_formula?: SortOrder
    default_value?: SortOrder
    facility_type_targets?: SortOrder
    field_type?: SortOrder
    is_active?: SortOrder
    sort_order?: SortOrder
    user_type?: SortOrder
    validation_rules?: SortOrder
    field_category?: SortOrder
  }

  export type FieldAvgOrderByAggregateInput = {
    id?: SortOrder
    sort_order?: SortOrder
  }

  export type FieldMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    calculation_formula?: SortOrder
    default_value?: SortOrder
    field_type?: SortOrder
    is_active?: SortOrder
    sort_order?: SortOrder
    user_type?: SortOrder
    field_category?: SortOrder
  }

  export type FieldMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    calculation_formula?: SortOrder
    default_value?: SortOrder
    field_type?: SortOrder
    is_active?: SortOrder
    sort_order?: SortOrder
    user_type?: SortOrder
    field_category?: SortOrder
  }

  export type FieldSumOrderByAggregateInput = {
    id?: SortOrder
    sort_order?: SortOrder
  }

  export type EnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type EnumFieldCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldCategory | EnumFieldCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FieldCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldCategoryFilter<$PrismaModel>
    _max?: NestedEnumFieldCategoryFilter<$PrismaModel>
  }

  export type FieldScalarRelationFilter = {
    is?: FieldWhereInput
    isNot?: FieldWhereInput
  }

  export type FieldValueField_idFacility_idReport_monthCompoundUniqueInput = {
    field_id: number
    facility_id: string
    report_month: string
  }

  export type FieldValueCountOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    report_month?: SortOrder
    string_value?: SortOrder
    numeric_value?: SortOrder
    boolean_value?: SortOrder
    json_value?: SortOrder
    uploaded_by?: SortOrder
    remarks?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_override?: SortOrder
    override_reason?: SortOrder
    facility_id?: SortOrder
  }

  export type FieldValueAvgOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    numeric_value?: SortOrder
    uploaded_by?: SortOrder
  }

  export type FieldValueMaxOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    report_month?: SortOrder
    string_value?: SortOrder
    numeric_value?: SortOrder
    boolean_value?: SortOrder
    uploaded_by?: SortOrder
    remarks?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_override?: SortOrder
    override_reason?: SortOrder
    facility_id?: SortOrder
  }

  export type FieldValueMinOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    report_month?: SortOrder
    string_value?: SortOrder
    numeric_value?: SortOrder
    boolean_value?: SortOrder
    uploaded_by?: SortOrder
    remarks?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_override?: SortOrder
    override_reason?: SortOrder
    facility_id?: SortOrder
  }

  export type FieldValueSumOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    numeric_value?: SortOrder
    uploaded_by?: SortOrder
  }

  export type FacilityScalarRelationFilter = {
    is?: FacilityWhereInput
    isNot?: FacilityWhereInput
  }

  export type FacilityFieldDefaultsField_idFacility_idCompoundUniqueInput = {
    field_id: number
    facility_id: string
  }

  export type FacilityFieldDefaultsCountOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    string_value?: SortOrder
    numeric_value?: SortOrder
    boolean_value?: SortOrder
    json_value?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type FacilityFieldDefaultsAvgOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    numeric_value?: SortOrder
  }

  export type FacilityFieldDefaultsMaxOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    string_value?: SortOrder
    numeric_value?: SortOrder
    boolean_value?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type FacilityFieldDefaultsMinOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    string_value?: SortOrder
    numeric_value?: SortOrder
    boolean_value?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type FacilityFieldDefaultsSumOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    numeric_value?: SortOrder
  }

  export type FacilityFieldMappingFacility_type_idField_idCompoundUniqueInput = {
    facility_type_id: string
    field_id: number
  }

  export type FacilityFieldMappingCountOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    is_required?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
  }

  export type FacilityFieldMappingAvgOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    display_order?: SortOrder
  }

  export type FacilityFieldMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    is_required?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
  }

  export type FacilityFieldMappingMinOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    is_required?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
  }

  export type FacilityFieldMappingSumOrderByAggregateInput = {
    id?: SortOrder
    field_id?: SortOrder
    display_order?: SortOrder
  }

  export type sub_centreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type sub_centreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sub_centreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type sub_centreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type sub_centreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type WorkerRemunerationListRelationFilter = {
    every?: WorkerRemunerationWhereInput
    some?: WorkerRemunerationWhereInput
    none?: WorkerRemunerationWhereInput
  }

  export type WorkerRemunerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthWorkerCountOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    name?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type HealthWorkerAvgOrderByAggregateInput = {
    id?: SortOrder
    allocated_amount?: SortOrder
  }

  export type HealthWorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    name?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type HealthWorkerMinOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    name?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type HealthWorkerSumOrderByAggregateInput = {
    id?: SortOrder
    allocated_amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type RemunerationCalculationFacility_idReport_monthCompoundUniqueInput = {
    facility_id: string
    report_month: string
  }

  export type RemunerationCalculationCountOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    report_month?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
    calculated_at?: SortOrder
  }

  export type RemunerationCalculationAvgOrderByAggregateInput = {
    id?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
  }

  export type RemunerationCalculationMaxOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    report_month?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
    calculated_at?: SortOrder
  }

  export type RemunerationCalculationMinOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    report_month?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
    calculated_at?: SortOrder
  }

  export type RemunerationCalculationSumOrderByAggregateInput = {
    id?: SortOrder
    performance_percentage?: SortOrder
    facility_remuneration?: SortOrder
    total_worker_remuneration?: SortOrder
    total_remuneration?: SortOrder
    health_workers_count?: SortOrder
    asha_workers_count?: SortOrder
  }

  export type HealthWorkerScalarRelationFilter = {
    is?: HealthWorkerWhereInput
    isNot?: HealthWorkerWhereInput
  }

  export type WorkerRemunerationHealth_worker_idReport_monthCompoundUniqueInput = {
    health_worker_id: number
    report_month: string
  }

  export type WorkerRemunerationCountOrderByAggregateInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    report_month?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
    calculated_at?: SortOrder
  }

  export type WorkerRemunerationAvgOrderByAggregateInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
  }

  export type WorkerRemunerationMaxOrderByAggregateInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    report_month?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
    calculated_at?: SortOrder
  }

  export type WorkerRemunerationMinOrderByAggregateInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    report_month?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
    calculated_at?: SortOrder
  }

  export type WorkerRemunerationSumOrderByAggregateInput = {
    id?: SortOrder
    health_worker_id?: SortOrder
    allocated_amount?: SortOrder
    performance_percentage?: SortOrder
    calculated_amount?: SortOrder
  }

  export type WorkerAllocationConfigFacility_type_idWorker_typeWorker_roleCompoundUniqueInput = {
    facility_type_id: string
    worker_type: string
    worker_role: string
  }

  export type WorkerAllocationConfigCountOrderByAggregateInput = {
    id?: SortOrder
    facility_type_id?: SortOrder
    worker_type?: SortOrder
    worker_role?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkerAllocationConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
  }

  export type WorkerAllocationConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    facility_type_id?: SortOrder
    worker_type?: SortOrder
    worker_role?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkerAllocationConfigMinOrderByAggregateInput = {
    id?: SortOrder
    facility_type_id?: SortOrder
    worker_type?: SortOrder
    worker_role?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
    description?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WorkerAllocationConfigSumOrderByAggregateInput = {
    id?: SortOrder
    max_count?: SortOrder
    allocated_amount?: SortOrder
  }

  export type WorkerAllocationConfigScalarRelationFilter = {
    is?: WorkerAllocationConfigWhereInput
    isNot?: WorkerAllocationConfigWhereInput
  }

  export type FacilityWorkerAllocationFacility_idWorker_allocation_config_idCompoundUniqueInput = {
    facility_id: string
    worker_allocation_config_id: number
  }

  export type FacilityWorkerAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityWorkerAllocationAvgOrderByAggregateInput = {
    id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
  }

  export type FacilityWorkerAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityWorkerAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    facility_id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FacilityWorkerAllocationSumOrderByAggregateInput = {
    id?: SortOrder
    worker_allocation_config_id?: SortOrder
    worker_count?: SortOrder
    total_allocated_amount?: SortOrder
  }

  export type FacilityTypeRemunerationCountOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
  }

  export type FacilityTypeRemunerationAvgOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
  }

  export type FacilityTypeRemunerationMaxOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
  }

  export type FacilityTypeRemunerationMinOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_type_id?: SortOrder
  }

  export type FacilityTypeRemunerationSumOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
  }

  export type FacilityTypeRemunerationScalarRelationFilter = {
    is?: FacilityTypeRemunerationWhereInput
    isNot?: FacilityTypeRemunerationWhereInput
  }

  export type IndicatorScalarRelationFilter = {
    is?: IndicatorWhereInput
    isNot?: IndicatorWhereInput
  }

  export type RemunerationSystemNullableScalarRelationFilter = {
    is?: RemunerationSystemWhereInput | null
    isNot?: RemunerationSystemWhereInput | null
  }

  export type IndicatorRemunerationFacility_type_remuneration_idIndicator_idCompoundUniqueInput = {
    facility_type_remuneration_id: number
    indicator_id: number
  }

  export type IndicatorRemunerationCountOrderByAggregateInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrder
    condition_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    remuneration_system_id?: SortOrder
  }

  export type IndicatorRemunerationAvgOrderByAggregateInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrder
  }

  export type IndicatorRemunerationMaxOrderByAggregateInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrder
    condition_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    remuneration_system_id?: SortOrder
  }

  export type IndicatorRemunerationMinOrderByAggregateInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrder
    condition_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    remuneration_system_id?: SortOrder
  }

  export type IndicatorRemunerationSumOrderByAggregateInput = {
    id?: SortOrder
    facility_type_remuneration_id?: SortOrder
    indicator_id?: SortOrder
    base_amount?: SortOrder
    conditional_amount?: SortOrder
  }

  export type PerformanceCalculationFacility_idSub_centre_idIndicator_idReport_monthCompoundUniqueInput = {
    facility_id: string
    sub_centre_id: number
    indicator_id: number
    report_month: string
  }

  export type PerformanceCalculationCountOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    achievement?: SortOrder
    target_value?: SortOrder
    remuneration_amount?: SortOrder
    calculated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type PerformanceCalculationAvgOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    indicator_id?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    achievement?: SortOrder
    target_value?: SortOrder
    remuneration_amount?: SortOrder
  }

  export type PerformanceCalculationMaxOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    achievement?: SortOrder
    target_value?: SortOrder
    remuneration_amount?: SortOrder
    calculated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type PerformanceCalculationMinOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    achievement?: SortOrder
    target_value?: SortOrder
    remuneration_amount?: SortOrder
    calculated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type PerformanceCalculationSumOrderByAggregateInput = {
    id?: SortOrder
    sub_centre_id?: SortOrder
    indicator_id?: SortOrder
    numerator?: SortOrder
    denominator?: SortOrder
    achievement?: SortOrder
    target_value?: SortOrder
    remuneration_amount?: SortOrder
  }

  export type FacilityTargetFacility_idIndicator_idReport_monthCompoundUniqueInput = {
    facility_id: string
    indicator_id: number
    report_month: string
  }

  export type FacilityTargetCountOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    target_value?: SortOrder
    numerator_label?: SortOrder
    denominator_label?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type FacilityTargetAvgOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    target_value?: SortOrder
  }

  export type FacilityTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    target_value?: SortOrder
    numerator_label?: SortOrder
    denominator_label?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type FacilityTargetMinOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    report_month?: SortOrder
    target_value?: SortOrder
    numerator_label?: SortOrder
    denominator_label?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    facility_id?: SortOrder
  }

  export type FacilityTargetSumOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    target_value?: SortOrder
  }

  export type IndicatorWorkerAllocationIndicator_idWorker_typeCompoundUniqueInput = {
    indicator_id: number
    worker_type: string
  }

  export type IndicatorWorkerAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IndicatorWorkerAllocationAvgOrderByAggregateInput = {
    indicator_id?: SortOrder
    allocated_amount?: SortOrder
  }

  export type IndicatorWorkerAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IndicatorWorkerAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    indicator_id?: SortOrder
    worker_type?: SortOrder
    allocated_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IndicatorWorkerAllocationSumOrderByAggregateInput = {
    indicator_id?: SortOrder
    allocated_amount?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DataUploadSessionCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DataUploadSessionCreateWithoutUploaderInput, DataUploadSessionUncheckedCreateWithoutUploaderInput> | DataUploadSessionCreateWithoutUploaderInput[] | DataUploadSessionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DataUploadSessionCreateOrConnectWithoutUploaderInput | DataUploadSessionCreateOrConnectWithoutUploaderInput[]
    createMany?: DataUploadSessionCreateManyUploaderInputEnvelope
    connect?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
  }

  export type FieldValueCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FieldValueCreateWithoutUploaderInput, FieldValueUncheckedCreateWithoutUploaderInput> | FieldValueCreateWithoutUploaderInput[] | FieldValueUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutUploaderInput | FieldValueCreateOrConnectWithoutUploaderInput[]
    createMany?: FieldValueCreateManyUploaderInputEnvelope
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
  }

  export type MonthlyHealthDataCreateNestedManyWithoutApproverInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutApproverInput, MonthlyHealthDataUncheckedCreateWithoutApproverInput> | MonthlyHealthDataCreateWithoutApproverInput[] | MonthlyHealthDataUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutApproverInput | MonthlyHealthDataCreateOrConnectWithoutApproverInput[]
    createMany?: MonthlyHealthDataCreateManyApproverInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type MonthlyHealthDataCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutUploaderInput, MonthlyHealthDataUncheckedCreateWithoutUploaderInput> | MonthlyHealthDataCreateWithoutUploaderInput[] | MonthlyHealthDataUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutUploaderInput | MonthlyHealthDataCreateOrConnectWithoutUploaderInput[]
    createMany?: MonthlyHealthDataCreateManyUploaderInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type FacilityCreateNestedOneWithoutUsersInput = {
    create?: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutUsersInput
    connect?: FacilityWhereUniqueInput
  }

  export type DataUploadSessionUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DataUploadSessionCreateWithoutUploaderInput, DataUploadSessionUncheckedCreateWithoutUploaderInput> | DataUploadSessionCreateWithoutUploaderInput[] | DataUploadSessionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DataUploadSessionCreateOrConnectWithoutUploaderInput | DataUploadSessionCreateOrConnectWithoutUploaderInput[]
    createMany?: DataUploadSessionCreateManyUploaderInputEnvelope
    connect?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
  }

  export type FieldValueUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<FieldValueCreateWithoutUploaderInput, FieldValueUncheckedCreateWithoutUploaderInput> | FieldValueCreateWithoutUploaderInput[] | FieldValueUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutUploaderInput | FieldValueCreateOrConnectWithoutUploaderInput[]
    createMany?: FieldValueCreateManyUploaderInputEnvelope
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
  }

  export type MonthlyHealthDataUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutApproverInput, MonthlyHealthDataUncheckedCreateWithoutApproverInput> | MonthlyHealthDataCreateWithoutApproverInput[] | MonthlyHealthDataUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutApproverInput | MonthlyHealthDataCreateOrConnectWithoutApproverInput[]
    createMany?: MonthlyHealthDataCreateManyApproverInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type MonthlyHealthDataUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutUploaderInput, MonthlyHealthDataUncheckedCreateWithoutUploaderInput> | MonthlyHealthDataCreateWithoutUploaderInput[] | MonthlyHealthDataUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutUploaderInput | MonthlyHealthDataCreateOrConnectWithoutUploaderInput[]
    createMany?: MonthlyHealthDataCreateManyUploaderInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DataUploadSessionUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DataUploadSessionCreateWithoutUploaderInput, DataUploadSessionUncheckedCreateWithoutUploaderInput> | DataUploadSessionCreateWithoutUploaderInput[] | DataUploadSessionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DataUploadSessionCreateOrConnectWithoutUploaderInput | DataUploadSessionCreateOrConnectWithoutUploaderInput[]
    upsert?: DataUploadSessionUpsertWithWhereUniqueWithoutUploaderInput | DataUploadSessionUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DataUploadSessionCreateManyUploaderInputEnvelope
    set?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    disconnect?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    delete?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    connect?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    update?: DataUploadSessionUpdateWithWhereUniqueWithoutUploaderInput | DataUploadSessionUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DataUploadSessionUpdateManyWithWhereWithoutUploaderInput | DataUploadSessionUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DataUploadSessionScalarWhereInput | DataUploadSessionScalarWhereInput[]
  }

  export type FieldValueUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FieldValueCreateWithoutUploaderInput, FieldValueUncheckedCreateWithoutUploaderInput> | FieldValueCreateWithoutUploaderInput[] | FieldValueUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutUploaderInput | FieldValueCreateOrConnectWithoutUploaderInput[]
    upsert?: FieldValueUpsertWithWhereUniqueWithoutUploaderInput | FieldValueUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: FieldValueCreateManyUploaderInputEnvelope
    set?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    disconnect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    delete?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    update?: FieldValueUpdateWithWhereUniqueWithoutUploaderInput | FieldValueUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: FieldValueUpdateManyWithWhereWithoutUploaderInput | FieldValueUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
  }

  export type MonthlyHealthDataUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutApproverInput, MonthlyHealthDataUncheckedCreateWithoutApproverInput> | MonthlyHealthDataCreateWithoutApproverInput[] | MonthlyHealthDataUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutApproverInput | MonthlyHealthDataCreateOrConnectWithoutApproverInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutApproverInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MonthlyHealthDataCreateManyApproverInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutApproverInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutApproverInput | MonthlyHealthDataUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type MonthlyHealthDataUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutUploaderInput, MonthlyHealthDataUncheckedCreateWithoutUploaderInput> | MonthlyHealthDataCreateWithoutUploaderInput[] | MonthlyHealthDataUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutUploaderInput | MonthlyHealthDataCreateOrConnectWithoutUploaderInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutUploaderInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MonthlyHealthDataCreateManyUploaderInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutUploaderInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutUploaderInput | MonthlyHealthDataUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type FacilityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutUsersInput
    upsert?: FacilityUpsertWithoutUsersInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutUsersInput, FacilityUpdateWithoutUsersInput>, FacilityUncheckedUpdateWithoutUsersInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DataUploadSessionUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DataUploadSessionCreateWithoutUploaderInput, DataUploadSessionUncheckedCreateWithoutUploaderInput> | DataUploadSessionCreateWithoutUploaderInput[] | DataUploadSessionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DataUploadSessionCreateOrConnectWithoutUploaderInput | DataUploadSessionCreateOrConnectWithoutUploaderInput[]
    upsert?: DataUploadSessionUpsertWithWhereUniqueWithoutUploaderInput | DataUploadSessionUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DataUploadSessionCreateManyUploaderInputEnvelope
    set?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    disconnect?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    delete?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    connect?: DataUploadSessionWhereUniqueInput | DataUploadSessionWhereUniqueInput[]
    update?: DataUploadSessionUpdateWithWhereUniqueWithoutUploaderInput | DataUploadSessionUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DataUploadSessionUpdateManyWithWhereWithoutUploaderInput | DataUploadSessionUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DataUploadSessionScalarWhereInput | DataUploadSessionScalarWhereInput[]
  }

  export type FieldValueUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<FieldValueCreateWithoutUploaderInput, FieldValueUncheckedCreateWithoutUploaderInput> | FieldValueCreateWithoutUploaderInput[] | FieldValueUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutUploaderInput | FieldValueCreateOrConnectWithoutUploaderInput[]
    upsert?: FieldValueUpsertWithWhereUniqueWithoutUploaderInput | FieldValueUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: FieldValueCreateManyUploaderInputEnvelope
    set?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    disconnect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    delete?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    update?: FieldValueUpdateWithWhereUniqueWithoutUploaderInput | FieldValueUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: FieldValueUpdateManyWithWhereWithoutUploaderInput | FieldValueUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutApproverInput, MonthlyHealthDataUncheckedCreateWithoutApproverInput> | MonthlyHealthDataCreateWithoutApproverInput[] | MonthlyHealthDataUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutApproverInput | MonthlyHealthDataCreateOrConnectWithoutApproverInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutApproverInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: MonthlyHealthDataCreateManyApproverInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutApproverInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutApproverInput | MonthlyHealthDataUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutUploaderInput, MonthlyHealthDataUncheckedCreateWithoutUploaderInput> | MonthlyHealthDataCreateWithoutUploaderInput[] | MonthlyHealthDataUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutUploaderInput | MonthlyHealthDataCreateOrConnectWithoutUploaderInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutUploaderInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MonthlyHealthDataCreateManyUploaderInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutUploaderInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutUploaderInput | MonthlyHealthDataUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type FacilityCreateNestedManyWithoutDistrictInput = {
    create?: XOR<FacilityCreateWithoutDistrictInput, FacilityUncheckedCreateWithoutDistrictInput> | FacilityCreateWithoutDistrictInput[] | FacilityUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutDistrictInput | FacilityCreateOrConnectWithoutDistrictInput[]
    createMany?: FacilityCreateManyDistrictInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type MonthlyHealthDataCreateNestedManyWithoutDistrictInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutDistrictInput, MonthlyHealthDataUncheckedCreateWithoutDistrictInput> | MonthlyHealthDataCreateWithoutDistrictInput[] | MonthlyHealthDataUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutDistrictInput | MonthlyHealthDataCreateOrConnectWithoutDistrictInput[]
    createMany?: MonthlyHealthDataCreateManyDistrictInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<FacilityCreateWithoutDistrictInput, FacilityUncheckedCreateWithoutDistrictInput> | FacilityCreateWithoutDistrictInput[] | FacilityUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutDistrictInput | FacilityCreateOrConnectWithoutDistrictInput[]
    createMany?: FacilityCreateManyDistrictInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type MonthlyHealthDataUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutDistrictInput, MonthlyHealthDataUncheckedCreateWithoutDistrictInput> | MonthlyHealthDataCreateWithoutDistrictInput[] | MonthlyHealthDataUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutDistrictInput | MonthlyHealthDataCreateOrConnectWithoutDistrictInput[]
    createMany?: MonthlyHealthDataCreateManyDistrictInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FacilityUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<FacilityCreateWithoutDistrictInput, FacilityUncheckedCreateWithoutDistrictInput> | FacilityCreateWithoutDistrictInput[] | FacilityUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutDistrictInput | FacilityCreateOrConnectWithoutDistrictInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutDistrictInput | FacilityUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: FacilityCreateManyDistrictInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutDistrictInput | FacilityUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutDistrictInput | FacilityUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type MonthlyHealthDataUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutDistrictInput, MonthlyHealthDataUncheckedCreateWithoutDistrictInput> | MonthlyHealthDataCreateWithoutDistrictInput[] | MonthlyHealthDataUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutDistrictInput | MonthlyHealthDataCreateOrConnectWithoutDistrictInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutDistrictInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: MonthlyHealthDataCreateManyDistrictInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutDistrictInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutDistrictInput | MonthlyHealthDataUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<FacilityCreateWithoutDistrictInput, FacilityUncheckedCreateWithoutDistrictInput> | FacilityCreateWithoutDistrictInput[] | FacilityUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutDistrictInput | FacilityCreateOrConnectWithoutDistrictInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutDistrictInput | FacilityUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: FacilityCreateManyDistrictInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutDistrictInput | FacilityUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutDistrictInput | FacilityUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutDistrictInput, MonthlyHealthDataUncheckedCreateWithoutDistrictInput> | MonthlyHealthDataCreateWithoutDistrictInput[] | MonthlyHealthDataUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutDistrictInput | MonthlyHealthDataCreateOrConnectWithoutDistrictInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutDistrictInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: MonthlyHealthDataCreateManyDistrictInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutDistrictInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutDistrictInput | MonthlyHealthDataUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type IndicatorRemunerationCreateNestedManyWithoutRemuneration_systemInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput> | IndicatorRemunerationCreateWithoutRemuneration_systemInput[] | IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput | IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput[]
    createMany?: IndicatorRemunerationCreateManyRemuneration_systemInputEnvelope
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
  }

  export type IndicatorRemunerationUncheckedCreateNestedManyWithoutRemuneration_systemInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput> | IndicatorRemunerationCreateWithoutRemuneration_systemInput[] | IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput | IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput[]
    createMany?: IndicatorRemunerationCreateManyRemuneration_systemInputEnvelope
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IndicatorRemunerationUpdateManyWithoutRemuneration_systemNestedInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput> | IndicatorRemunerationCreateWithoutRemuneration_systemInput[] | IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput | IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput[]
    upsert?: IndicatorRemunerationUpsertWithWhereUniqueWithoutRemuneration_systemInput | IndicatorRemunerationUpsertWithWhereUniqueWithoutRemuneration_systemInput[]
    createMany?: IndicatorRemunerationCreateManyRemuneration_systemInputEnvelope
    set?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    disconnect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    delete?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    update?: IndicatorRemunerationUpdateWithWhereUniqueWithoutRemuneration_systemInput | IndicatorRemunerationUpdateWithWhereUniqueWithoutRemuneration_systemInput[]
    updateMany?: IndicatorRemunerationUpdateManyWithWhereWithoutRemuneration_systemInput | IndicatorRemunerationUpdateManyWithWhereWithoutRemuneration_systemInput[]
    deleteMany?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
  }

  export type IndicatorRemunerationUncheckedUpdateManyWithoutRemuneration_systemNestedInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput> | IndicatorRemunerationCreateWithoutRemuneration_systemInput[] | IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput | IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput[]
    upsert?: IndicatorRemunerationUpsertWithWhereUniqueWithoutRemuneration_systemInput | IndicatorRemunerationUpsertWithWhereUniqueWithoutRemuneration_systemInput[]
    createMany?: IndicatorRemunerationCreateManyRemuneration_systemInputEnvelope
    set?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    disconnect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    delete?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    update?: IndicatorRemunerationUpdateWithWhereUniqueWithoutRemuneration_systemInput | IndicatorRemunerationUpdateWithWhereUniqueWithoutRemuneration_systemInput[]
    updateMany?: IndicatorRemunerationUpdateManyWithWhereWithoutRemuneration_systemInput | IndicatorRemunerationUpdateManyWithWhereWithoutRemuneration_systemInput[]
    deleteMany?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
  }

  export type FacilityCreateNestedManyWithoutFacility_typeInput = {
    create?: XOR<FacilityCreateWithoutFacility_typeInput, FacilityUncheckedCreateWithoutFacility_typeInput> | FacilityCreateWithoutFacility_typeInput[] | FacilityUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_typeInput | FacilityCreateOrConnectWithoutFacility_typeInput[]
    createMany?: FacilityCreateManyFacility_typeInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type FacilityFieldMappingCreateNestedManyWithoutFacility_typeInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFacility_typeInput, FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput> | FacilityFieldMappingCreateWithoutFacility_typeInput[] | FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput | FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput[]
    createMany?: FacilityFieldMappingCreateManyFacility_typeInputEnvelope
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
  }

  export type FacilityTypeRemunerationCreateNestedOneWithoutFacility_typeInput = {
    create?: XOR<FacilityTypeRemunerationCreateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput>
    connectOrCreate?: FacilityTypeRemunerationCreateOrConnectWithoutFacility_typeInput
    connect?: FacilityTypeRemunerationWhereUniqueInput
  }

  export type WorkerAllocationConfigCreateNestedManyWithoutFacility_typeInput = {
    create?: XOR<WorkerAllocationConfigCreateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput> | WorkerAllocationConfigCreateWithoutFacility_typeInput[] | WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput | WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput[]
    createMany?: WorkerAllocationConfigCreateManyFacility_typeInputEnvelope
    connect?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
  }

  export type FacilityUncheckedCreateNestedManyWithoutFacility_typeInput = {
    create?: XOR<FacilityCreateWithoutFacility_typeInput, FacilityUncheckedCreateWithoutFacility_typeInput> | FacilityCreateWithoutFacility_typeInput[] | FacilityUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_typeInput | FacilityCreateOrConnectWithoutFacility_typeInput[]
    createMany?: FacilityCreateManyFacility_typeInputEnvelope
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
  }

  export type FacilityFieldMappingUncheckedCreateNestedManyWithoutFacility_typeInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFacility_typeInput, FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput> | FacilityFieldMappingCreateWithoutFacility_typeInput[] | FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput | FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput[]
    createMany?: FacilityFieldMappingCreateManyFacility_typeInputEnvelope
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
  }

  export type FacilityTypeRemunerationUncheckedCreateNestedOneWithoutFacility_typeInput = {
    create?: XOR<FacilityTypeRemunerationCreateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput>
    connectOrCreate?: FacilityTypeRemunerationCreateOrConnectWithoutFacility_typeInput
    connect?: FacilityTypeRemunerationWhereUniqueInput
  }

  export type WorkerAllocationConfigUncheckedCreateNestedManyWithoutFacility_typeInput = {
    create?: XOR<WorkerAllocationConfigCreateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput> | WorkerAllocationConfigCreateWithoutFacility_typeInput[] | WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput | WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput[]
    createMany?: WorkerAllocationConfigCreateManyFacility_typeInputEnvelope
    connect?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
  }

  export type FacilityUpdateManyWithoutFacility_typeNestedInput = {
    create?: XOR<FacilityCreateWithoutFacility_typeInput, FacilityUncheckedCreateWithoutFacility_typeInput> | FacilityCreateWithoutFacility_typeInput[] | FacilityUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_typeInput | FacilityCreateOrConnectWithoutFacility_typeInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutFacility_typeInput | FacilityUpsertWithWhereUniqueWithoutFacility_typeInput[]
    createMany?: FacilityCreateManyFacility_typeInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutFacility_typeInput | FacilityUpdateWithWhereUniqueWithoutFacility_typeInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutFacility_typeInput | FacilityUpdateManyWithWhereWithoutFacility_typeInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type FacilityFieldMappingUpdateManyWithoutFacility_typeNestedInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFacility_typeInput, FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput> | FacilityFieldMappingCreateWithoutFacility_typeInput[] | FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput | FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput[]
    upsert?: FacilityFieldMappingUpsertWithWhereUniqueWithoutFacility_typeInput | FacilityFieldMappingUpsertWithWhereUniqueWithoutFacility_typeInput[]
    createMany?: FacilityFieldMappingCreateManyFacility_typeInputEnvelope
    set?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    disconnect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    delete?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    update?: FacilityFieldMappingUpdateWithWhereUniqueWithoutFacility_typeInput | FacilityFieldMappingUpdateWithWhereUniqueWithoutFacility_typeInput[]
    updateMany?: FacilityFieldMappingUpdateManyWithWhereWithoutFacility_typeInput | FacilityFieldMappingUpdateManyWithWhereWithoutFacility_typeInput[]
    deleteMany?: FacilityFieldMappingScalarWhereInput | FacilityFieldMappingScalarWhereInput[]
  }

  export type FacilityTypeRemunerationUpdateOneWithoutFacility_typeNestedInput = {
    create?: XOR<FacilityTypeRemunerationCreateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput>
    connectOrCreate?: FacilityTypeRemunerationCreateOrConnectWithoutFacility_typeInput
    upsert?: FacilityTypeRemunerationUpsertWithoutFacility_typeInput
    disconnect?: FacilityTypeRemunerationWhereInput | boolean
    delete?: FacilityTypeRemunerationWhereInput | boolean
    connect?: FacilityTypeRemunerationWhereUniqueInput
    update?: XOR<XOR<FacilityTypeRemunerationUpdateToOneWithWhereWithoutFacility_typeInput, FacilityTypeRemunerationUpdateWithoutFacility_typeInput>, FacilityTypeRemunerationUncheckedUpdateWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigUpdateManyWithoutFacility_typeNestedInput = {
    create?: XOR<WorkerAllocationConfigCreateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput> | WorkerAllocationConfigCreateWithoutFacility_typeInput[] | WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput | WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput[]
    upsert?: WorkerAllocationConfigUpsertWithWhereUniqueWithoutFacility_typeInput | WorkerAllocationConfigUpsertWithWhereUniqueWithoutFacility_typeInput[]
    createMany?: WorkerAllocationConfigCreateManyFacility_typeInputEnvelope
    set?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    disconnect?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    delete?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    connect?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    update?: WorkerAllocationConfigUpdateWithWhereUniqueWithoutFacility_typeInput | WorkerAllocationConfigUpdateWithWhereUniqueWithoutFacility_typeInput[]
    updateMany?: WorkerAllocationConfigUpdateManyWithWhereWithoutFacility_typeInput | WorkerAllocationConfigUpdateManyWithWhereWithoutFacility_typeInput[]
    deleteMany?: WorkerAllocationConfigScalarWhereInput | WorkerAllocationConfigScalarWhereInput[]
  }

  export type FacilityUncheckedUpdateManyWithoutFacility_typeNestedInput = {
    create?: XOR<FacilityCreateWithoutFacility_typeInput, FacilityUncheckedCreateWithoutFacility_typeInput> | FacilityCreateWithoutFacility_typeInput[] | FacilityUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_typeInput | FacilityCreateOrConnectWithoutFacility_typeInput[]
    upsert?: FacilityUpsertWithWhereUniqueWithoutFacility_typeInput | FacilityUpsertWithWhereUniqueWithoutFacility_typeInput[]
    createMany?: FacilityCreateManyFacility_typeInputEnvelope
    set?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    disconnect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    delete?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    connect?: FacilityWhereUniqueInput | FacilityWhereUniqueInput[]
    update?: FacilityUpdateWithWhereUniqueWithoutFacility_typeInput | FacilityUpdateWithWhereUniqueWithoutFacility_typeInput[]
    updateMany?: FacilityUpdateManyWithWhereWithoutFacility_typeInput | FacilityUpdateManyWithWhereWithoutFacility_typeInput[]
    deleteMany?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
  }

  export type FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeNestedInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFacility_typeInput, FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput> | FacilityFieldMappingCreateWithoutFacility_typeInput[] | FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput | FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput[]
    upsert?: FacilityFieldMappingUpsertWithWhereUniqueWithoutFacility_typeInput | FacilityFieldMappingUpsertWithWhereUniqueWithoutFacility_typeInput[]
    createMany?: FacilityFieldMappingCreateManyFacility_typeInputEnvelope
    set?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    disconnect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    delete?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    update?: FacilityFieldMappingUpdateWithWhereUniqueWithoutFacility_typeInput | FacilityFieldMappingUpdateWithWhereUniqueWithoutFacility_typeInput[]
    updateMany?: FacilityFieldMappingUpdateManyWithWhereWithoutFacility_typeInput | FacilityFieldMappingUpdateManyWithWhereWithoutFacility_typeInput[]
    deleteMany?: FacilityFieldMappingScalarWhereInput | FacilityFieldMappingScalarWhereInput[]
  }

  export type FacilityTypeRemunerationUncheckedUpdateOneWithoutFacility_typeNestedInput = {
    create?: XOR<FacilityTypeRemunerationCreateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput>
    connectOrCreate?: FacilityTypeRemunerationCreateOrConnectWithoutFacility_typeInput
    upsert?: FacilityTypeRemunerationUpsertWithoutFacility_typeInput
    disconnect?: FacilityTypeRemunerationWhereInput | boolean
    delete?: FacilityTypeRemunerationWhereInput | boolean
    connect?: FacilityTypeRemunerationWhereUniqueInput
    update?: XOR<XOR<FacilityTypeRemunerationUpdateToOneWithWhereWithoutFacility_typeInput, FacilityTypeRemunerationUpdateWithoutFacility_typeInput>, FacilityTypeRemunerationUncheckedUpdateWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeNestedInput = {
    create?: XOR<WorkerAllocationConfigCreateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput> | WorkerAllocationConfigCreateWithoutFacility_typeInput[] | WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput[]
    connectOrCreate?: WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput | WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput[]
    upsert?: WorkerAllocationConfigUpsertWithWhereUniqueWithoutFacility_typeInput | WorkerAllocationConfigUpsertWithWhereUniqueWithoutFacility_typeInput[]
    createMany?: WorkerAllocationConfigCreateManyFacility_typeInputEnvelope
    set?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    disconnect?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    delete?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    connect?: WorkerAllocationConfigWhereUniqueInput | WorkerAllocationConfigWhereUniqueInput[]
    update?: WorkerAllocationConfigUpdateWithWhereUniqueWithoutFacility_typeInput | WorkerAllocationConfigUpdateWithWhereUniqueWithoutFacility_typeInput[]
    updateMany?: WorkerAllocationConfigUpdateManyWithWhereWithoutFacility_typeInput | WorkerAllocationConfigUpdateManyWithWhereWithoutFacility_typeInput[]
    deleteMany?: WorkerAllocationConfigScalarWhereInput | WorkerAllocationConfigScalarWhereInput[]
  }

  export type DistrictCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<DistrictCreateWithoutFacilitiesInput, DistrictUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutFacilitiesInput
    connect?: DistrictWhereUniqueInput
  }

  export type FacilityTypeCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<FacilityTypeCreateWithoutFacilitiesInput, FacilityTypeUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutFacilitiesInput
    connect?: FacilityTypeWhereUniqueInput
  }

  export type FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFacilityInput, FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput> | FacilityFieldDefaultsCreateWithoutFacilityInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput | FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityFieldDefaultsCreateManyFacilityInputEnvelope
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
  }

  export type FacilityTargetCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityTargetCreateWithoutFacilityInput, FacilityTargetUncheckedCreateWithoutFacilityInput> | FacilityTargetCreateWithoutFacilityInput[] | FacilityTargetUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutFacilityInput | FacilityTargetCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityTargetCreateManyFacilityInputEnvelope
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
  }

  export type FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutFacilityInput, FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput> | FacilityWorkerAllocationCreateWithoutFacilityInput[] | FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput | FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityWorkerAllocationCreateManyFacilityInputEnvelope
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
  }

  export type FieldValueCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FieldValueCreateWithoutFacilityInput, FieldValueUncheckedCreateWithoutFacilityInput> | FieldValueCreateWithoutFacilityInput[] | FieldValueUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFacilityInput | FieldValueCreateOrConnectWithoutFacilityInput[]
    createMany?: FieldValueCreateManyFacilityInputEnvelope
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
  }

  export type HealthWorkerCreateNestedManyWithoutFacilityInput = {
    create?: XOR<HealthWorkerCreateWithoutFacilityInput, HealthWorkerUncheckedCreateWithoutFacilityInput> | HealthWorkerCreateWithoutFacilityInput[] | HealthWorkerUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutFacilityInput | HealthWorkerCreateOrConnectWithoutFacilityInput[]
    createMany?: HealthWorkerCreateManyFacilityInputEnvelope
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
  }

  export type MonthlyHealthDataCreateNestedManyWithoutFacilityInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutFacilityInput, MonthlyHealthDataUncheckedCreateWithoutFacilityInput> | MonthlyHealthDataCreateWithoutFacilityInput[] | MonthlyHealthDataUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutFacilityInput | MonthlyHealthDataCreateOrConnectWithoutFacilityInput[]
    createMany?: MonthlyHealthDataCreateManyFacilityInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type PerformanceCalculationCreateNestedManyWithoutFacilityInput = {
    create?: XOR<PerformanceCalculationCreateWithoutFacilityInput, PerformanceCalculationUncheckedCreateWithoutFacilityInput> | PerformanceCalculationCreateWithoutFacilityInput[] | PerformanceCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutFacilityInput | PerformanceCalculationCreateOrConnectWithoutFacilityInput[]
    createMany?: PerformanceCalculationCreateManyFacilityInputEnvelope
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
  }

  export type RemunerationCalculationCreateNestedManyWithoutFacilityInput = {
    create?: XOR<RemunerationCalculationCreateWithoutFacilityInput, RemunerationCalculationUncheckedCreateWithoutFacilityInput> | RemunerationCalculationCreateWithoutFacilityInput[] | RemunerationCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: RemunerationCalculationCreateOrConnectWithoutFacilityInput | RemunerationCalculationCreateOrConnectWithoutFacilityInput[]
    createMany?: RemunerationCalculationCreateManyFacilityInputEnvelope
    connect?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
  }

  export type sub_centreCreateNestedManyWithoutFacilityInput = {
    create?: XOR<sub_centreCreateWithoutFacilityInput, sub_centreUncheckedCreateWithoutFacilityInput> | sub_centreCreateWithoutFacilityInput[] | sub_centreUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: sub_centreCreateOrConnectWithoutFacilityInput | sub_centreCreateOrConnectWithoutFacilityInput[]
    createMany?: sub_centreCreateManyFacilityInputEnvelope
    connect?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutFacilityInput = {
    create?: XOR<UserCreateWithoutFacilityInput, UserUncheckedCreateWithoutFacilityInput> | UserCreateWithoutFacilityInput[] | UserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacilityInput | UserCreateOrConnectWithoutFacilityInput[]
    createMany?: UserCreateManyFacilityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFacilityInput, FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput> | FacilityFieldDefaultsCreateWithoutFacilityInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput | FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityFieldDefaultsCreateManyFacilityInputEnvelope
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
  }

  export type FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityTargetCreateWithoutFacilityInput, FacilityTargetUncheckedCreateWithoutFacilityInput> | FacilityTargetCreateWithoutFacilityInput[] | FacilityTargetUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutFacilityInput | FacilityTargetCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityTargetCreateManyFacilityInputEnvelope
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
  }

  export type FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutFacilityInput, FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput> | FacilityWorkerAllocationCreateWithoutFacilityInput[] | FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput | FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput[]
    createMany?: FacilityWorkerAllocationCreateManyFacilityInputEnvelope
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
  }

  export type FieldValueUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<FieldValueCreateWithoutFacilityInput, FieldValueUncheckedCreateWithoutFacilityInput> | FieldValueCreateWithoutFacilityInput[] | FieldValueUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFacilityInput | FieldValueCreateOrConnectWithoutFacilityInput[]
    createMany?: FieldValueCreateManyFacilityInputEnvelope
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
  }

  export type HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<HealthWorkerCreateWithoutFacilityInput, HealthWorkerUncheckedCreateWithoutFacilityInput> | HealthWorkerCreateWithoutFacilityInput[] | HealthWorkerUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutFacilityInput | HealthWorkerCreateOrConnectWithoutFacilityInput[]
    createMany?: HealthWorkerCreateManyFacilityInputEnvelope
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
  }

  export type MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutFacilityInput, MonthlyHealthDataUncheckedCreateWithoutFacilityInput> | MonthlyHealthDataCreateWithoutFacilityInput[] | MonthlyHealthDataUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutFacilityInput | MonthlyHealthDataCreateOrConnectWithoutFacilityInput[]
    createMany?: MonthlyHealthDataCreateManyFacilityInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<PerformanceCalculationCreateWithoutFacilityInput, PerformanceCalculationUncheckedCreateWithoutFacilityInput> | PerformanceCalculationCreateWithoutFacilityInput[] | PerformanceCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutFacilityInput | PerformanceCalculationCreateOrConnectWithoutFacilityInput[]
    createMany?: PerformanceCalculationCreateManyFacilityInputEnvelope
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
  }

  export type RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<RemunerationCalculationCreateWithoutFacilityInput, RemunerationCalculationUncheckedCreateWithoutFacilityInput> | RemunerationCalculationCreateWithoutFacilityInput[] | RemunerationCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: RemunerationCalculationCreateOrConnectWithoutFacilityInput | RemunerationCalculationCreateOrConnectWithoutFacilityInput[]
    createMany?: RemunerationCalculationCreateManyFacilityInputEnvelope
    connect?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
  }

  export type sub_centreUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<sub_centreCreateWithoutFacilityInput, sub_centreUncheckedCreateWithoutFacilityInput> | sub_centreCreateWithoutFacilityInput[] | sub_centreUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: sub_centreCreateOrConnectWithoutFacilityInput | sub_centreCreateOrConnectWithoutFacilityInput[]
    createMany?: sub_centreCreateManyFacilityInputEnvelope
    connect?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<UserCreateWithoutFacilityInput, UserUncheckedCreateWithoutFacilityInput> | UserCreateWithoutFacilityInput[] | UserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacilityInput | UserCreateOrConnectWithoutFacilityInput[]
    createMany?: UserCreateManyFacilityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DistrictUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<DistrictCreateWithoutFacilitiesInput, DistrictUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutFacilitiesInput
    upsert?: DistrictUpsertWithoutFacilitiesInput
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutFacilitiesInput, DistrictUpdateWithoutFacilitiesInput>, DistrictUncheckedUpdateWithoutFacilitiesInput>
  }

  export type FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput = {
    create?: XOR<FacilityTypeCreateWithoutFacilitiesInput, FacilityTypeUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutFacilitiesInput
    upsert?: FacilityTypeUpsertWithoutFacilitiesInput
    connect?: FacilityTypeWhereUniqueInput
    update?: XOR<XOR<FacilityTypeUpdateToOneWithWhereWithoutFacilitiesInput, FacilityTypeUpdateWithoutFacilitiesInput>, FacilityTypeUncheckedUpdateWithoutFacilitiesInput>
  }

  export type FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFacilityInput, FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput> | FacilityFieldDefaultsCreateWithoutFacilityInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput | FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFacilityInput | FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityFieldDefaultsCreateManyFacilityInputEnvelope
    set?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    disconnect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    delete?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    update?: FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFacilityInput | FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityFieldDefaultsUpdateManyWithWhereWithoutFacilityInput | FacilityFieldDefaultsUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityFieldDefaultsScalarWhereInput | FacilityFieldDefaultsScalarWhereInput[]
  }

  export type FacilityTargetUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityTargetCreateWithoutFacilityInput, FacilityTargetUncheckedCreateWithoutFacilityInput> | FacilityTargetCreateWithoutFacilityInput[] | FacilityTargetUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutFacilityInput | FacilityTargetCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityTargetUpsertWithWhereUniqueWithoutFacilityInput | FacilityTargetUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityTargetCreateManyFacilityInputEnvelope
    set?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    disconnect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    delete?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    update?: FacilityTargetUpdateWithWhereUniqueWithoutFacilityInput | FacilityTargetUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityTargetUpdateManyWithWhereWithoutFacilityInput | FacilityTargetUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityTargetScalarWhereInput | FacilityTargetScalarWhereInput[]
  }

  export type FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutFacilityInput, FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput> | FacilityWorkerAllocationCreateWithoutFacilityInput[] | FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput | FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityWorkerAllocationUpsertWithWhereUniqueWithoutFacilityInput | FacilityWorkerAllocationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityWorkerAllocationCreateManyFacilityInputEnvelope
    set?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    disconnect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    delete?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    update?: FacilityWorkerAllocationUpdateWithWhereUniqueWithoutFacilityInput | FacilityWorkerAllocationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityWorkerAllocationUpdateManyWithWhereWithoutFacilityInput | FacilityWorkerAllocationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityWorkerAllocationScalarWhereInput | FacilityWorkerAllocationScalarWhereInput[]
  }

  export type FieldValueUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FieldValueCreateWithoutFacilityInput, FieldValueUncheckedCreateWithoutFacilityInput> | FieldValueCreateWithoutFacilityInput[] | FieldValueUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFacilityInput | FieldValueCreateOrConnectWithoutFacilityInput[]
    upsert?: FieldValueUpsertWithWhereUniqueWithoutFacilityInput | FieldValueUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FieldValueCreateManyFacilityInputEnvelope
    set?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    disconnect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    delete?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    update?: FieldValueUpdateWithWhereUniqueWithoutFacilityInput | FieldValueUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FieldValueUpdateManyWithWhereWithoutFacilityInput | FieldValueUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
  }

  export type HealthWorkerUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<HealthWorkerCreateWithoutFacilityInput, HealthWorkerUncheckedCreateWithoutFacilityInput> | HealthWorkerCreateWithoutFacilityInput[] | HealthWorkerUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutFacilityInput | HealthWorkerCreateOrConnectWithoutFacilityInput[]
    upsert?: HealthWorkerUpsertWithWhereUniqueWithoutFacilityInput | HealthWorkerUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: HealthWorkerCreateManyFacilityInputEnvelope
    set?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    disconnect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    delete?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    update?: HealthWorkerUpdateWithWhereUniqueWithoutFacilityInput | HealthWorkerUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: HealthWorkerUpdateManyWithWhereWithoutFacilityInput | HealthWorkerUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
  }

  export type MonthlyHealthDataUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutFacilityInput, MonthlyHealthDataUncheckedCreateWithoutFacilityInput> | MonthlyHealthDataCreateWithoutFacilityInput[] | MonthlyHealthDataUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutFacilityInput | MonthlyHealthDataCreateOrConnectWithoutFacilityInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutFacilityInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: MonthlyHealthDataCreateManyFacilityInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutFacilityInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutFacilityInput | MonthlyHealthDataUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type PerformanceCalculationUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<PerformanceCalculationCreateWithoutFacilityInput, PerformanceCalculationUncheckedCreateWithoutFacilityInput> | PerformanceCalculationCreateWithoutFacilityInput[] | PerformanceCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutFacilityInput | PerformanceCalculationCreateOrConnectWithoutFacilityInput[]
    upsert?: PerformanceCalculationUpsertWithWhereUniqueWithoutFacilityInput | PerformanceCalculationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: PerformanceCalculationCreateManyFacilityInputEnvelope
    set?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    disconnect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    delete?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    update?: PerformanceCalculationUpdateWithWhereUniqueWithoutFacilityInput | PerformanceCalculationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: PerformanceCalculationUpdateManyWithWhereWithoutFacilityInput | PerformanceCalculationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
  }

  export type RemunerationCalculationUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<RemunerationCalculationCreateWithoutFacilityInput, RemunerationCalculationUncheckedCreateWithoutFacilityInput> | RemunerationCalculationCreateWithoutFacilityInput[] | RemunerationCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: RemunerationCalculationCreateOrConnectWithoutFacilityInput | RemunerationCalculationCreateOrConnectWithoutFacilityInput[]
    upsert?: RemunerationCalculationUpsertWithWhereUniqueWithoutFacilityInput | RemunerationCalculationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: RemunerationCalculationCreateManyFacilityInputEnvelope
    set?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    disconnect?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    delete?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    connect?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    update?: RemunerationCalculationUpdateWithWhereUniqueWithoutFacilityInput | RemunerationCalculationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: RemunerationCalculationUpdateManyWithWhereWithoutFacilityInput | RemunerationCalculationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: RemunerationCalculationScalarWhereInput | RemunerationCalculationScalarWhereInput[]
  }

  export type sub_centreUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<sub_centreCreateWithoutFacilityInput, sub_centreUncheckedCreateWithoutFacilityInput> | sub_centreCreateWithoutFacilityInput[] | sub_centreUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: sub_centreCreateOrConnectWithoutFacilityInput | sub_centreCreateOrConnectWithoutFacilityInput[]
    upsert?: sub_centreUpsertWithWhereUniqueWithoutFacilityInput | sub_centreUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: sub_centreCreateManyFacilityInputEnvelope
    set?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    disconnect?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    delete?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    connect?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    update?: sub_centreUpdateWithWhereUniqueWithoutFacilityInput | sub_centreUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: sub_centreUpdateManyWithWhereWithoutFacilityInput | sub_centreUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: sub_centreScalarWhereInput | sub_centreScalarWhereInput[]
  }

  export type UserUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<UserCreateWithoutFacilityInput, UserUncheckedCreateWithoutFacilityInput> | UserCreateWithoutFacilityInput[] | UserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacilityInput | UserCreateOrConnectWithoutFacilityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFacilityInput | UserUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: UserCreateManyFacilityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFacilityInput | UserUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFacilityInput | UserUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFacilityInput, FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput> | FacilityFieldDefaultsCreateWithoutFacilityInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput | FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFacilityInput | FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityFieldDefaultsCreateManyFacilityInputEnvelope
    set?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    disconnect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    delete?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    update?: FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFacilityInput | FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityFieldDefaultsUpdateManyWithWhereWithoutFacilityInput | FacilityFieldDefaultsUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityFieldDefaultsScalarWhereInput | FacilityFieldDefaultsScalarWhereInput[]
  }

  export type FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityTargetCreateWithoutFacilityInput, FacilityTargetUncheckedCreateWithoutFacilityInput> | FacilityTargetCreateWithoutFacilityInput[] | FacilityTargetUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutFacilityInput | FacilityTargetCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityTargetUpsertWithWhereUniqueWithoutFacilityInput | FacilityTargetUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityTargetCreateManyFacilityInputEnvelope
    set?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    disconnect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    delete?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    update?: FacilityTargetUpdateWithWhereUniqueWithoutFacilityInput | FacilityTargetUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityTargetUpdateManyWithWhereWithoutFacilityInput | FacilityTargetUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityTargetScalarWhereInput | FacilityTargetScalarWhereInput[]
  }

  export type FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutFacilityInput, FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput> | FacilityWorkerAllocationCreateWithoutFacilityInput[] | FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput | FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput[]
    upsert?: FacilityWorkerAllocationUpsertWithWhereUniqueWithoutFacilityInput | FacilityWorkerAllocationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FacilityWorkerAllocationCreateManyFacilityInputEnvelope
    set?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    disconnect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    delete?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    update?: FacilityWorkerAllocationUpdateWithWhereUniqueWithoutFacilityInput | FacilityWorkerAllocationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FacilityWorkerAllocationUpdateManyWithWhereWithoutFacilityInput | FacilityWorkerAllocationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FacilityWorkerAllocationScalarWhereInput | FacilityWorkerAllocationScalarWhereInput[]
  }

  export type FieldValueUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<FieldValueCreateWithoutFacilityInput, FieldValueUncheckedCreateWithoutFacilityInput> | FieldValueCreateWithoutFacilityInput[] | FieldValueUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFacilityInput | FieldValueCreateOrConnectWithoutFacilityInput[]
    upsert?: FieldValueUpsertWithWhereUniqueWithoutFacilityInput | FieldValueUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: FieldValueCreateManyFacilityInputEnvelope
    set?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    disconnect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    delete?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    update?: FieldValueUpdateWithWhereUniqueWithoutFacilityInput | FieldValueUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: FieldValueUpdateManyWithWhereWithoutFacilityInput | FieldValueUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
  }

  export type HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<HealthWorkerCreateWithoutFacilityInput, HealthWorkerUncheckedCreateWithoutFacilityInput> | HealthWorkerCreateWithoutFacilityInput[] | HealthWorkerUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutFacilityInput | HealthWorkerCreateOrConnectWithoutFacilityInput[]
    upsert?: HealthWorkerUpsertWithWhereUniqueWithoutFacilityInput | HealthWorkerUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: HealthWorkerCreateManyFacilityInputEnvelope
    set?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    disconnect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    delete?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    update?: HealthWorkerUpdateWithWhereUniqueWithoutFacilityInput | HealthWorkerUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: HealthWorkerUpdateManyWithWhereWithoutFacilityInput | HealthWorkerUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutFacilityInput, MonthlyHealthDataUncheckedCreateWithoutFacilityInput> | MonthlyHealthDataCreateWithoutFacilityInput[] | MonthlyHealthDataUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutFacilityInput | MonthlyHealthDataCreateOrConnectWithoutFacilityInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutFacilityInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: MonthlyHealthDataCreateManyFacilityInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutFacilityInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutFacilityInput | MonthlyHealthDataUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<PerformanceCalculationCreateWithoutFacilityInput, PerformanceCalculationUncheckedCreateWithoutFacilityInput> | PerformanceCalculationCreateWithoutFacilityInput[] | PerformanceCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutFacilityInput | PerformanceCalculationCreateOrConnectWithoutFacilityInput[]
    upsert?: PerformanceCalculationUpsertWithWhereUniqueWithoutFacilityInput | PerformanceCalculationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: PerformanceCalculationCreateManyFacilityInputEnvelope
    set?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    disconnect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    delete?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    update?: PerformanceCalculationUpdateWithWhereUniqueWithoutFacilityInput | PerformanceCalculationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: PerformanceCalculationUpdateManyWithWhereWithoutFacilityInput | PerformanceCalculationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
  }

  export type RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<RemunerationCalculationCreateWithoutFacilityInput, RemunerationCalculationUncheckedCreateWithoutFacilityInput> | RemunerationCalculationCreateWithoutFacilityInput[] | RemunerationCalculationUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: RemunerationCalculationCreateOrConnectWithoutFacilityInput | RemunerationCalculationCreateOrConnectWithoutFacilityInput[]
    upsert?: RemunerationCalculationUpsertWithWhereUniqueWithoutFacilityInput | RemunerationCalculationUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: RemunerationCalculationCreateManyFacilityInputEnvelope
    set?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    disconnect?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    delete?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    connect?: RemunerationCalculationWhereUniqueInput | RemunerationCalculationWhereUniqueInput[]
    update?: RemunerationCalculationUpdateWithWhereUniqueWithoutFacilityInput | RemunerationCalculationUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: RemunerationCalculationUpdateManyWithWhereWithoutFacilityInput | RemunerationCalculationUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: RemunerationCalculationScalarWhereInput | RemunerationCalculationScalarWhereInput[]
  }

  export type sub_centreUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<sub_centreCreateWithoutFacilityInput, sub_centreUncheckedCreateWithoutFacilityInput> | sub_centreCreateWithoutFacilityInput[] | sub_centreUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: sub_centreCreateOrConnectWithoutFacilityInput | sub_centreCreateOrConnectWithoutFacilityInput[]
    upsert?: sub_centreUpsertWithWhereUniqueWithoutFacilityInput | sub_centreUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: sub_centreCreateManyFacilityInputEnvelope
    set?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    disconnect?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    delete?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    connect?: sub_centreWhereUniqueInput | sub_centreWhereUniqueInput[]
    update?: sub_centreUpdateWithWhereUniqueWithoutFacilityInput | sub_centreUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: sub_centreUpdateManyWithWhereWithoutFacilityInput | sub_centreUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: sub_centreScalarWhereInput | sub_centreScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<UserCreateWithoutFacilityInput, UserUncheckedCreateWithoutFacilityInput> | UserCreateWithoutFacilityInput[] | UserUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacilityInput | UserCreateOrConnectWithoutFacilityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFacilityInput | UserUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: UserCreateManyFacilityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFacilityInput | UserUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFacilityInput | UserUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutApproved_dataInput = {
    create?: XOR<UserCreateWithoutApproved_dataInput, UserUncheckedCreateWithoutApproved_dataInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproved_dataInput
    connect?: UserWhereUniqueInput
  }

  export type DistrictCreateNestedOneWithoutMonthly_dataInput = {
    create?: XOR<DistrictCreateWithoutMonthly_dataInput, DistrictUncheckedCreateWithoutMonthly_dataInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutMonthly_dataInput
    connect?: DistrictWhereUniqueInput
  }

  export type FacilityCreateNestedOneWithoutMonthly_dataInput = {
    create?: XOR<FacilityCreateWithoutMonthly_dataInput, FacilityUncheckedCreateWithoutMonthly_dataInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutMonthly_dataInput
    connect?: FacilityWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutMonthly_dataInput = {
    create?: XOR<IndicatorCreateWithoutMonthly_dataInput, IndicatorUncheckedCreateWithoutMonthly_dataInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutMonthly_dataInput
    connect?: IndicatorWhereUniqueInput
  }

  export type sub_centreCreateNestedOneWithoutMonthly_health_dataInput = {
    create?: XOR<sub_centreCreateWithoutMonthly_health_dataInput, sub_centreUncheckedCreateWithoutMonthly_health_dataInput>
    connectOrCreate?: sub_centreCreateOrConnectWithoutMonthly_health_dataInput
    connect?: sub_centreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploaded_dataInput = {
    create?: XOR<UserCreateWithoutUploaded_dataInput, UserUncheckedCreateWithoutUploaded_dataInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploaded_dataInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumDataQualityFieldUpdateOperationsInput = {
    set?: $Enums.DataQuality
  }

  export type UserUpdateOneWithoutApproved_dataNestedInput = {
    create?: XOR<UserCreateWithoutApproved_dataInput, UserUncheckedCreateWithoutApproved_dataInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproved_dataInput
    upsert?: UserUpsertWithoutApproved_dataInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApproved_dataInput, UserUpdateWithoutApproved_dataInput>, UserUncheckedUpdateWithoutApproved_dataInput>
  }

  export type DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput = {
    create?: XOR<DistrictCreateWithoutMonthly_dataInput, DistrictUncheckedCreateWithoutMonthly_dataInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutMonthly_dataInput
    upsert?: DistrictUpsertWithoutMonthly_dataInput
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutMonthly_dataInput, DistrictUpdateWithoutMonthly_dataInput>, DistrictUncheckedUpdateWithoutMonthly_dataInput>
  }

  export type FacilityUpdateOneWithoutMonthly_dataNestedInput = {
    create?: XOR<FacilityCreateWithoutMonthly_dataInput, FacilityUncheckedCreateWithoutMonthly_dataInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutMonthly_dataInput
    upsert?: FacilityUpsertWithoutMonthly_dataInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutMonthly_dataInput, FacilityUpdateWithoutMonthly_dataInput>, FacilityUncheckedUpdateWithoutMonthly_dataInput>
  }

  export type IndicatorUpdateOneWithoutMonthly_dataNestedInput = {
    create?: XOR<IndicatorCreateWithoutMonthly_dataInput, IndicatorUncheckedCreateWithoutMonthly_dataInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutMonthly_dataInput
    upsert?: IndicatorUpsertWithoutMonthly_dataInput
    disconnect?: IndicatorWhereInput | boolean
    delete?: IndicatorWhereInput | boolean
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutMonthly_dataInput, IndicatorUpdateWithoutMonthly_dataInput>, IndicatorUncheckedUpdateWithoutMonthly_dataInput>
  }

  export type sub_centreUpdateOneWithoutMonthly_health_dataNestedInput = {
    create?: XOR<sub_centreCreateWithoutMonthly_health_dataInput, sub_centreUncheckedCreateWithoutMonthly_health_dataInput>
    connectOrCreate?: sub_centreCreateOrConnectWithoutMonthly_health_dataInput
    upsert?: sub_centreUpsertWithoutMonthly_health_dataInput
    disconnect?: sub_centreWhereInput | boolean
    delete?: sub_centreWhereInput | boolean
    connect?: sub_centreWhereUniqueInput
    update?: XOR<XOR<sub_centreUpdateToOneWithWhereWithoutMonthly_health_dataInput, sub_centreUpdateWithoutMonthly_health_dataInput>, sub_centreUncheckedUpdateWithoutMonthly_health_dataInput>
  }

  export type UserUpdateOneRequiredWithoutUploaded_dataNestedInput = {
    create?: XOR<UserCreateWithoutUploaded_dataInput, UserUncheckedCreateWithoutUploaded_dataInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploaded_dataInput
    upsert?: UserUpsertWithoutUploaded_dataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploaded_dataInput, UserUpdateWithoutUploaded_dataInput>, UserUncheckedUpdateWithoutUploaded_dataInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutUpload_sessionsInput = {
    create?: XOR<UserCreateWithoutUpload_sessionsInput, UserUncheckedCreateWithoutUpload_sessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpload_sessionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUploadStatusFieldUpdateOperationsInput = {
    set?: $Enums.UploadStatus
  }

  export type UserUpdateOneRequiredWithoutUpload_sessionsNestedInput = {
    create?: XOR<UserCreateWithoutUpload_sessionsInput, UserUncheckedCreateWithoutUpload_sessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpload_sessionsInput
    upsert?: UserUpsertWithoutUpload_sessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpload_sessionsInput, UserUpdateWithoutUpload_sessionsInput>, UserUncheckedUpdateWithoutUpload_sessionsInput>
  }

  export type FacilityTargetCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<FacilityTargetCreateWithoutIndicatorInput, FacilityTargetUncheckedCreateWithoutIndicatorInput> | FacilityTargetCreateWithoutIndicatorInput[] | FacilityTargetUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutIndicatorInput | FacilityTargetCreateOrConnectWithoutIndicatorInput[]
    createMany?: FacilityTargetCreateManyIndicatorInputEnvelope
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
  }

  export type FieldCreateNestedOneWithoutDenominator_for_indicatorsInput = {
    create?: XOR<FieldCreateWithoutDenominator_for_indicatorsInput, FieldUncheckedCreateWithoutDenominator_for_indicatorsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutDenominator_for_indicatorsInput
    connect?: FieldWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutNumerator_for_indicatorsInput = {
    create?: XOR<FieldCreateWithoutNumerator_for_indicatorsInput, FieldUncheckedCreateWithoutNumerator_for_indicatorsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutNumerator_for_indicatorsInput
    connect?: FieldWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutTarget_for_indicatorsInput = {
    create?: XOR<FieldCreateWithoutTarget_for_indicatorsInput, FieldUncheckedCreateWithoutTarget_for_indicatorsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutTarget_for_indicatorsInput
    connect?: FieldWhereUniqueInput
  }

  export type IndicatorRemunerationCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutIndicatorInput, IndicatorRemunerationUncheckedCreateWithoutIndicatorInput> | IndicatorRemunerationCreateWithoutIndicatorInput[] | IndicatorRemunerationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutIndicatorInput | IndicatorRemunerationCreateOrConnectWithoutIndicatorInput[]
    createMany?: IndicatorRemunerationCreateManyIndicatorInputEnvelope
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
  }

  export type IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<IndicatorWorkerAllocationCreateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput> | IndicatorWorkerAllocationCreateWithoutIndicatorInput[] | IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput | IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput[]
    createMany?: IndicatorWorkerAllocationCreateManyIndicatorInputEnvelope
    connect?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
  }

  export type MonthlyHealthDataCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutIndicatorInput, MonthlyHealthDataUncheckedCreateWithoutIndicatorInput> | MonthlyHealthDataCreateWithoutIndicatorInput[] | MonthlyHealthDataUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutIndicatorInput | MonthlyHealthDataCreateOrConnectWithoutIndicatorInput[]
    createMany?: MonthlyHealthDataCreateManyIndicatorInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type PerformanceCalculationCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<PerformanceCalculationCreateWithoutIndicatorInput, PerformanceCalculationUncheckedCreateWithoutIndicatorInput> | PerformanceCalculationCreateWithoutIndicatorInput[] | PerformanceCalculationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutIndicatorInput | PerformanceCalculationCreateOrConnectWithoutIndicatorInput[]
    createMany?: PerformanceCalculationCreateManyIndicatorInputEnvelope
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
  }

  export type FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<FacilityTargetCreateWithoutIndicatorInput, FacilityTargetUncheckedCreateWithoutIndicatorInput> | FacilityTargetCreateWithoutIndicatorInput[] | FacilityTargetUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutIndicatorInput | FacilityTargetCreateOrConnectWithoutIndicatorInput[]
    createMany?: FacilityTargetCreateManyIndicatorInputEnvelope
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
  }

  export type IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutIndicatorInput, IndicatorRemunerationUncheckedCreateWithoutIndicatorInput> | IndicatorRemunerationCreateWithoutIndicatorInput[] | IndicatorRemunerationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutIndicatorInput | IndicatorRemunerationCreateOrConnectWithoutIndicatorInput[]
    createMany?: IndicatorRemunerationCreateManyIndicatorInputEnvelope
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
  }

  export type IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<IndicatorWorkerAllocationCreateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput> | IndicatorWorkerAllocationCreateWithoutIndicatorInput[] | IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput | IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput[]
    createMany?: IndicatorWorkerAllocationCreateManyIndicatorInputEnvelope
    connect?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
  }

  export type MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutIndicatorInput, MonthlyHealthDataUncheckedCreateWithoutIndicatorInput> | MonthlyHealthDataCreateWithoutIndicatorInput[] | MonthlyHealthDataUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutIndicatorInput | MonthlyHealthDataCreateOrConnectWithoutIndicatorInput[]
    createMany?: MonthlyHealthDataCreateManyIndicatorInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<PerformanceCalculationCreateWithoutIndicatorInput, PerformanceCalculationUncheckedCreateWithoutIndicatorInput> | PerformanceCalculationCreateWithoutIndicatorInput[] | PerformanceCalculationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutIndicatorInput | PerformanceCalculationCreateOrConnectWithoutIndicatorInput[]
    createMany?: PerformanceCalculationCreateManyIndicatorInputEnvelope
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
  }

  export type EnumTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.TargetType
  }

  export type FacilityTargetUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<FacilityTargetCreateWithoutIndicatorInput, FacilityTargetUncheckedCreateWithoutIndicatorInput> | FacilityTargetCreateWithoutIndicatorInput[] | FacilityTargetUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutIndicatorInput | FacilityTargetCreateOrConnectWithoutIndicatorInput[]
    upsert?: FacilityTargetUpsertWithWhereUniqueWithoutIndicatorInput | FacilityTargetUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: FacilityTargetCreateManyIndicatorInputEnvelope
    set?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    disconnect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    delete?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    update?: FacilityTargetUpdateWithWhereUniqueWithoutIndicatorInput | FacilityTargetUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: FacilityTargetUpdateManyWithWhereWithoutIndicatorInput | FacilityTargetUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: FacilityTargetScalarWhereInput | FacilityTargetScalarWhereInput[]
  }

  export type FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput = {
    create?: XOR<FieldCreateWithoutDenominator_for_indicatorsInput, FieldUncheckedCreateWithoutDenominator_for_indicatorsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutDenominator_for_indicatorsInput
    upsert?: FieldUpsertWithoutDenominator_for_indicatorsInput
    disconnect?: FieldWhereInput | boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutDenominator_for_indicatorsInput, FieldUpdateWithoutDenominator_for_indicatorsInput>, FieldUncheckedUpdateWithoutDenominator_for_indicatorsInput>
  }

  export type FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput = {
    create?: XOR<FieldCreateWithoutNumerator_for_indicatorsInput, FieldUncheckedCreateWithoutNumerator_for_indicatorsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutNumerator_for_indicatorsInput
    upsert?: FieldUpsertWithoutNumerator_for_indicatorsInput
    disconnect?: FieldWhereInput | boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutNumerator_for_indicatorsInput, FieldUpdateWithoutNumerator_for_indicatorsInput>, FieldUncheckedUpdateWithoutNumerator_for_indicatorsInput>
  }

  export type FieldUpdateOneWithoutTarget_for_indicatorsNestedInput = {
    create?: XOR<FieldCreateWithoutTarget_for_indicatorsInput, FieldUncheckedCreateWithoutTarget_for_indicatorsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutTarget_for_indicatorsInput
    upsert?: FieldUpsertWithoutTarget_for_indicatorsInput
    disconnect?: FieldWhereInput | boolean
    delete?: FieldWhereInput | boolean
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutTarget_for_indicatorsInput, FieldUpdateWithoutTarget_for_indicatorsInput>, FieldUncheckedUpdateWithoutTarget_for_indicatorsInput>
  }

  export type IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutIndicatorInput, IndicatorRemunerationUncheckedCreateWithoutIndicatorInput> | IndicatorRemunerationCreateWithoutIndicatorInput[] | IndicatorRemunerationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutIndicatorInput | IndicatorRemunerationCreateOrConnectWithoutIndicatorInput[]
    upsert?: IndicatorRemunerationUpsertWithWhereUniqueWithoutIndicatorInput | IndicatorRemunerationUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: IndicatorRemunerationCreateManyIndicatorInputEnvelope
    set?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    disconnect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    delete?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    update?: IndicatorRemunerationUpdateWithWhereUniqueWithoutIndicatorInput | IndicatorRemunerationUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: IndicatorRemunerationUpdateManyWithWhereWithoutIndicatorInput | IndicatorRemunerationUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
  }

  export type IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<IndicatorWorkerAllocationCreateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput> | IndicatorWorkerAllocationCreateWithoutIndicatorInput[] | IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput | IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput[]
    upsert?: IndicatorWorkerAllocationUpsertWithWhereUniqueWithoutIndicatorInput | IndicatorWorkerAllocationUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: IndicatorWorkerAllocationCreateManyIndicatorInputEnvelope
    set?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    disconnect?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    delete?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    connect?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    update?: IndicatorWorkerAllocationUpdateWithWhereUniqueWithoutIndicatorInput | IndicatorWorkerAllocationUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: IndicatorWorkerAllocationUpdateManyWithWhereWithoutIndicatorInput | IndicatorWorkerAllocationUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: IndicatorWorkerAllocationScalarWhereInput | IndicatorWorkerAllocationScalarWhereInput[]
  }

  export type MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutIndicatorInput, MonthlyHealthDataUncheckedCreateWithoutIndicatorInput> | MonthlyHealthDataCreateWithoutIndicatorInput[] | MonthlyHealthDataUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutIndicatorInput | MonthlyHealthDataCreateOrConnectWithoutIndicatorInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutIndicatorInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: MonthlyHealthDataCreateManyIndicatorInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutIndicatorInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutIndicatorInput | MonthlyHealthDataUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type PerformanceCalculationUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<PerformanceCalculationCreateWithoutIndicatorInput, PerformanceCalculationUncheckedCreateWithoutIndicatorInput> | PerformanceCalculationCreateWithoutIndicatorInput[] | PerformanceCalculationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutIndicatorInput | PerformanceCalculationCreateOrConnectWithoutIndicatorInput[]
    upsert?: PerformanceCalculationUpsertWithWhereUniqueWithoutIndicatorInput | PerformanceCalculationUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: PerformanceCalculationCreateManyIndicatorInputEnvelope
    set?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    disconnect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    delete?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    update?: PerformanceCalculationUpdateWithWhereUniqueWithoutIndicatorInput | PerformanceCalculationUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: PerformanceCalculationUpdateManyWithWhereWithoutIndicatorInput | PerformanceCalculationUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
  }

  export type FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<FacilityTargetCreateWithoutIndicatorInput, FacilityTargetUncheckedCreateWithoutIndicatorInput> | FacilityTargetCreateWithoutIndicatorInput[] | FacilityTargetUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: FacilityTargetCreateOrConnectWithoutIndicatorInput | FacilityTargetCreateOrConnectWithoutIndicatorInput[]
    upsert?: FacilityTargetUpsertWithWhereUniqueWithoutIndicatorInput | FacilityTargetUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: FacilityTargetCreateManyIndicatorInputEnvelope
    set?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    disconnect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    delete?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    connect?: FacilityTargetWhereUniqueInput | FacilityTargetWhereUniqueInput[]
    update?: FacilityTargetUpdateWithWhereUniqueWithoutIndicatorInput | FacilityTargetUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: FacilityTargetUpdateManyWithWhereWithoutIndicatorInput | FacilityTargetUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: FacilityTargetScalarWhereInput | FacilityTargetScalarWhereInput[]
  }

  export type IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutIndicatorInput, IndicatorRemunerationUncheckedCreateWithoutIndicatorInput> | IndicatorRemunerationCreateWithoutIndicatorInput[] | IndicatorRemunerationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutIndicatorInput | IndicatorRemunerationCreateOrConnectWithoutIndicatorInput[]
    upsert?: IndicatorRemunerationUpsertWithWhereUniqueWithoutIndicatorInput | IndicatorRemunerationUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: IndicatorRemunerationCreateManyIndicatorInputEnvelope
    set?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    disconnect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    delete?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    update?: IndicatorRemunerationUpdateWithWhereUniqueWithoutIndicatorInput | IndicatorRemunerationUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: IndicatorRemunerationUpdateManyWithWhereWithoutIndicatorInput | IndicatorRemunerationUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
  }

  export type IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<IndicatorWorkerAllocationCreateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput> | IndicatorWorkerAllocationCreateWithoutIndicatorInput[] | IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput | IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput[]
    upsert?: IndicatorWorkerAllocationUpsertWithWhereUniqueWithoutIndicatorInput | IndicatorWorkerAllocationUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: IndicatorWorkerAllocationCreateManyIndicatorInputEnvelope
    set?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    disconnect?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    delete?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    connect?: IndicatorWorkerAllocationWhereUniqueInput | IndicatorWorkerAllocationWhereUniqueInput[]
    update?: IndicatorWorkerAllocationUpdateWithWhereUniqueWithoutIndicatorInput | IndicatorWorkerAllocationUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: IndicatorWorkerAllocationUpdateManyWithWhereWithoutIndicatorInput | IndicatorWorkerAllocationUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: IndicatorWorkerAllocationScalarWhereInput | IndicatorWorkerAllocationScalarWhereInput[]
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutIndicatorInput, MonthlyHealthDataUncheckedCreateWithoutIndicatorInput> | MonthlyHealthDataCreateWithoutIndicatorInput[] | MonthlyHealthDataUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutIndicatorInput | MonthlyHealthDataCreateOrConnectWithoutIndicatorInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutIndicatorInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: MonthlyHealthDataCreateManyIndicatorInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutIndicatorInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutIndicatorInput | MonthlyHealthDataUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<PerformanceCalculationCreateWithoutIndicatorInput, PerformanceCalculationUncheckedCreateWithoutIndicatorInput> | PerformanceCalculationCreateWithoutIndicatorInput[] | PerformanceCalculationUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutIndicatorInput | PerformanceCalculationCreateOrConnectWithoutIndicatorInput[]
    upsert?: PerformanceCalculationUpsertWithWhereUniqueWithoutIndicatorInput | PerformanceCalculationUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: PerformanceCalculationCreateManyIndicatorInputEnvelope
    set?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    disconnect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    delete?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    update?: PerformanceCalculationUpdateWithWhereUniqueWithoutIndicatorInput | PerformanceCalculationUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: PerformanceCalculationUpdateManyWithWhereWithoutIndicatorInput | PerformanceCalculationUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
  }

  export type FacilityFieldDefaultsCreateNestedManyWithoutFieldInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFieldInput, FacilityFieldDefaultsUncheckedCreateWithoutFieldInput> | FacilityFieldDefaultsCreateWithoutFieldInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFieldInput | FacilityFieldDefaultsCreateOrConnectWithoutFieldInput[]
    createMany?: FacilityFieldDefaultsCreateManyFieldInputEnvelope
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
  }

  export type FacilityFieldMappingCreateNestedManyWithoutFieldInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFieldInput, FacilityFieldMappingUncheckedCreateWithoutFieldInput> | FacilityFieldMappingCreateWithoutFieldInput[] | FacilityFieldMappingUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFieldInput | FacilityFieldMappingCreateOrConnectWithoutFieldInput[]
    createMany?: FacilityFieldMappingCreateManyFieldInputEnvelope
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
  }

  export type FieldValueCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldValueCreateWithoutFieldInput, FieldValueUncheckedCreateWithoutFieldInput> | FieldValueCreateWithoutFieldInput[] | FieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFieldInput | FieldValueCreateOrConnectWithoutFieldInput[]
    createMany?: FieldValueCreateManyFieldInputEnvelope
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
  }

  export type IndicatorCreateNestedManyWithoutDenominator_fieldInput = {
    create?: XOR<IndicatorCreateWithoutDenominator_fieldInput, IndicatorUncheckedCreateWithoutDenominator_fieldInput> | IndicatorCreateWithoutDenominator_fieldInput[] | IndicatorUncheckedCreateWithoutDenominator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutDenominator_fieldInput | IndicatorCreateOrConnectWithoutDenominator_fieldInput[]
    createMany?: IndicatorCreateManyDenominator_fieldInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorCreateNestedManyWithoutNumerator_fieldInput = {
    create?: XOR<IndicatorCreateWithoutNumerator_fieldInput, IndicatorUncheckedCreateWithoutNumerator_fieldInput> | IndicatorCreateWithoutNumerator_fieldInput[] | IndicatorUncheckedCreateWithoutNumerator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutNumerator_fieldInput | IndicatorCreateOrConnectWithoutNumerator_fieldInput[]
    createMany?: IndicatorCreateManyNumerator_fieldInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorCreateNestedManyWithoutTarget_fieldInput = {
    create?: XOR<IndicatorCreateWithoutTarget_fieldInput, IndicatorUncheckedCreateWithoutTarget_fieldInput> | IndicatorCreateWithoutTarget_fieldInput[] | IndicatorUncheckedCreateWithoutTarget_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutTarget_fieldInput | IndicatorCreateOrConnectWithoutTarget_fieldInput[]
    createMany?: IndicatorCreateManyTarget_fieldInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFieldInput, FacilityFieldDefaultsUncheckedCreateWithoutFieldInput> | FacilityFieldDefaultsCreateWithoutFieldInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFieldInput | FacilityFieldDefaultsCreateOrConnectWithoutFieldInput[]
    createMany?: FacilityFieldDefaultsCreateManyFieldInputEnvelope
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
  }

  export type FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFieldInput, FacilityFieldMappingUncheckedCreateWithoutFieldInput> | FacilityFieldMappingCreateWithoutFieldInput[] | FacilityFieldMappingUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFieldInput | FacilityFieldMappingCreateOrConnectWithoutFieldInput[]
    createMany?: FacilityFieldMappingCreateManyFieldInputEnvelope
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
  }

  export type FieldValueUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FieldValueCreateWithoutFieldInput, FieldValueUncheckedCreateWithoutFieldInput> | FieldValueCreateWithoutFieldInput[] | FieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFieldInput | FieldValueCreateOrConnectWithoutFieldInput[]
    createMany?: FieldValueCreateManyFieldInputEnvelope
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
  }

  export type IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput = {
    create?: XOR<IndicatorCreateWithoutDenominator_fieldInput, IndicatorUncheckedCreateWithoutDenominator_fieldInput> | IndicatorCreateWithoutDenominator_fieldInput[] | IndicatorUncheckedCreateWithoutDenominator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutDenominator_fieldInput | IndicatorCreateOrConnectWithoutDenominator_fieldInput[]
    createMany?: IndicatorCreateManyDenominator_fieldInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput = {
    create?: XOR<IndicatorCreateWithoutNumerator_fieldInput, IndicatorUncheckedCreateWithoutNumerator_fieldInput> | IndicatorCreateWithoutNumerator_fieldInput[] | IndicatorUncheckedCreateWithoutNumerator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutNumerator_fieldInput | IndicatorCreateOrConnectWithoutNumerator_fieldInput[]
    createMany?: IndicatorCreateManyNumerator_fieldInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput = {
    create?: XOR<IndicatorCreateWithoutTarget_fieldInput, IndicatorUncheckedCreateWithoutTarget_fieldInput> | IndicatorCreateWithoutTarget_fieldInput[] | IndicatorUncheckedCreateWithoutTarget_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutTarget_fieldInput | IndicatorCreateOrConnectWithoutTarget_fieldInput[]
    createMany?: IndicatorCreateManyTarget_fieldInputEnvelope
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
  }

  export type EnumFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.FieldType
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type EnumFieldCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FieldCategory
  }

  export type FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFieldInput, FacilityFieldDefaultsUncheckedCreateWithoutFieldInput> | FacilityFieldDefaultsCreateWithoutFieldInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFieldInput | FacilityFieldDefaultsCreateOrConnectWithoutFieldInput[]
    upsert?: FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFieldInput | FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FacilityFieldDefaultsCreateManyFieldInputEnvelope
    set?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    disconnect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    delete?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    update?: FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFieldInput | FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FacilityFieldDefaultsUpdateManyWithWhereWithoutFieldInput | FacilityFieldDefaultsUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FacilityFieldDefaultsScalarWhereInput | FacilityFieldDefaultsScalarWhereInput[]
  }

  export type FacilityFieldMappingUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFieldInput, FacilityFieldMappingUncheckedCreateWithoutFieldInput> | FacilityFieldMappingCreateWithoutFieldInput[] | FacilityFieldMappingUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFieldInput | FacilityFieldMappingCreateOrConnectWithoutFieldInput[]
    upsert?: FacilityFieldMappingUpsertWithWhereUniqueWithoutFieldInput | FacilityFieldMappingUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FacilityFieldMappingCreateManyFieldInputEnvelope
    set?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    disconnect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    delete?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    update?: FacilityFieldMappingUpdateWithWhereUniqueWithoutFieldInput | FacilityFieldMappingUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FacilityFieldMappingUpdateManyWithWhereWithoutFieldInput | FacilityFieldMappingUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FacilityFieldMappingScalarWhereInput | FacilityFieldMappingScalarWhereInput[]
  }

  export type FieldValueUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldValueCreateWithoutFieldInput, FieldValueUncheckedCreateWithoutFieldInput> | FieldValueCreateWithoutFieldInput[] | FieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFieldInput | FieldValueCreateOrConnectWithoutFieldInput[]
    upsert?: FieldValueUpsertWithWhereUniqueWithoutFieldInput | FieldValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldValueCreateManyFieldInputEnvelope
    set?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    disconnect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    delete?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    update?: FieldValueUpdateWithWhereUniqueWithoutFieldInput | FieldValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldValueUpdateManyWithWhereWithoutFieldInput | FieldValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
  }

  export type IndicatorUpdateManyWithoutDenominator_fieldNestedInput = {
    create?: XOR<IndicatorCreateWithoutDenominator_fieldInput, IndicatorUncheckedCreateWithoutDenominator_fieldInput> | IndicatorCreateWithoutDenominator_fieldInput[] | IndicatorUncheckedCreateWithoutDenominator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutDenominator_fieldInput | IndicatorCreateOrConnectWithoutDenominator_fieldInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutDenominator_fieldInput | IndicatorUpsertWithWhereUniqueWithoutDenominator_fieldInput[]
    createMany?: IndicatorCreateManyDenominator_fieldInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutDenominator_fieldInput | IndicatorUpdateWithWhereUniqueWithoutDenominator_fieldInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutDenominator_fieldInput | IndicatorUpdateManyWithWhereWithoutDenominator_fieldInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorUpdateManyWithoutNumerator_fieldNestedInput = {
    create?: XOR<IndicatorCreateWithoutNumerator_fieldInput, IndicatorUncheckedCreateWithoutNumerator_fieldInput> | IndicatorCreateWithoutNumerator_fieldInput[] | IndicatorUncheckedCreateWithoutNumerator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutNumerator_fieldInput | IndicatorCreateOrConnectWithoutNumerator_fieldInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutNumerator_fieldInput | IndicatorUpsertWithWhereUniqueWithoutNumerator_fieldInput[]
    createMany?: IndicatorCreateManyNumerator_fieldInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutNumerator_fieldInput | IndicatorUpdateWithWhereUniqueWithoutNumerator_fieldInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutNumerator_fieldInput | IndicatorUpdateManyWithWhereWithoutNumerator_fieldInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorUpdateManyWithoutTarget_fieldNestedInput = {
    create?: XOR<IndicatorCreateWithoutTarget_fieldInput, IndicatorUncheckedCreateWithoutTarget_fieldInput> | IndicatorCreateWithoutTarget_fieldInput[] | IndicatorUncheckedCreateWithoutTarget_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutTarget_fieldInput | IndicatorCreateOrConnectWithoutTarget_fieldInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutTarget_fieldInput | IndicatorUpsertWithWhereUniqueWithoutTarget_fieldInput[]
    createMany?: IndicatorCreateManyTarget_fieldInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutTarget_fieldInput | IndicatorUpdateWithWhereUniqueWithoutTarget_fieldInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutTarget_fieldInput | IndicatorUpdateManyWithWhereWithoutTarget_fieldInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FacilityFieldDefaultsCreateWithoutFieldInput, FacilityFieldDefaultsUncheckedCreateWithoutFieldInput> | FacilityFieldDefaultsCreateWithoutFieldInput[] | FacilityFieldDefaultsUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldDefaultsCreateOrConnectWithoutFieldInput | FacilityFieldDefaultsCreateOrConnectWithoutFieldInput[]
    upsert?: FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFieldInput | FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FacilityFieldDefaultsCreateManyFieldInputEnvelope
    set?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    disconnect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    delete?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    connect?: FacilityFieldDefaultsWhereUniqueInput | FacilityFieldDefaultsWhereUniqueInput[]
    update?: FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFieldInput | FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FacilityFieldDefaultsUpdateManyWithWhereWithoutFieldInput | FacilityFieldDefaultsUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FacilityFieldDefaultsScalarWhereInput | FacilityFieldDefaultsScalarWhereInput[]
  }

  export type FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FacilityFieldMappingCreateWithoutFieldInput, FacilityFieldMappingUncheckedCreateWithoutFieldInput> | FacilityFieldMappingCreateWithoutFieldInput[] | FacilityFieldMappingUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FacilityFieldMappingCreateOrConnectWithoutFieldInput | FacilityFieldMappingCreateOrConnectWithoutFieldInput[]
    upsert?: FacilityFieldMappingUpsertWithWhereUniqueWithoutFieldInput | FacilityFieldMappingUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FacilityFieldMappingCreateManyFieldInputEnvelope
    set?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    disconnect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    delete?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    connect?: FacilityFieldMappingWhereUniqueInput | FacilityFieldMappingWhereUniqueInput[]
    update?: FacilityFieldMappingUpdateWithWhereUniqueWithoutFieldInput | FacilityFieldMappingUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FacilityFieldMappingUpdateManyWithWhereWithoutFieldInput | FacilityFieldMappingUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FacilityFieldMappingScalarWhereInput | FacilityFieldMappingScalarWhereInput[]
  }

  export type FieldValueUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FieldValueCreateWithoutFieldInput, FieldValueUncheckedCreateWithoutFieldInput> | FieldValueCreateWithoutFieldInput[] | FieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FieldValueCreateOrConnectWithoutFieldInput | FieldValueCreateOrConnectWithoutFieldInput[]
    upsert?: FieldValueUpsertWithWhereUniqueWithoutFieldInput | FieldValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FieldValueCreateManyFieldInputEnvelope
    set?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    disconnect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    delete?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    connect?: FieldValueWhereUniqueInput | FieldValueWhereUniqueInput[]
    update?: FieldValueUpdateWithWhereUniqueWithoutFieldInput | FieldValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FieldValueUpdateManyWithWhereWithoutFieldInput | FieldValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
  }

  export type IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput = {
    create?: XOR<IndicatorCreateWithoutDenominator_fieldInput, IndicatorUncheckedCreateWithoutDenominator_fieldInput> | IndicatorCreateWithoutDenominator_fieldInput[] | IndicatorUncheckedCreateWithoutDenominator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutDenominator_fieldInput | IndicatorCreateOrConnectWithoutDenominator_fieldInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutDenominator_fieldInput | IndicatorUpsertWithWhereUniqueWithoutDenominator_fieldInput[]
    createMany?: IndicatorCreateManyDenominator_fieldInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutDenominator_fieldInput | IndicatorUpdateWithWhereUniqueWithoutDenominator_fieldInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutDenominator_fieldInput | IndicatorUpdateManyWithWhereWithoutDenominator_fieldInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput = {
    create?: XOR<IndicatorCreateWithoutNumerator_fieldInput, IndicatorUncheckedCreateWithoutNumerator_fieldInput> | IndicatorCreateWithoutNumerator_fieldInput[] | IndicatorUncheckedCreateWithoutNumerator_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutNumerator_fieldInput | IndicatorCreateOrConnectWithoutNumerator_fieldInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutNumerator_fieldInput | IndicatorUpsertWithWhereUniqueWithoutNumerator_fieldInput[]
    createMany?: IndicatorCreateManyNumerator_fieldInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutNumerator_fieldInput | IndicatorUpdateWithWhereUniqueWithoutNumerator_fieldInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutNumerator_fieldInput | IndicatorUpdateManyWithWhereWithoutNumerator_fieldInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput = {
    create?: XOR<IndicatorCreateWithoutTarget_fieldInput, IndicatorUncheckedCreateWithoutTarget_fieldInput> | IndicatorCreateWithoutTarget_fieldInput[] | IndicatorUncheckedCreateWithoutTarget_fieldInput[]
    connectOrCreate?: IndicatorCreateOrConnectWithoutTarget_fieldInput | IndicatorCreateOrConnectWithoutTarget_fieldInput[]
    upsert?: IndicatorUpsertWithWhereUniqueWithoutTarget_fieldInput | IndicatorUpsertWithWhereUniqueWithoutTarget_fieldInput[]
    createMany?: IndicatorCreateManyTarget_fieldInputEnvelope
    set?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    disconnect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    delete?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    connect?: IndicatorWhereUniqueInput | IndicatorWhereUniqueInput[]
    update?: IndicatorUpdateWithWhereUniqueWithoutTarget_fieldInput | IndicatorUpdateWithWhereUniqueWithoutTarget_fieldInput[]
    updateMany?: IndicatorUpdateManyWithWhereWithoutTarget_fieldInput | IndicatorUpdateManyWithWhereWithoutTarget_fieldInput[]
    deleteMany?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
  }

  export type FacilityCreateNestedOneWithoutField_valuesInput = {
    create?: XOR<FacilityCreateWithoutField_valuesInput, FacilityUncheckedCreateWithoutField_valuesInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutField_valuesInput
    connect?: FacilityWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutField_valuesInput = {
    create?: XOR<FieldCreateWithoutField_valuesInput, FieldUncheckedCreateWithoutField_valuesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutField_valuesInput
    connect?: FieldWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutField_valuesInput = {
    create?: XOR<UserCreateWithoutField_valuesInput, UserUncheckedCreateWithoutField_valuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutField_valuesInput
    connect?: UserWhereUniqueInput
  }

  export type FacilityUpdateOneWithoutField_valuesNestedInput = {
    create?: XOR<FacilityCreateWithoutField_valuesInput, FacilityUncheckedCreateWithoutField_valuesInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutField_valuesInput
    upsert?: FacilityUpsertWithoutField_valuesInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutField_valuesInput, FacilityUpdateWithoutField_valuesInput>, FacilityUncheckedUpdateWithoutField_valuesInput>
  }

  export type FieldUpdateOneRequiredWithoutField_valuesNestedInput = {
    create?: XOR<FieldCreateWithoutField_valuesInput, FieldUncheckedCreateWithoutField_valuesInput>
    connectOrCreate?: FieldCreateOrConnectWithoutField_valuesInput
    upsert?: FieldUpsertWithoutField_valuesInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutField_valuesInput, FieldUpdateWithoutField_valuesInput>, FieldUncheckedUpdateWithoutField_valuesInput>
  }

  export type UserUpdateOneRequiredWithoutField_valuesNestedInput = {
    create?: XOR<UserCreateWithoutField_valuesInput, UserUncheckedCreateWithoutField_valuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutField_valuesInput
    upsert?: UserUpsertWithoutField_valuesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutField_valuesInput, UserUpdateWithoutField_valuesInput>, UserUncheckedUpdateWithoutField_valuesInput>
  }

  export type FacilityCreateNestedOneWithoutFacility_field_defaultsInput = {
    create?: XOR<FacilityCreateWithoutFacility_field_defaultsInput, FacilityUncheckedCreateWithoutFacility_field_defaultsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_field_defaultsInput
    connect?: FacilityWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutFacility_field_defaultsInput = {
    create?: XOR<FieldCreateWithoutFacility_field_defaultsInput, FieldUncheckedCreateWithoutFacility_field_defaultsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFacility_field_defaultsInput
    connect?: FieldWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutFacility_field_defaultsNestedInput = {
    create?: XOR<FacilityCreateWithoutFacility_field_defaultsInput, FacilityUncheckedCreateWithoutFacility_field_defaultsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_field_defaultsInput
    upsert?: FacilityUpsertWithoutFacility_field_defaultsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutFacility_field_defaultsInput, FacilityUpdateWithoutFacility_field_defaultsInput>, FacilityUncheckedUpdateWithoutFacility_field_defaultsInput>
  }

  export type FieldUpdateOneRequiredWithoutFacility_field_defaultsNestedInput = {
    create?: XOR<FieldCreateWithoutFacility_field_defaultsInput, FieldUncheckedCreateWithoutFacility_field_defaultsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFacility_field_defaultsInput
    upsert?: FieldUpsertWithoutFacility_field_defaultsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFacility_field_defaultsInput, FieldUpdateWithoutFacility_field_defaultsInput>, FieldUncheckedUpdateWithoutFacility_field_defaultsInput>
  }

  export type FacilityTypeCreateNestedOneWithoutField_mappingsInput = {
    create?: XOR<FacilityTypeCreateWithoutField_mappingsInput, FacilityTypeUncheckedCreateWithoutField_mappingsInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutField_mappingsInput
    connect?: FacilityTypeWhereUniqueInput
  }

  export type FieldCreateNestedOneWithoutFacility_field_mappingsInput = {
    create?: XOR<FieldCreateWithoutFacility_field_mappingsInput, FieldUncheckedCreateWithoutFacility_field_mappingsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFacility_field_mappingsInput
    connect?: FieldWhereUniqueInput
  }

  export type FacilityTypeUpdateOneRequiredWithoutField_mappingsNestedInput = {
    create?: XOR<FacilityTypeCreateWithoutField_mappingsInput, FacilityTypeUncheckedCreateWithoutField_mappingsInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutField_mappingsInput
    upsert?: FacilityTypeUpsertWithoutField_mappingsInput
    connect?: FacilityTypeWhereUniqueInput
    update?: XOR<XOR<FacilityTypeUpdateToOneWithWhereWithoutField_mappingsInput, FacilityTypeUpdateWithoutField_mappingsInput>, FacilityTypeUncheckedUpdateWithoutField_mappingsInput>
  }

  export type FieldUpdateOneRequiredWithoutFacility_field_mappingsNestedInput = {
    create?: XOR<FieldCreateWithoutFacility_field_mappingsInput, FieldUncheckedCreateWithoutFacility_field_mappingsInput>
    connectOrCreate?: FieldCreateOrConnectWithoutFacility_field_mappingsInput
    upsert?: FieldUpsertWithoutFacility_field_mappingsInput
    connect?: FieldWhereUniqueInput
    update?: XOR<XOR<FieldUpdateToOneWithWhereWithoutFacility_field_mappingsInput, FieldUpdateWithoutFacility_field_mappingsInput>, FieldUncheckedUpdateWithoutFacility_field_mappingsInput>
  }

  export type MonthlyHealthDataCreateNestedManyWithoutSub_centreInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutSub_centreInput, MonthlyHealthDataUncheckedCreateWithoutSub_centreInput> | MonthlyHealthDataCreateWithoutSub_centreInput[] | MonthlyHealthDataUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutSub_centreInput | MonthlyHealthDataCreateOrConnectWithoutSub_centreInput[]
    createMany?: MonthlyHealthDataCreateManySub_centreInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type PerformanceCalculationCreateNestedManyWithoutSub_centreInput = {
    create?: XOR<PerformanceCalculationCreateWithoutSub_centreInput, PerformanceCalculationUncheckedCreateWithoutSub_centreInput> | PerformanceCalculationCreateWithoutSub_centreInput[] | PerformanceCalculationUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutSub_centreInput | PerformanceCalculationCreateOrConnectWithoutSub_centreInput[]
    createMany?: PerformanceCalculationCreateManySub_centreInputEnvelope
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
  }

  export type FacilityCreateNestedOneWithoutSub_centresInput = {
    create?: XOR<FacilityCreateWithoutSub_centresInput, FacilityUncheckedCreateWithoutSub_centresInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutSub_centresInput
    connect?: FacilityWhereUniqueInput
  }

  export type MonthlyHealthDataUncheckedCreateNestedManyWithoutSub_centreInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutSub_centreInput, MonthlyHealthDataUncheckedCreateWithoutSub_centreInput> | MonthlyHealthDataCreateWithoutSub_centreInput[] | MonthlyHealthDataUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutSub_centreInput | MonthlyHealthDataCreateOrConnectWithoutSub_centreInput[]
    createMany?: MonthlyHealthDataCreateManySub_centreInputEnvelope
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
  }

  export type PerformanceCalculationUncheckedCreateNestedManyWithoutSub_centreInput = {
    create?: XOR<PerformanceCalculationCreateWithoutSub_centreInput, PerformanceCalculationUncheckedCreateWithoutSub_centreInput> | PerformanceCalculationCreateWithoutSub_centreInput[] | PerformanceCalculationUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutSub_centreInput | PerformanceCalculationCreateOrConnectWithoutSub_centreInput[]
    createMany?: PerformanceCalculationCreateManySub_centreInputEnvelope
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
  }

  export type MonthlyHealthDataUpdateManyWithoutSub_centreNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutSub_centreInput, MonthlyHealthDataUncheckedCreateWithoutSub_centreInput> | MonthlyHealthDataCreateWithoutSub_centreInput[] | MonthlyHealthDataUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutSub_centreInput | MonthlyHealthDataCreateOrConnectWithoutSub_centreInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutSub_centreInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutSub_centreInput[]
    createMany?: MonthlyHealthDataCreateManySub_centreInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutSub_centreInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutSub_centreInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutSub_centreInput | MonthlyHealthDataUpdateManyWithWhereWithoutSub_centreInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type PerformanceCalculationUpdateManyWithoutSub_centreNestedInput = {
    create?: XOR<PerformanceCalculationCreateWithoutSub_centreInput, PerformanceCalculationUncheckedCreateWithoutSub_centreInput> | PerformanceCalculationCreateWithoutSub_centreInput[] | PerformanceCalculationUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutSub_centreInput | PerformanceCalculationCreateOrConnectWithoutSub_centreInput[]
    upsert?: PerformanceCalculationUpsertWithWhereUniqueWithoutSub_centreInput | PerformanceCalculationUpsertWithWhereUniqueWithoutSub_centreInput[]
    createMany?: PerformanceCalculationCreateManySub_centreInputEnvelope
    set?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    disconnect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    delete?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    update?: PerformanceCalculationUpdateWithWhereUniqueWithoutSub_centreInput | PerformanceCalculationUpdateWithWhereUniqueWithoutSub_centreInput[]
    updateMany?: PerformanceCalculationUpdateManyWithWhereWithoutSub_centreInput | PerformanceCalculationUpdateManyWithWhereWithoutSub_centreInput[]
    deleteMany?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
  }

  export type FacilityUpdateOneRequiredWithoutSub_centresNestedInput = {
    create?: XOR<FacilityCreateWithoutSub_centresInput, FacilityUncheckedCreateWithoutSub_centresInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutSub_centresInput
    upsert?: FacilityUpsertWithoutSub_centresInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutSub_centresInput, FacilityUpdateWithoutSub_centresInput>, FacilityUncheckedUpdateWithoutSub_centresInput>
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutSub_centreNestedInput = {
    create?: XOR<MonthlyHealthDataCreateWithoutSub_centreInput, MonthlyHealthDataUncheckedCreateWithoutSub_centreInput> | MonthlyHealthDataCreateWithoutSub_centreInput[] | MonthlyHealthDataUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: MonthlyHealthDataCreateOrConnectWithoutSub_centreInput | MonthlyHealthDataCreateOrConnectWithoutSub_centreInput[]
    upsert?: MonthlyHealthDataUpsertWithWhereUniqueWithoutSub_centreInput | MonthlyHealthDataUpsertWithWhereUniqueWithoutSub_centreInput[]
    createMany?: MonthlyHealthDataCreateManySub_centreInputEnvelope
    set?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    disconnect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    delete?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    connect?: MonthlyHealthDataWhereUniqueInput | MonthlyHealthDataWhereUniqueInput[]
    update?: MonthlyHealthDataUpdateWithWhereUniqueWithoutSub_centreInput | MonthlyHealthDataUpdateWithWhereUniqueWithoutSub_centreInput[]
    updateMany?: MonthlyHealthDataUpdateManyWithWhereWithoutSub_centreInput | MonthlyHealthDataUpdateManyWithWhereWithoutSub_centreInput[]
    deleteMany?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
  }

  export type PerformanceCalculationUncheckedUpdateManyWithoutSub_centreNestedInput = {
    create?: XOR<PerformanceCalculationCreateWithoutSub_centreInput, PerformanceCalculationUncheckedCreateWithoutSub_centreInput> | PerformanceCalculationCreateWithoutSub_centreInput[] | PerformanceCalculationUncheckedCreateWithoutSub_centreInput[]
    connectOrCreate?: PerformanceCalculationCreateOrConnectWithoutSub_centreInput | PerformanceCalculationCreateOrConnectWithoutSub_centreInput[]
    upsert?: PerformanceCalculationUpsertWithWhereUniqueWithoutSub_centreInput | PerformanceCalculationUpsertWithWhereUniqueWithoutSub_centreInput[]
    createMany?: PerformanceCalculationCreateManySub_centreInputEnvelope
    set?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    disconnect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    delete?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    connect?: PerformanceCalculationWhereUniqueInput | PerformanceCalculationWhereUniqueInput[]
    update?: PerformanceCalculationUpdateWithWhereUniqueWithoutSub_centreInput | PerformanceCalculationUpdateWithWhereUniqueWithoutSub_centreInput[]
    updateMany?: PerformanceCalculationUpdateManyWithWhereWithoutSub_centreInput | PerformanceCalculationUpdateManyWithWhereWithoutSub_centreInput[]
    deleteMany?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
  }

  export type FacilityCreateNestedOneWithoutHealth_workersInput = {
    create?: XOR<FacilityCreateWithoutHealth_workersInput, FacilityUncheckedCreateWithoutHealth_workersInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutHealth_workersInput
    connect?: FacilityWhereUniqueInput
  }

  export type WorkerRemunerationCreateNestedManyWithoutHealth_workerInput = {
    create?: XOR<WorkerRemunerationCreateWithoutHealth_workerInput, WorkerRemunerationUncheckedCreateWithoutHealth_workerInput> | WorkerRemunerationCreateWithoutHealth_workerInput[] | WorkerRemunerationUncheckedCreateWithoutHealth_workerInput[]
    connectOrCreate?: WorkerRemunerationCreateOrConnectWithoutHealth_workerInput | WorkerRemunerationCreateOrConnectWithoutHealth_workerInput[]
    createMany?: WorkerRemunerationCreateManyHealth_workerInputEnvelope
    connect?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
  }

  export type WorkerRemunerationUncheckedCreateNestedManyWithoutHealth_workerInput = {
    create?: XOR<WorkerRemunerationCreateWithoutHealth_workerInput, WorkerRemunerationUncheckedCreateWithoutHealth_workerInput> | WorkerRemunerationCreateWithoutHealth_workerInput[] | WorkerRemunerationUncheckedCreateWithoutHealth_workerInput[]
    connectOrCreate?: WorkerRemunerationCreateOrConnectWithoutHealth_workerInput | WorkerRemunerationCreateOrConnectWithoutHealth_workerInput[]
    createMany?: WorkerRemunerationCreateManyHealth_workerInputEnvelope
    connect?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FacilityUpdateOneRequiredWithoutHealth_workersNestedInput = {
    create?: XOR<FacilityCreateWithoutHealth_workersInput, FacilityUncheckedCreateWithoutHealth_workersInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutHealth_workersInput
    upsert?: FacilityUpsertWithoutHealth_workersInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutHealth_workersInput, FacilityUpdateWithoutHealth_workersInput>, FacilityUncheckedUpdateWithoutHealth_workersInput>
  }

  export type WorkerRemunerationUpdateManyWithoutHealth_workerNestedInput = {
    create?: XOR<WorkerRemunerationCreateWithoutHealth_workerInput, WorkerRemunerationUncheckedCreateWithoutHealth_workerInput> | WorkerRemunerationCreateWithoutHealth_workerInput[] | WorkerRemunerationUncheckedCreateWithoutHealth_workerInput[]
    connectOrCreate?: WorkerRemunerationCreateOrConnectWithoutHealth_workerInput | WorkerRemunerationCreateOrConnectWithoutHealth_workerInput[]
    upsert?: WorkerRemunerationUpsertWithWhereUniqueWithoutHealth_workerInput | WorkerRemunerationUpsertWithWhereUniqueWithoutHealth_workerInput[]
    createMany?: WorkerRemunerationCreateManyHealth_workerInputEnvelope
    set?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    disconnect?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    delete?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    connect?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    update?: WorkerRemunerationUpdateWithWhereUniqueWithoutHealth_workerInput | WorkerRemunerationUpdateWithWhereUniqueWithoutHealth_workerInput[]
    updateMany?: WorkerRemunerationUpdateManyWithWhereWithoutHealth_workerInput | WorkerRemunerationUpdateManyWithWhereWithoutHealth_workerInput[]
    deleteMany?: WorkerRemunerationScalarWhereInput | WorkerRemunerationScalarWhereInput[]
  }

  export type WorkerRemunerationUncheckedUpdateManyWithoutHealth_workerNestedInput = {
    create?: XOR<WorkerRemunerationCreateWithoutHealth_workerInput, WorkerRemunerationUncheckedCreateWithoutHealth_workerInput> | WorkerRemunerationCreateWithoutHealth_workerInput[] | WorkerRemunerationUncheckedCreateWithoutHealth_workerInput[]
    connectOrCreate?: WorkerRemunerationCreateOrConnectWithoutHealth_workerInput | WorkerRemunerationCreateOrConnectWithoutHealth_workerInput[]
    upsert?: WorkerRemunerationUpsertWithWhereUniqueWithoutHealth_workerInput | WorkerRemunerationUpsertWithWhereUniqueWithoutHealth_workerInput[]
    createMany?: WorkerRemunerationCreateManyHealth_workerInputEnvelope
    set?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    disconnect?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    delete?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    connect?: WorkerRemunerationWhereUniqueInput | WorkerRemunerationWhereUniqueInput[]
    update?: WorkerRemunerationUpdateWithWhereUniqueWithoutHealth_workerInput | WorkerRemunerationUpdateWithWhereUniqueWithoutHealth_workerInput[]
    updateMany?: WorkerRemunerationUpdateManyWithWhereWithoutHealth_workerInput | WorkerRemunerationUpdateManyWithWhereWithoutHealth_workerInput[]
    deleteMany?: WorkerRemunerationScalarWhereInput | WorkerRemunerationScalarWhereInput[]
  }

  export type FacilityCreateNestedOneWithoutRemuneration_calculationsInput = {
    create?: XOR<FacilityCreateWithoutRemuneration_calculationsInput, FacilityUncheckedCreateWithoutRemuneration_calculationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutRemuneration_calculationsInput
    connect?: FacilityWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutRemuneration_calculationsNestedInput = {
    create?: XOR<FacilityCreateWithoutRemuneration_calculationsInput, FacilityUncheckedCreateWithoutRemuneration_calculationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutRemuneration_calculationsInput
    upsert?: FacilityUpsertWithoutRemuneration_calculationsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutRemuneration_calculationsInput, FacilityUpdateWithoutRemuneration_calculationsInput>, FacilityUncheckedUpdateWithoutRemuneration_calculationsInput>
  }

  export type HealthWorkerCreateNestedOneWithoutRemuneration_calculationsInput = {
    create?: XOR<HealthWorkerCreateWithoutRemuneration_calculationsInput, HealthWorkerUncheckedCreateWithoutRemuneration_calculationsInput>
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutRemuneration_calculationsInput
    connect?: HealthWorkerWhereUniqueInput
  }

  export type HealthWorkerUpdateOneRequiredWithoutRemuneration_calculationsNestedInput = {
    create?: XOR<HealthWorkerCreateWithoutRemuneration_calculationsInput, HealthWorkerUncheckedCreateWithoutRemuneration_calculationsInput>
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutRemuneration_calculationsInput
    upsert?: HealthWorkerUpsertWithoutRemuneration_calculationsInput
    connect?: HealthWorkerWhereUniqueInput
    update?: XOR<XOR<HealthWorkerUpdateToOneWithWhereWithoutRemuneration_calculationsInput, HealthWorkerUpdateWithoutRemuneration_calculationsInput>, HealthWorkerUncheckedUpdateWithoutRemuneration_calculationsInput>
  }

  export type FacilityWorkerAllocationCreateNestedManyWithoutWorker_allocation_configInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput> | FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput[] | FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput | FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput[]
    createMany?: FacilityWorkerAllocationCreateManyWorker_allocation_configInputEnvelope
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
  }

  export type FacilityTypeCreateNestedOneWithoutWorker_allocationsInput = {
    create?: XOR<FacilityTypeCreateWithoutWorker_allocationsInput, FacilityTypeUncheckedCreateWithoutWorker_allocationsInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutWorker_allocationsInput
    connect?: FacilityTypeWhereUniqueInput
  }

  export type FacilityWorkerAllocationUncheckedCreateNestedManyWithoutWorker_allocation_configInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput> | FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput[] | FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput | FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput[]
    createMany?: FacilityWorkerAllocationCreateManyWorker_allocation_configInputEnvelope
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
  }

  export type FacilityWorkerAllocationUpdateManyWithoutWorker_allocation_configNestedInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput> | FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput[] | FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput | FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput[]
    upsert?: FacilityWorkerAllocationUpsertWithWhereUniqueWithoutWorker_allocation_configInput | FacilityWorkerAllocationUpsertWithWhereUniqueWithoutWorker_allocation_configInput[]
    createMany?: FacilityWorkerAllocationCreateManyWorker_allocation_configInputEnvelope
    set?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    disconnect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    delete?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    update?: FacilityWorkerAllocationUpdateWithWhereUniqueWithoutWorker_allocation_configInput | FacilityWorkerAllocationUpdateWithWhereUniqueWithoutWorker_allocation_configInput[]
    updateMany?: FacilityWorkerAllocationUpdateManyWithWhereWithoutWorker_allocation_configInput | FacilityWorkerAllocationUpdateManyWithWhereWithoutWorker_allocation_configInput[]
    deleteMany?: FacilityWorkerAllocationScalarWhereInput | FacilityWorkerAllocationScalarWhereInput[]
  }

  export type FacilityTypeUpdateOneRequiredWithoutWorker_allocationsNestedInput = {
    create?: XOR<FacilityTypeCreateWithoutWorker_allocationsInput, FacilityTypeUncheckedCreateWithoutWorker_allocationsInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutWorker_allocationsInput
    upsert?: FacilityTypeUpsertWithoutWorker_allocationsInput
    connect?: FacilityTypeWhereUniqueInput
    update?: XOR<XOR<FacilityTypeUpdateToOneWithWhereWithoutWorker_allocationsInput, FacilityTypeUpdateWithoutWorker_allocationsInput>, FacilityTypeUncheckedUpdateWithoutWorker_allocationsInput>
  }

  export type FacilityWorkerAllocationUncheckedUpdateManyWithoutWorker_allocation_configNestedInput = {
    create?: XOR<FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput> | FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput[] | FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput[]
    connectOrCreate?: FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput | FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput[]
    upsert?: FacilityWorkerAllocationUpsertWithWhereUniqueWithoutWorker_allocation_configInput | FacilityWorkerAllocationUpsertWithWhereUniqueWithoutWorker_allocation_configInput[]
    createMany?: FacilityWorkerAllocationCreateManyWorker_allocation_configInputEnvelope
    set?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    disconnect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    delete?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    connect?: FacilityWorkerAllocationWhereUniqueInput | FacilityWorkerAllocationWhereUniqueInput[]
    update?: FacilityWorkerAllocationUpdateWithWhereUniqueWithoutWorker_allocation_configInput | FacilityWorkerAllocationUpdateWithWhereUniqueWithoutWorker_allocation_configInput[]
    updateMany?: FacilityWorkerAllocationUpdateManyWithWhereWithoutWorker_allocation_configInput | FacilityWorkerAllocationUpdateManyWithWhereWithoutWorker_allocation_configInput[]
    deleteMany?: FacilityWorkerAllocationScalarWhereInput | FacilityWorkerAllocationScalarWhereInput[]
  }

  export type FacilityCreateNestedOneWithoutWorker_allocationsInput = {
    create?: XOR<FacilityCreateWithoutWorker_allocationsInput, FacilityUncheckedCreateWithoutWorker_allocationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutWorker_allocationsInput
    connect?: FacilityWhereUniqueInput
  }

  export type WorkerAllocationConfigCreateNestedOneWithoutFacility_allocationsInput = {
    create?: XOR<WorkerAllocationConfigCreateWithoutFacility_allocationsInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_allocationsInput>
    connectOrCreate?: WorkerAllocationConfigCreateOrConnectWithoutFacility_allocationsInput
    connect?: WorkerAllocationConfigWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutWorker_allocationsNestedInput = {
    create?: XOR<FacilityCreateWithoutWorker_allocationsInput, FacilityUncheckedCreateWithoutWorker_allocationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutWorker_allocationsInput
    upsert?: FacilityUpsertWithoutWorker_allocationsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutWorker_allocationsInput, FacilityUpdateWithoutWorker_allocationsInput>, FacilityUncheckedUpdateWithoutWorker_allocationsInput>
  }

  export type WorkerAllocationConfigUpdateOneRequiredWithoutFacility_allocationsNestedInput = {
    create?: XOR<WorkerAllocationConfigCreateWithoutFacility_allocationsInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_allocationsInput>
    connectOrCreate?: WorkerAllocationConfigCreateOrConnectWithoutFacility_allocationsInput
    upsert?: WorkerAllocationConfigUpsertWithoutFacility_allocationsInput
    connect?: WorkerAllocationConfigWhereUniqueInput
    update?: XOR<XOR<WorkerAllocationConfigUpdateToOneWithWhereWithoutFacility_allocationsInput, WorkerAllocationConfigUpdateWithoutFacility_allocationsInput>, WorkerAllocationConfigUncheckedUpdateWithoutFacility_allocationsInput>
  }

  export type FacilityTypeCreateNestedOneWithoutRemunerationsInput = {
    create?: XOR<FacilityTypeCreateWithoutRemunerationsInput, FacilityTypeUncheckedCreateWithoutRemunerationsInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutRemunerationsInput
    connect?: FacilityTypeWhereUniqueInput
  }

  export type IndicatorRemunerationCreateNestedManyWithoutFacility_type_remunerationInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput> | IndicatorRemunerationCreateWithoutFacility_type_remunerationInput[] | IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput | IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput[]
    createMany?: IndicatorRemunerationCreateManyFacility_type_remunerationInputEnvelope
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
  }

  export type IndicatorRemunerationUncheckedCreateNestedManyWithoutFacility_type_remunerationInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput> | IndicatorRemunerationCreateWithoutFacility_type_remunerationInput[] | IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput | IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput[]
    createMany?: IndicatorRemunerationCreateManyFacility_type_remunerationInputEnvelope
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
  }

  export type FacilityTypeUpdateOneRequiredWithoutRemunerationsNestedInput = {
    create?: XOR<FacilityTypeCreateWithoutRemunerationsInput, FacilityTypeUncheckedCreateWithoutRemunerationsInput>
    connectOrCreate?: FacilityTypeCreateOrConnectWithoutRemunerationsInput
    upsert?: FacilityTypeUpsertWithoutRemunerationsInput
    connect?: FacilityTypeWhereUniqueInput
    update?: XOR<XOR<FacilityTypeUpdateToOneWithWhereWithoutRemunerationsInput, FacilityTypeUpdateWithoutRemunerationsInput>, FacilityTypeUncheckedUpdateWithoutRemunerationsInput>
  }

  export type IndicatorRemunerationUpdateManyWithoutFacility_type_remunerationNestedInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput> | IndicatorRemunerationCreateWithoutFacility_type_remunerationInput[] | IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput | IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput[]
    upsert?: IndicatorRemunerationUpsertWithWhereUniqueWithoutFacility_type_remunerationInput | IndicatorRemunerationUpsertWithWhereUniqueWithoutFacility_type_remunerationInput[]
    createMany?: IndicatorRemunerationCreateManyFacility_type_remunerationInputEnvelope
    set?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    disconnect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    delete?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    update?: IndicatorRemunerationUpdateWithWhereUniqueWithoutFacility_type_remunerationInput | IndicatorRemunerationUpdateWithWhereUniqueWithoutFacility_type_remunerationInput[]
    updateMany?: IndicatorRemunerationUpdateManyWithWhereWithoutFacility_type_remunerationInput | IndicatorRemunerationUpdateManyWithWhereWithoutFacility_type_remunerationInput[]
    deleteMany?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
  }

  export type IndicatorRemunerationUncheckedUpdateManyWithoutFacility_type_remunerationNestedInput = {
    create?: XOR<IndicatorRemunerationCreateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput> | IndicatorRemunerationCreateWithoutFacility_type_remunerationInput[] | IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput[]
    connectOrCreate?: IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput | IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput[]
    upsert?: IndicatorRemunerationUpsertWithWhereUniqueWithoutFacility_type_remunerationInput | IndicatorRemunerationUpsertWithWhereUniqueWithoutFacility_type_remunerationInput[]
    createMany?: IndicatorRemunerationCreateManyFacility_type_remunerationInputEnvelope
    set?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    disconnect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    delete?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    connect?: IndicatorRemunerationWhereUniqueInput | IndicatorRemunerationWhereUniqueInput[]
    update?: IndicatorRemunerationUpdateWithWhereUniqueWithoutFacility_type_remunerationInput | IndicatorRemunerationUpdateWithWhereUniqueWithoutFacility_type_remunerationInput[]
    updateMany?: IndicatorRemunerationUpdateManyWithWhereWithoutFacility_type_remunerationInput | IndicatorRemunerationUpdateManyWithWhereWithoutFacility_type_remunerationInput[]
    deleteMany?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
  }

  export type FacilityTypeRemunerationCreateNestedOneWithoutIndicator_remunerationsInput = {
    create?: XOR<FacilityTypeRemunerationCreateWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUncheckedCreateWithoutIndicator_remunerationsInput>
    connectOrCreate?: FacilityTypeRemunerationCreateOrConnectWithoutIndicator_remunerationsInput
    connect?: FacilityTypeRemunerationWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutRemunerationsInput = {
    create?: XOR<IndicatorCreateWithoutRemunerationsInput, IndicatorUncheckedCreateWithoutRemunerationsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutRemunerationsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type RemunerationSystemCreateNestedOneWithoutIndicator_remunerationsInput = {
    create?: XOR<RemunerationSystemCreateWithoutIndicator_remunerationsInput, RemunerationSystemUncheckedCreateWithoutIndicator_remunerationsInput>
    connectOrCreate?: RemunerationSystemCreateOrConnectWithoutIndicator_remunerationsInput
    connect?: RemunerationSystemWhereUniqueInput
  }

  export type FacilityTypeRemunerationUpdateOneRequiredWithoutIndicator_remunerationsNestedInput = {
    create?: XOR<FacilityTypeRemunerationCreateWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUncheckedCreateWithoutIndicator_remunerationsInput>
    connectOrCreate?: FacilityTypeRemunerationCreateOrConnectWithoutIndicator_remunerationsInput
    upsert?: FacilityTypeRemunerationUpsertWithoutIndicator_remunerationsInput
    connect?: FacilityTypeRemunerationWhereUniqueInput
    update?: XOR<XOR<FacilityTypeRemunerationUpdateToOneWithWhereWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUpdateWithoutIndicator_remunerationsInput>, FacilityTypeRemunerationUncheckedUpdateWithoutIndicator_remunerationsInput>
  }

  export type IndicatorUpdateOneRequiredWithoutRemunerationsNestedInput = {
    create?: XOR<IndicatorCreateWithoutRemunerationsInput, IndicatorUncheckedCreateWithoutRemunerationsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutRemunerationsInput
    upsert?: IndicatorUpsertWithoutRemunerationsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutRemunerationsInput, IndicatorUpdateWithoutRemunerationsInput>, IndicatorUncheckedUpdateWithoutRemunerationsInput>
  }

  export type RemunerationSystemUpdateOneWithoutIndicator_remunerationsNestedInput = {
    create?: XOR<RemunerationSystemCreateWithoutIndicator_remunerationsInput, RemunerationSystemUncheckedCreateWithoutIndicator_remunerationsInput>
    connectOrCreate?: RemunerationSystemCreateOrConnectWithoutIndicator_remunerationsInput
    upsert?: RemunerationSystemUpsertWithoutIndicator_remunerationsInput
    disconnect?: RemunerationSystemWhereInput | boolean
    delete?: RemunerationSystemWhereInput | boolean
    connect?: RemunerationSystemWhereUniqueInput
    update?: XOR<XOR<RemunerationSystemUpdateToOneWithWhereWithoutIndicator_remunerationsInput, RemunerationSystemUpdateWithoutIndicator_remunerationsInput>, RemunerationSystemUncheckedUpdateWithoutIndicator_remunerationsInput>
  }

  export type FacilityCreateNestedOneWithoutPerformance_calculationsInput = {
    create?: XOR<FacilityCreateWithoutPerformance_calculationsInput, FacilityUncheckedCreateWithoutPerformance_calculationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutPerformance_calculationsInput
    connect?: FacilityWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutPerformance_calculationsInput = {
    create?: XOR<IndicatorCreateWithoutPerformance_calculationsInput, IndicatorUncheckedCreateWithoutPerformance_calculationsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutPerformance_calculationsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type sub_centreCreateNestedOneWithoutPerformance_calculationsInput = {
    create?: XOR<sub_centreCreateWithoutPerformance_calculationsInput, sub_centreUncheckedCreateWithoutPerformance_calculationsInput>
    connectOrCreate?: sub_centreCreateOrConnectWithoutPerformance_calculationsInput
    connect?: sub_centreWhereUniqueInput
  }

  export type FacilityUpdateOneWithoutPerformance_calculationsNestedInput = {
    create?: XOR<FacilityCreateWithoutPerformance_calculationsInput, FacilityUncheckedCreateWithoutPerformance_calculationsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutPerformance_calculationsInput
    upsert?: FacilityUpsertWithoutPerformance_calculationsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutPerformance_calculationsInput, FacilityUpdateWithoutPerformance_calculationsInput>, FacilityUncheckedUpdateWithoutPerformance_calculationsInput>
  }

  export type IndicatorUpdateOneRequiredWithoutPerformance_calculationsNestedInput = {
    create?: XOR<IndicatorCreateWithoutPerformance_calculationsInput, IndicatorUncheckedCreateWithoutPerformance_calculationsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutPerformance_calculationsInput
    upsert?: IndicatorUpsertWithoutPerformance_calculationsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutPerformance_calculationsInput, IndicatorUpdateWithoutPerformance_calculationsInput>, IndicatorUncheckedUpdateWithoutPerformance_calculationsInput>
  }

  export type sub_centreUpdateOneWithoutPerformance_calculationsNestedInput = {
    create?: XOR<sub_centreCreateWithoutPerformance_calculationsInput, sub_centreUncheckedCreateWithoutPerformance_calculationsInput>
    connectOrCreate?: sub_centreCreateOrConnectWithoutPerformance_calculationsInput
    upsert?: sub_centreUpsertWithoutPerformance_calculationsInput
    disconnect?: sub_centreWhereInput | boolean
    delete?: sub_centreWhereInput | boolean
    connect?: sub_centreWhereUniqueInput
    update?: XOR<XOR<sub_centreUpdateToOneWithWhereWithoutPerformance_calculationsInput, sub_centreUpdateWithoutPerformance_calculationsInput>, sub_centreUncheckedUpdateWithoutPerformance_calculationsInput>
  }

  export type FacilityCreateNestedOneWithoutFacility_targetsInput = {
    create?: XOR<FacilityCreateWithoutFacility_targetsInput, FacilityUncheckedCreateWithoutFacility_targetsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_targetsInput
    connect?: FacilityWhereUniqueInput
  }

  export type IndicatorCreateNestedOneWithoutFacility_targetsInput = {
    create?: XOR<IndicatorCreateWithoutFacility_targetsInput, IndicatorUncheckedCreateWithoutFacility_targetsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutFacility_targetsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutFacility_targetsNestedInput = {
    create?: XOR<FacilityCreateWithoutFacility_targetsInput, FacilityUncheckedCreateWithoutFacility_targetsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutFacility_targetsInput
    upsert?: FacilityUpsertWithoutFacility_targetsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutFacility_targetsInput, FacilityUpdateWithoutFacility_targetsInput>, FacilityUncheckedUpdateWithoutFacility_targetsInput>
  }

  export type IndicatorUpdateOneRequiredWithoutFacility_targetsNestedInput = {
    create?: XOR<IndicatorCreateWithoutFacility_targetsInput, IndicatorUncheckedCreateWithoutFacility_targetsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutFacility_targetsInput
    upsert?: IndicatorUpsertWithoutFacility_targetsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutFacility_targetsInput, IndicatorUpdateWithoutFacility_targetsInput>, IndicatorUncheckedUpdateWithoutFacility_targetsInput>
  }

  export type IndicatorCreateNestedOneWithoutWorker_allocationsInput = {
    create?: XOR<IndicatorCreateWithoutWorker_allocationsInput, IndicatorUncheckedCreateWithoutWorker_allocationsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutWorker_allocationsInput
    connect?: IndicatorWhereUniqueInput
  }

  export type IndicatorUpdateOneRequiredWithoutWorker_allocationsNestedInput = {
    create?: XOR<IndicatorCreateWithoutWorker_allocationsInput, IndicatorUncheckedCreateWithoutWorker_allocationsInput>
    connectOrCreate?: IndicatorCreateOrConnectWithoutWorker_allocationsInput
    upsert?: IndicatorUpsertWithoutWorker_allocationsInput
    connect?: IndicatorWhereUniqueInput
    update?: XOR<XOR<IndicatorUpdateToOneWithWhereWithoutWorker_allocationsInput, IndicatorUpdateWithoutWorker_allocationsInput>, IndicatorUncheckedUpdateWithoutWorker_allocationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumDataQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.DataQuality | EnumDataQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataQualityFilter<$PrismaModel> | $Enums.DataQuality
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumDataQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataQuality | EnumDataQualityFieldRefInput<$PrismaModel>
    in?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataQuality[] | ListEnumDataQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataQualityWithAggregatesFilter<$PrismaModel> | $Enums.DataQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataQualityFilter<$PrismaModel>
    _max?: NestedEnumDataQualityFilter<$PrismaModel>
  }

  export type NestedEnumUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusFilter<$PrismaModel> | $Enums.UploadStatus
  }

  export type NestedEnumUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UploadStatus | EnumUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UploadStatus[] | ListEnumUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.UploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumUploadStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeFilter<$PrismaModel> | $Enums.TargetType
  }

  export type NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TargetType | EnumTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TargetType[] | ListEnumTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.TargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumFieldCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldCategory | EnumFieldCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldCategoryFilter<$PrismaModel> | $Enums.FieldCategory
  }

  export type NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumFieldCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldCategory | EnumFieldCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldCategory[] | ListEnumFieldCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FieldCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldCategoryFilter<$PrismaModel>
    _max?: NestedEnumFieldCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DataUploadSessionCreateWithoutUploaderInput = {
    file_name: string
    report_month: string
    total_records: number
    success_count?: number
    error_count?: number
    status?: $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    completed_at?: Date | string | null
    file_path?: string | null
  }

  export type DataUploadSessionUncheckedCreateWithoutUploaderInput = {
    id?: number
    file_name: string
    report_month: string
    total_records: number
    success_count?: number
    error_count?: number
    status?: $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    completed_at?: Date | string | null
    file_path?: string | null
  }

  export type DataUploadSessionCreateOrConnectWithoutUploaderInput = {
    where: DataUploadSessionWhereUniqueInput
    create: XOR<DataUploadSessionCreateWithoutUploaderInput, DataUploadSessionUncheckedCreateWithoutUploaderInput>
  }

  export type DataUploadSessionCreateManyUploaderInputEnvelope = {
    data: DataUploadSessionCreateManyUploaderInput | DataUploadSessionCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type FieldValueCreateWithoutUploaderInput = {
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility?: FacilityCreateNestedOneWithoutField_valuesInput
    field: FieldCreateNestedOneWithoutField_valuesInput
  }

  export type FieldValueUncheckedCreateWithoutUploaderInput = {
    id?: number
    field_id: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility_id?: string | null
  }

  export type FieldValueCreateOrConnectWithoutUploaderInput = {
    where: FieldValueWhereUniqueInput
    create: XOR<FieldValueCreateWithoutUploaderInput, FieldValueUncheckedCreateWithoutUploaderInput>
  }

  export type FieldValueCreateManyUploaderInputEnvelope = {
    data: FieldValueCreateManyUploaderInput | FieldValueCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type MonthlyHealthDataCreateWithoutApproverInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    district: DistrictCreateNestedOneWithoutMonthly_dataInput
    facility?: FacilityCreateNestedOneWithoutMonthly_dataInput
    indicator?: IndicatorCreateNestedOneWithoutMonthly_dataInput
    sub_centre?: sub_centreCreateNestedOneWithoutMonthly_health_dataInput
    uploader: UserCreateNestedOneWithoutUploaded_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateWithoutApproverInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateOrConnectWithoutApproverInput = {
    where: MonthlyHealthDataWhereUniqueInput
    create: XOR<MonthlyHealthDataCreateWithoutApproverInput, MonthlyHealthDataUncheckedCreateWithoutApproverInput>
  }

  export type MonthlyHealthDataCreateManyApproverInputEnvelope = {
    data: MonthlyHealthDataCreateManyApproverInput | MonthlyHealthDataCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type MonthlyHealthDataCreateWithoutUploaderInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    approver?: UserCreateNestedOneWithoutApproved_dataInput
    district: DistrictCreateNestedOneWithoutMonthly_dataInput
    facility?: FacilityCreateNestedOneWithoutMonthly_dataInput
    indicator?: IndicatorCreateNestedOneWithoutMonthly_dataInput
    sub_centre?: sub_centreCreateNestedOneWithoutMonthly_health_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateWithoutUploaderInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateOrConnectWithoutUploaderInput = {
    where: MonthlyHealthDataWhereUniqueInput
    create: XOR<MonthlyHealthDataCreateWithoutUploaderInput, MonthlyHealthDataUncheckedCreateWithoutUploaderInput>
  }

  export type MonthlyHealthDataCreateManyUploaderInputEnvelope = {
    data: MonthlyHealthDataCreateManyUploaderInput | MonthlyHealthDataCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type FacilityCreateWithoutUsersInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutUsersInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
  }

  export type DataUploadSessionUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DataUploadSessionWhereUniqueInput
    update: XOR<DataUploadSessionUpdateWithoutUploaderInput, DataUploadSessionUncheckedUpdateWithoutUploaderInput>
    create: XOR<DataUploadSessionCreateWithoutUploaderInput, DataUploadSessionUncheckedCreateWithoutUploaderInput>
  }

  export type DataUploadSessionUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DataUploadSessionWhereUniqueInput
    data: XOR<DataUploadSessionUpdateWithoutUploaderInput, DataUploadSessionUncheckedUpdateWithoutUploaderInput>
  }

  export type DataUploadSessionUpdateManyWithWhereWithoutUploaderInput = {
    where: DataUploadSessionScalarWhereInput
    data: XOR<DataUploadSessionUpdateManyMutationInput, DataUploadSessionUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DataUploadSessionScalarWhereInput = {
    AND?: DataUploadSessionScalarWhereInput | DataUploadSessionScalarWhereInput[]
    OR?: DataUploadSessionScalarWhereInput[]
    NOT?: DataUploadSessionScalarWhereInput | DataUploadSessionScalarWhereInput[]
    id?: IntFilter<"DataUploadSession"> | number
    file_name?: StringFilter<"DataUploadSession"> | string
    report_month?: StringFilter<"DataUploadSession"> | string
    total_records?: IntFilter<"DataUploadSession"> | number
    success_count?: IntFilter<"DataUploadSession"> | number
    error_count?: IntFilter<"DataUploadSession"> | number
    status?: EnumUploadStatusFilter<"DataUploadSession"> | $Enums.UploadStatus
    upload_summary?: JsonNullableFilter<"DataUploadSession">
    uploaded_by?: IntFilter<"DataUploadSession"> | number
    created_at?: DateTimeFilter<"DataUploadSession"> | Date | string
    completed_at?: DateTimeNullableFilter<"DataUploadSession"> | Date | string | null
    file_path?: StringNullableFilter<"DataUploadSession"> | string | null
  }

  export type FieldValueUpsertWithWhereUniqueWithoutUploaderInput = {
    where: FieldValueWhereUniqueInput
    update: XOR<FieldValueUpdateWithoutUploaderInput, FieldValueUncheckedUpdateWithoutUploaderInput>
    create: XOR<FieldValueCreateWithoutUploaderInput, FieldValueUncheckedCreateWithoutUploaderInput>
  }

  export type FieldValueUpdateWithWhereUniqueWithoutUploaderInput = {
    where: FieldValueWhereUniqueInput
    data: XOR<FieldValueUpdateWithoutUploaderInput, FieldValueUncheckedUpdateWithoutUploaderInput>
  }

  export type FieldValueUpdateManyWithWhereWithoutUploaderInput = {
    where: FieldValueScalarWhereInput
    data: XOR<FieldValueUpdateManyMutationInput, FieldValueUncheckedUpdateManyWithoutUploaderInput>
  }

  export type FieldValueScalarWhereInput = {
    AND?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
    OR?: FieldValueScalarWhereInput[]
    NOT?: FieldValueScalarWhereInput | FieldValueScalarWhereInput[]
    id?: IntFilter<"FieldValue"> | number
    field_id?: IntFilter<"FieldValue"> | number
    report_month?: StringFilter<"FieldValue"> | string
    string_value?: StringNullableFilter<"FieldValue"> | string | null
    numeric_value?: DecimalNullableFilter<"FieldValue"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableFilter<"FieldValue"> | boolean | null
    json_value?: JsonNullableFilter<"FieldValue">
    uploaded_by?: IntFilter<"FieldValue"> | number
    remarks?: StringNullableFilter<"FieldValue"> | string | null
    created_at?: DateTimeFilter<"FieldValue"> | Date | string
    updated_at?: DateTimeFilter<"FieldValue"> | Date | string
    is_override?: BoolFilter<"FieldValue"> | boolean
    override_reason?: StringNullableFilter<"FieldValue"> | string | null
    facility_id?: StringNullableFilter<"FieldValue"> | string | null
  }

  export type MonthlyHealthDataUpsertWithWhereUniqueWithoutApproverInput = {
    where: MonthlyHealthDataWhereUniqueInput
    update: XOR<MonthlyHealthDataUpdateWithoutApproverInput, MonthlyHealthDataUncheckedUpdateWithoutApproverInput>
    create: XOR<MonthlyHealthDataCreateWithoutApproverInput, MonthlyHealthDataUncheckedCreateWithoutApproverInput>
  }

  export type MonthlyHealthDataUpdateWithWhereUniqueWithoutApproverInput = {
    where: MonthlyHealthDataWhereUniqueInput
    data: XOR<MonthlyHealthDataUpdateWithoutApproverInput, MonthlyHealthDataUncheckedUpdateWithoutApproverInput>
  }

  export type MonthlyHealthDataUpdateManyWithWhereWithoutApproverInput = {
    where: MonthlyHealthDataScalarWhereInput
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyWithoutApproverInput>
  }

  export type MonthlyHealthDataScalarWhereInput = {
    AND?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
    OR?: MonthlyHealthDataScalarWhereInput[]
    NOT?: MonthlyHealthDataScalarWhereInput | MonthlyHealthDataScalarWhereInput[]
    id?: IntFilter<"MonthlyHealthData"> | number
    sub_centre_id?: IntNullableFilter<"MonthlyHealthData"> | number | null
    report_month?: StringFilter<"MonthlyHealthData"> | string
    value?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFilter<"MonthlyHealthData"> | $Enums.DataQuality
    remarks?: StringNullableFilter<"MonthlyHealthData"> | string | null
    uploaded_by?: IntFilter<"MonthlyHealthData"> | number
    approved_by?: IntNullableFilter<"MonthlyHealthData"> | number | null
    approved_at?: DateTimeNullableFilter<"MonthlyHealthData"> | Date | string | null
    created_at?: DateTimeFilter<"MonthlyHealthData"> | Date | string
    updated_at?: DateTimeFilter<"MonthlyHealthData"> | Date | string
    achievement?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    numerator?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableFilter<"MonthlyHealthData"> | Decimal | DecimalJsLike | number | string | null
    indicator_id?: IntNullableFilter<"MonthlyHealthData"> | number | null
    district_id?: StringFilter<"MonthlyHealthData"> | string
    facility_id?: StringNullableFilter<"MonthlyHealthData"> | string | null
  }

  export type MonthlyHealthDataUpsertWithWhereUniqueWithoutUploaderInput = {
    where: MonthlyHealthDataWhereUniqueInput
    update: XOR<MonthlyHealthDataUpdateWithoutUploaderInput, MonthlyHealthDataUncheckedUpdateWithoutUploaderInput>
    create: XOR<MonthlyHealthDataCreateWithoutUploaderInput, MonthlyHealthDataUncheckedCreateWithoutUploaderInput>
  }

  export type MonthlyHealthDataUpdateWithWhereUniqueWithoutUploaderInput = {
    where: MonthlyHealthDataWhereUniqueInput
    data: XOR<MonthlyHealthDataUpdateWithoutUploaderInput, MonthlyHealthDataUncheckedUpdateWithoutUploaderInput>
  }

  export type MonthlyHealthDataUpdateManyWithWhereWithoutUploaderInput = {
    where: MonthlyHealthDataScalarWhereInput
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyWithoutUploaderInput>
  }

  export type FacilityUpsertWithoutUsersInput = {
    update: XOR<FacilityUpdateWithoutUsersInput, FacilityUncheckedUpdateWithoutUsersInput>
    create: XOR<FacilityCreateWithoutUsersInput, FacilityUncheckedCreateWithoutUsersInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutUsersInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutUsersInput, FacilityUncheckedUpdateWithoutUsersInput>
  }

  export type FacilityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateWithoutDistrictInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutDistrictInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutDistrictInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutDistrictInput, FacilityUncheckedCreateWithoutDistrictInput>
  }

  export type FacilityCreateManyDistrictInputEnvelope = {
    data: FacilityCreateManyDistrictInput | FacilityCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type MonthlyHealthDataCreateWithoutDistrictInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    approver?: UserCreateNestedOneWithoutApproved_dataInput
    facility?: FacilityCreateNestedOneWithoutMonthly_dataInput
    indicator?: IndicatorCreateNestedOneWithoutMonthly_dataInput
    sub_centre?: sub_centreCreateNestedOneWithoutMonthly_health_dataInput
    uploader: UserCreateNestedOneWithoutUploaded_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateWithoutDistrictInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateOrConnectWithoutDistrictInput = {
    where: MonthlyHealthDataWhereUniqueInput
    create: XOR<MonthlyHealthDataCreateWithoutDistrictInput, MonthlyHealthDataUncheckedCreateWithoutDistrictInput>
  }

  export type MonthlyHealthDataCreateManyDistrictInputEnvelope = {
    data: MonthlyHealthDataCreateManyDistrictInput | MonthlyHealthDataCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithWhereUniqueWithoutDistrictInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutDistrictInput, FacilityUncheckedUpdateWithoutDistrictInput>
    create: XOR<FacilityCreateWithoutDistrictInput, FacilityUncheckedCreateWithoutDistrictInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutDistrictInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutDistrictInput, FacilityUncheckedUpdateWithoutDistrictInput>
  }

  export type FacilityUpdateManyWithWhereWithoutDistrictInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutDistrictInput>
  }

  export type FacilityScalarWhereInput = {
    AND?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    OR?: FacilityScalarWhereInput[]
    NOT?: FacilityScalarWhereInput | FacilityScalarWhereInput[]
    id?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    created_at?: DateTimeFilter<"Facility"> | Date | string
    description?: StringNullableFilter<"Facility"> | string | null
    display_name?: StringFilter<"Facility"> | string
    district_id?: StringFilter<"Facility"> | string
    facility_type_id?: StringFilter<"Facility"> | string
    is_active?: BoolFilter<"Facility"> | boolean
    updated_at?: DateTimeFilter<"Facility"> | Date | string
  }

  export type MonthlyHealthDataUpsertWithWhereUniqueWithoutDistrictInput = {
    where: MonthlyHealthDataWhereUniqueInput
    update: XOR<MonthlyHealthDataUpdateWithoutDistrictInput, MonthlyHealthDataUncheckedUpdateWithoutDistrictInput>
    create: XOR<MonthlyHealthDataCreateWithoutDistrictInput, MonthlyHealthDataUncheckedCreateWithoutDistrictInput>
  }

  export type MonthlyHealthDataUpdateWithWhereUniqueWithoutDistrictInput = {
    where: MonthlyHealthDataWhereUniqueInput
    data: XOR<MonthlyHealthDataUpdateWithoutDistrictInput, MonthlyHealthDataUncheckedUpdateWithoutDistrictInput>
  }

  export type MonthlyHealthDataUpdateManyWithWhereWithoutDistrictInput = {
    where: MonthlyHealthDataScalarWhereInput
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyWithoutDistrictInput>
  }

  export type IndicatorRemunerationCreateWithoutRemuneration_systemInput = {
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_remuneration: FacilityTypeRemunerationCreateNestedOneWithoutIndicator_remunerationsInput
    indicator: IndicatorCreateNestedOneWithoutRemunerationsInput
  }

  export type IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput = {
    id?: number
    facility_type_remuneration_id: number
    indicator_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IndicatorRemunerationCreateOrConnectWithoutRemuneration_systemInput = {
    where: IndicatorRemunerationWhereUniqueInput
    create: XOR<IndicatorRemunerationCreateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput>
  }

  export type IndicatorRemunerationCreateManyRemuneration_systemInputEnvelope = {
    data: IndicatorRemunerationCreateManyRemuneration_systemInput | IndicatorRemunerationCreateManyRemuneration_systemInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorRemunerationUpsertWithWhereUniqueWithoutRemuneration_systemInput = {
    where: IndicatorRemunerationWhereUniqueInput
    update: XOR<IndicatorRemunerationUpdateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedUpdateWithoutRemuneration_systemInput>
    create: XOR<IndicatorRemunerationCreateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedCreateWithoutRemuneration_systemInput>
  }

  export type IndicatorRemunerationUpdateWithWhereUniqueWithoutRemuneration_systemInput = {
    where: IndicatorRemunerationWhereUniqueInput
    data: XOR<IndicatorRemunerationUpdateWithoutRemuneration_systemInput, IndicatorRemunerationUncheckedUpdateWithoutRemuneration_systemInput>
  }

  export type IndicatorRemunerationUpdateManyWithWhereWithoutRemuneration_systemInput = {
    where: IndicatorRemunerationScalarWhereInput
    data: XOR<IndicatorRemunerationUpdateManyMutationInput, IndicatorRemunerationUncheckedUpdateManyWithoutRemuneration_systemInput>
  }

  export type IndicatorRemunerationScalarWhereInput = {
    AND?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
    OR?: IndicatorRemunerationScalarWhereInput[]
    NOT?: IndicatorRemunerationScalarWhereInput | IndicatorRemunerationScalarWhereInput[]
    id?: IntFilter<"IndicatorRemuneration"> | number
    facility_type_remuneration_id?: IntFilter<"IndicatorRemuneration"> | number
    indicator_id?: IntFilter<"IndicatorRemuneration"> | number
    base_amount?: DecimalFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string
    conditional_amount?: DecimalNullableFilter<"IndicatorRemuneration"> | Decimal | DecimalJsLike | number | string | null
    condition_type?: StringNullableFilter<"IndicatorRemuneration"> | string | null
    created_at?: DateTimeFilter<"IndicatorRemuneration"> | Date | string
    updated_at?: DateTimeFilter<"IndicatorRemuneration"> | Date | string
    remuneration_system_id?: StringNullableFilter<"IndicatorRemuneration"> | string | null
  }

  export type FacilityCreateWithoutFacility_typeInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutFacility_typeInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutFacility_typeInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutFacility_typeInput, FacilityUncheckedCreateWithoutFacility_typeInput>
  }

  export type FacilityCreateManyFacility_typeInputEnvelope = {
    data: FacilityCreateManyFacility_typeInput | FacilityCreateManyFacility_typeInput[]
    skipDuplicates?: boolean
  }

  export type FacilityFieldMappingCreateWithoutFacility_typeInput = {
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    field: FieldCreateNestedOneWithoutFacility_field_mappingsInput
  }

  export type FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput = {
    id?: number
    field_id: number
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityFieldMappingCreateOrConnectWithoutFacility_typeInput = {
    where: FacilityFieldMappingWhereUniqueInput
    create: XOR<FacilityFieldMappingCreateWithoutFacility_typeInput, FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput>
  }

  export type FacilityFieldMappingCreateManyFacility_typeInputEnvelope = {
    data: FacilityFieldMappingCreateManyFacility_typeInput | FacilityFieldMappingCreateManyFacility_typeInput[]
    skipDuplicates?: boolean
  }

  export type FacilityTypeRemunerationCreateWithoutFacility_typeInput = {
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    indicator_remunerations?: IndicatorRemunerationCreateNestedManyWithoutFacility_type_remunerationInput
  }

  export type FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput = {
    id?: number
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    indicator_remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutFacility_type_remunerationInput
  }

  export type FacilityTypeRemunerationCreateOrConnectWithoutFacility_typeInput = {
    where: FacilityTypeRemunerationWhereUniqueInput
    create: XOR<FacilityTypeRemunerationCreateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigCreateWithoutFacility_typeInput = {
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutWorker_allocation_configInput
  }

  export type WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput = {
    id?: number
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutWorker_allocation_configInput
  }

  export type WorkerAllocationConfigCreateOrConnectWithoutFacility_typeInput = {
    where: WorkerAllocationConfigWhereUniqueInput
    create: XOR<WorkerAllocationConfigCreateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigCreateManyFacility_typeInputEnvelope = {
    data: WorkerAllocationConfigCreateManyFacility_typeInput | WorkerAllocationConfigCreateManyFacility_typeInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithWhereUniqueWithoutFacility_typeInput = {
    where: FacilityWhereUniqueInput
    update: XOR<FacilityUpdateWithoutFacility_typeInput, FacilityUncheckedUpdateWithoutFacility_typeInput>
    create: XOR<FacilityCreateWithoutFacility_typeInput, FacilityUncheckedCreateWithoutFacility_typeInput>
  }

  export type FacilityUpdateWithWhereUniqueWithoutFacility_typeInput = {
    where: FacilityWhereUniqueInput
    data: XOR<FacilityUpdateWithoutFacility_typeInput, FacilityUncheckedUpdateWithoutFacility_typeInput>
  }

  export type FacilityUpdateManyWithWhereWithoutFacility_typeInput = {
    where: FacilityScalarWhereInput
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyWithoutFacility_typeInput>
  }

  export type FacilityFieldMappingUpsertWithWhereUniqueWithoutFacility_typeInput = {
    where: FacilityFieldMappingWhereUniqueInput
    update: XOR<FacilityFieldMappingUpdateWithoutFacility_typeInput, FacilityFieldMappingUncheckedUpdateWithoutFacility_typeInput>
    create: XOR<FacilityFieldMappingCreateWithoutFacility_typeInput, FacilityFieldMappingUncheckedCreateWithoutFacility_typeInput>
  }

  export type FacilityFieldMappingUpdateWithWhereUniqueWithoutFacility_typeInput = {
    where: FacilityFieldMappingWhereUniqueInput
    data: XOR<FacilityFieldMappingUpdateWithoutFacility_typeInput, FacilityFieldMappingUncheckedUpdateWithoutFacility_typeInput>
  }

  export type FacilityFieldMappingUpdateManyWithWhereWithoutFacility_typeInput = {
    where: FacilityFieldMappingScalarWhereInput
    data: XOR<FacilityFieldMappingUpdateManyMutationInput, FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeInput>
  }

  export type FacilityFieldMappingScalarWhereInput = {
    AND?: FacilityFieldMappingScalarWhereInput | FacilityFieldMappingScalarWhereInput[]
    OR?: FacilityFieldMappingScalarWhereInput[]
    NOT?: FacilityFieldMappingScalarWhereInput | FacilityFieldMappingScalarWhereInput[]
    id?: IntFilter<"FacilityFieldMapping"> | number
    field_id?: IntFilter<"FacilityFieldMapping"> | number
    is_required?: BoolFilter<"FacilityFieldMapping"> | boolean
    display_order?: IntFilter<"FacilityFieldMapping"> | number
    created_at?: DateTimeFilter<"FacilityFieldMapping"> | Date | string
    updated_at?: DateTimeFilter<"FacilityFieldMapping"> | Date | string
    facility_type_id?: StringFilter<"FacilityFieldMapping"> | string
  }

  export type FacilityTypeRemunerationUpsertWithoutFacility_typeInput = {
    update: XOR<FacilityTypeRemunerationUpdateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedUpdateWithoutFacility_typeInput>
    create: XOR<FacilityTypeRemunerationCreateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedCreateWithoutFacility_typeInput>
    where?: FacilityTypeRemunerationWhereInput
  }

  export type FacilityTypeRemunerationUpdateToOneWithWhereWithoutFacility_typeInput = {
    where?: FacilityTypeRemunerationWhereInput
    data: XOR<FacilityTypeRemunerationUpdateWithoutFacility_typeInput, FacilityTypeRemunerationUncheckedUpdateWithoutFacility_typeInput>
  }

  export type FacilityTypeRemunerationUpdateWithoutFacility_typeInput = {
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator_remunerations?: IndicatorRemunerationUpdateManyWithoutFacility_type_remunerationNestedInput
  }

  export type FacilityTypeRemunerationUncheckedUpdateWithoutFacility_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator_remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutFacility_type_remunerationNestedInput
  }

  export type WorkerAllocationConfigUpsertWithWhereUniqueWithoutFacility_typeInput = {
    where: WorkerAllocationConfigWhereUniqueInput
    update: XOR<WorkerAllocationConfigUpdateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedUpdateWithoutFacility_typeInput>
    create: XOR<WorkerAllocationConfigCreateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigUpdateWithWhereUniqueWithoutFacility_typeInput = {
    where: WorkerAllocationConfigWhereUniqueInput
    data: XOR<WorkerAllocationConfigUpdateWithoutFacility_typeInput, WorkerAllocationConfigUncheckedUpdateWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigUpdateManyWithWhereWithoutFacility_typeInput = {
    where: WorkerAllocationConfigScalarWhereInput
    data: XOR<WorkerAllocationConfigUpdateManyMutationInput, WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeInput>
  }

  export type WorkerAllocationConfigScalarWhereInput = {
    AND?: WorkerAllocationConfigScalarWhereInput | WorkerAllocationConfigScalarWhereInput[]
    OR?: WorkerAllocationConfigScalarWhereInput[]
    NOT?: WorkerAllocationConfigScalarWhereInput | WorkerAllocationConfigScalarWhereInput[]
    id?: IntFilter<"WorkerAllocationConfig"> | number
    facility_type_id?: StringFilter<"WorkerAllocationConfig"> | string
    worker_type?: StringFilter<"WorkerAllocationConfig"> | string
    worker_role?: StringFilter<"WorkerAllocationConfig"> | string
    max_count?: IntFilter<"WorkerAllocationConfig"> | number
    allocated_amount?: DecimalFilter<"WorkerAllocationConfig"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WorkerAllocationConfig"> | string | null
    is_active?: BoolFilter<"WorkerAllocationConfig"> | boolean
    created_at?: DateTimeFilter<"WorkerAllocationConfig"> | Date | string
    updated_at?: DateTimeFilter<"WorkerAllocationConfig"> | Date | string
  }

  export type DistrictCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutFacilitiesInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutFacilitiesInput, DistrictUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityTypeCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationCreateNestedOneWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeUncheckedCreateWithoutFacilitiesInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationUncheckedCreateNestedOneWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigUncheckedCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeCreateOrConnectWithoutFacilitiesInput = {
    where: FacilityTypeWhereUniqueInput
    create: XOR<FacilityTypeCreateWithoutFacilitiesInput, FacilityTypeUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityFieldDefaultsCreateWithoutFacilityInput = {
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    field: FieldCreateNestedOneWithoutFacility_field_defaultsInput
  }

  export type FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput = {
    id?: number
    field_id: number
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityFieldDefaultsCreateOrConnectWithoutFacilityInput = {
    where: FacilityFieldDefaultsWhereUniqueInput
    create: XOR<FacilityFieldDefaultsCreateWithoutFacilityInput, FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityFieldDefaultsCreateManyFacilityInputEnvelope = {
    data: FacilityFieldDefaultsCreateManyFacilityInput | FacilityFieldDefaultsCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type FacilityTargetCreateWithoutFacilityInput = {
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    indicator: IndicatorCreateNestedOneWithoutFacility_targetsInput
  }

  export type FacilityTargetUncheckedCreateWithoutFacilityInput = {
    id?: number
    indicator_id: number
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityTargetCreateOrConnectWithoutFacilityInput = {
    where: FacilityTargetWhereUniqueInput
    create: XOR<FacilityTargetCreateWithoutFacilityInput, FacilityTargetUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityTargetCreateManyFacilityInputEnvelope = {
    data: FacilityTargetCreateManyFacilityInput | FacilityTargetCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type FacilityWorkerAllocationCreateWithoutFacilityInput = {
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    worker_allocation_config: WorkerAllocationConfigCreateNestedOneWithoutFacility_allocationsInput
  }

  export type FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput = {
    id?: number
    worker_allocation_config_id: number
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityWorkerAllocationCreateOrConnectWithoutFacilityInput = {
    where: FacilityWorkerAllocationWhereUniqueInput
    create: XOR<FacilityWorkerAllocationCreateWithoutFacilityInput, FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityWorkerAllocationCreateManyFacilityInputEnvelope = {
    data: FacilityWorkerAllocationCreateManyFacilityInput | FacilityWorkerAllocationCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type FieldValueCreateWithoutFacilityInput = {
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    field: FieldCreateNestedOneWithoutField_valuesInput
    uploader: UserCreateNestedOneWithoutField_valuesInput
  }

  export type FieldValueUncheckedCreateWithoutFacilityInput = {
    id?: number
    field_id: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
  }

  export type FieldValueCreateOrConnectWithoutFacilityInput = {
    where: FieldValueWhereUniqueInput
    create: XOR<FieldValueCreateWithoutFacilityInput, FieldValueUncheckedCreateWithoutFacilityInput>
  }

  export type FieldValueCreateManyFacilityInputEnvelope = {
    data: FieldValueCreateManyFacilityInput | FieldValueCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type HealthWorkerCreateWithoutFacilityInput = {
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_calculations?: WorkerRemunerationCreateNestedManyWithoutHealth_workerInput
  }

  export type HealthWorkerUncheckedCreateWithoutFacilityInput = {
    id?: number
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_calculations?: WorkerRemunerationUncheckedCreateNestedManyWithoutHealth_workerInput
  }

  export type HealthWorkerCreateOrConnectWithoutFacilityInput = {
    where: HealthWorkerWhereUniqueInput
    create: XOR<HealthWorkerCreateWithoutFacilityInput, HealthWorkerUncheckedCreateWithoutFacilityInput>
  }

  export type HealthWorkerCreateManyFacilityInputEnvelope = {
    data: HealthWorkerCreateManyFacilityInput | HealthWorkerCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type MonthlyHealthDataCreateWithoutFacilityInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    approver?: UserCreateNestedOneWithoutApproved_dataInput
    district: DistrictCreateNestedOneWithoutMonthly_dataInput
    indicator?: IndicatorCreateNestedOneWithoutMonthly_dataInput
    sub_centre?: sub_centreCreateNestedOneWithoutMonthly_health_dataInput
    uploader: UserCreateNestedOneWithoutUploaded_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateWithoutFacilityInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
  }

  export type MonthlyHealthDataCreateOrConnectWithoutFacilityInput = {
    where: MonthlyHealthDataWhereUniqueInput
    create: XOR<MonthlyHealthDataCreateWithoutFacilityInput, MonthlyHealthDataUncheckedCreateWithoutFacilityInput>
  }

  export type MonthlyHealthDataCreateManyFacilityInputEnvelope = {
    data: MonthlyHealthDataCreateManyFacilityInput | MonthlyHealthDataCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceCalculationCreateWithoutFacilityInput = {
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    indicator: IndicatorCreateNestedOneWithoutPerformance_calculationsInput
    sub_centre?: sub_centreCreateNestedOneWithoutPerformance_calculationsInput
  }

  export type PerformanceCalculationUncheckedCreateWithoutFacilityInput = {
    id?: number
    sub_centre_id?: number | null
    indicator_id: number
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
  }

  export type PerformanceCalculationCreateOrConnectWithoutFacilityInput = {
    where: PerformanceCalculationWhereUniqueInput
    create: XOR<PerformanceCalculationCreateWithoutFacilityInput, PerformanceCalculationUncheckedCreateWithoutFacilityInput>
  }

  export type PerformanceCalculationCreateManyFacilityInputEnvelope = {
    data: PerformanceCalculationCreateManyFacilityInput | PerformanceCalculationCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type RemunerationCalculationCreateWithoutFacilityInput = {
    report_month: string
    performance_percentage: Decimal | DecimalJsLike | number | string
    facility_remuneration: Decimal | DecimalJsLike | number | string
    total_worker_remuneration: Decimal | DecimalJsLike | number | string
    total_remuneration: Decimal | DecimalJsLike | number | string
    health_workers_count?: number
    asha_workers_count?: number
    calculated_at?: Date | string
  }

  export type RemunerationCalculationUncheckedCreateWithoutFacilityInput = {
    id?: number
    report_month: string
    performance_percentage: Decimal | DecimalJsLike | number | string
    facility_remuneration: Decimal | DecimalJsLike | number | string
    total_worker_remuneration: Decimal | DecimalJsLike | number | string
    total_remuneration: Decimal | DecimalJsLike | number | string
    health_workers_count?: number
    asha_workers_count?: number
    calculated_at?: Date | string
  }

  export type RemunerationCalculationCreateOrConnectWithoutFacilityInput = {
    where: RemunerationCalculationWhereUniqueInput
    create: XOR<RemunerationCalculationCreateWithoutFacilityInput, RemunerationCalculationUncheckedCreateWithoutFacilityInput>
  }

  export type RemunerationCalculationCreateManyFacilityInputEnvelope = {
    data: RemunerationCalculationCreateManyFacilityInput | RemunerationCalculationCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type sub_centreCreateWithoutFacilityInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    monthly_health_data?: MonthlyHealthDataCreateNestedManyWithoutSub_centreInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutSub_centreInput
  }

  export type sub_centreUncheckedCreateWithoutFacilityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    monthly_health_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutSub_centreInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutSub_centreInput
  }

  export type sub_centreCreateOrConnectWithoutFacilityInput = {
    where: sub_centreWhereUniqueInput
    create: XOR<sub_centreCreateWithoutFacilityInput, sub_centreUncheckedCreateWithoutFacilityInput>
  }

  export type sub_centreCreateManyFacilityInputEnvelope = {
    data: sub_centreCreateManyFacilityInput | sub_centreCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFacilityInput = {
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    upload_sessions?: DataUploadSessionCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataCreateNestedManyWithoutUploaderInput
  }

  export type UserUncheckedCreateWithoutFacilityInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    upload_sessions?: DataUploadSessionUncheckedCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutFacilityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFacilityInput, UserUncheckedCreateWithoutFacilityInput>
  }

  export type UserCreateManyFacilityInputEnvelope = {
    data: UserCreateManyFacilityInput | UserCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type DistrictUpsertWithoutFacilitiesInput = {
    update: XOR<DistrictUpdateWithoutFacilitiesInput, DistrictUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<DistrictCreateWithoutFacilitiesInput, DistrictUncheckedCreateWithoutFacilitiesInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutFacilitiesInput, DistrictUncheckedUpdateWithoutFacilitiesInput>
  }

  export type DistrictUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_data?: MonthlyHealthDataUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type FacilityTypeUpsertWithoutFacilitiesInput = {
    update: XOR<FacilityTypeUpdateWithoutFacilitiesInput, FacilityTypeUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<FacilityTypeCreateWithoutFacilitiesInput, FacilityTypeUncheckedCreateWithoutFacilitiesInput>
    where?: FacilityTypeWhereInput
  }

  export type FacilityTypeUpdateToOneWithWhereWithoutFacilitiesInput = {
    where?: FacilityTypeWhereInput
    data: XOR<FacilityTypeUpdateWithoutFacilitiesInput, FacilityTypeUncheckedUpdateWithoutFacilitiesInput>
  }

  export type FacilityTypeUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_mappings?: FacilityFieldMappingUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUpdateOneWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUpdateManyWithoutFacility_typeNestedInput
  }

  export type FacilityTypeUncheckedUpdateWithoutFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUncheckedUpdateOneWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeNestedInput
  }

  export type FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FacilityFieldDefaultsWhereUniqueInput
    update: XOR<FacilityFieldDefaultsUpdateWithoutFacilityInput, FacilityFieldDefaultsUncheckedUpdateWithoutFacilityInput>
    create: XOR<FacilityFieldDefaultsCreateWithoutFacilityInput, FacilityFieldDefaultsUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FacilityFieldDefaultsWhereUniqueInput
    data: XOR<FacilityFieldDefaultsUpdateWithoutFacilityInput, FacilityFieldDefaultsUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityFieldDefaultsUpdateManyWithWhereWithoutFacilityInput = {
    where: FacilityFieldDefaultsScalarWhereInput
    data: XOR<FacilityFieldDefaultsUpdateManyMutationInput, FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityInput>
  }

  export type FacilityFieldDefaultsScalarWhereInput = {
    AND?: FacilityFieldDefaultsScalarWhereInput | FacilityFieldDefaultsScalarWhereInput[]
    OR?: FacilityFieldDefaultsScalarWhereInput[]
    NOT?: FacilityFieldDefaultsScalarWhereInput | FacilityFieldDefaultsScalarWhereInput[]
    id?: IntFilter<"FacilityFieldDefaults"> | number
    field_id?: IntFilter<"FacilityFieldDefaults"> | number
    string_value?: StringNullableFilter<"FacilityFieldDefaults"> | string | null
    numeric_value?: DecimalNullableFilter<"FacilityFieldDefaults"> | Decimal | DecimalJsLike | number | string | null
    boolean_value?: BoolNullableFilter<"FacilityFieldDefaults"> | boolean | null
    json_value?: JsonNullableFilter<"FacilityFieldDefaults">
    is_active?: BoolFilter<"FacilityFieldDefaults"> | boolean
    created_at?: DateTimeFilter<"FacilityFieldDefaults"> | Date | string
    updated_at?: DateTimeFilter<"FacilityFieldDefaults"> | Date | string
    facility_id?: StringFilter<"FacilityFieldDefaults"> | string
  }

  export type FacilityTargetUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FacilityTargetWhereUniqueInput
    update: XOR<FacilityTargetUpdateWithoutFacilityInput, FacilityTargetUncheckedUpdateWithoutFacilityInput>
    create: XOR<FacilityTargetCreateWithoutFacilityInput, FacilityTargetUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityTargetUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FacilityTargetWhereUniqueInput
    data: XOR<FacilityTargetUpdateWithoutFacilityInput, FacilityTargetUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityTargetUpdateManyWithWhereWithoutFacilityInput = {
    where: FacilityTargetScalarWhereInput
    data: XOR<FacilityTargetUpdateManyMutationInput, FacilityTargetUncheckedUpdateManyWithoutFacilityInput>
  }

  export type FacilityTargetScalarWhereInput = {
    AND?: FacilityTargetScalarWhereInput | FacilityTargetScalarWhereInput[]
    OR?: FacilityTargetScalarWhereInput[]
    NOT?: FacilityTargetScalarWhereInput | FacilityTargetScalarWhereInput[]
    id?: IntFilter<"FacilityTarget"> | number
    indicator_id?: IntFilter<"FacilityTarget"> | number
    report_month?: StringFilter<"FacilityTarget"> | string
    target_value?: DecimalFilter<"FacilityTarget"> | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFilter<"FacilityTarget"> | string
    denominator_label?: StringFilter<"FacilityTarget"> | string
    created_at?: DateTimeFilter<"FacilityTarget"> | Date | string
    updated_at?: DateTimeFilter<"FacilityTarget"> | Date | string
    facility_id?: StringFilter<"FacilityTarget"> | string
  }

  export type FacilityWorkerAllocationUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FacilityWorkerAllocationWhereUniqueInput
    update: XOR<FacilityWorkerAllocationUpdateWithoutFacilityInput, FacilityWorkerAllocationUncheckedUpdateWithoutFacilityInput>
    create: XOR<FacilityWorkerAllocationCreateWithoutFacilityInput, FacilityWorkerAllocationUncheckedCreateWithoutFacilityInput>
  }

  export type FacilityWorkerAllocationUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FacilityWorkerAllocationWhereUniqueInput
    data: XOR<FacilityWorkerAllocationUpdateWithoutFacilityInput, FacilityWorkerAllocationUncheckedUpdateWithoutFacilityInput>
  }

  export type FacilityWorkerAllocationUpdateManyWithWhereWithoutFacilityInput = {
    where: FacilityWorkerAllocationScalarWhereInput
    data: XOR<FacilityWorkerAllocationUpdateManyMutationInput, FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityInput>
  }

  export type FacilityWorkerAllocationScalarWhereInput = {
    AND?: FacilityWorkerAllocationScalarWhereInput | FacilityWorkerAllocationScalarWhereInput[]
    OR?: FacilityWorkerAllocationScalarWhereInput[]
    NOT?: FacilityWorkerAllocationScalarWhereInput | FacilityWorkerAllocationScalarWhereInput[]
    id?: IntFilter<"FacilityWorkerAllocation"> | number
    facility_id?: StringFilter<"FacilityWorkerAllocation"> | string
    worker_allocation_config_id?: IntFilter<"FacilityWorkerAllocation"> | number
    worker_count?: IntFilter<"FacilityWorkerAllocation"> | number
    total_allocated_amount?: DecimalFilter<"FacilityWorkerAllocation"> | Decimal | DecimalJsLike | number | string
    is_active?: BoolFilter<"FacilityWorkerAllocation"> | boolean
    created_at?: DateTimeFilter<"FacilityWorkerAllocation"> | Date | string
    updated_at?: DateTimeFilter<"FacilityWorkerAllocation"> | Date | string
  }

  export type FieldValueUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FieldValueWhereUniqueInput
    update: XOR<FieldValueUpdateWithoutFacilityInput, FieldValueUncheckedUpdateWithoutFacilityInput>
    create: XOR<FieldValueCreateWithoutFacilityInput, FieldValueUncheckedCreateWithoutFacilityInput>
  }

  export type FieldValueUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FieldValueWhereUniqueInput
    data: XOR<FieldValueUpdateWithoutFacilityInput, FieldValueUncheckedUpdateWithoutFacilityInput>
  }

  export type FieldValueUpdateManyWithWhereWithoutFacilityInput = {
    where: FieldValueScalarWhereInput
    data: XOR<FieldValueUpdateManyMutationInput, FieldValueUncheckedUpdateManyWithoutFacilityInput>
  }

  export type HealthWorkerUpsertWithWhereUniqueWithoutFacilityInput = {
    where: HealthWorkerWhereUniqueInput
    update: XOR<HealthWorkerUpdateWithoutFacilityInput, HealthWorkerUncheckedUpdateWithoutFacilityInput>
    create: XOR<HealthWorkerCreateWithoutFacilityInput, HealthWorkerUncheckedCreateWithoutFacilityInput>
  }

  export type HealthWorkerUpdateWithWhereUniqueWithoutFacilityInput = {
    where: HealthWorkerWhereUniqueInput
    data: XOR<HealthWorkerUpdateWithoutFacilityInput, HealthWorkerUncheckedUpdateWithoutFacilityInput>
  }

  export type HealthWorkerUpdateManyWithWhereWithoutFacilityInput = {
    where: HealthWorkerScalarWhereInput
    data: XOR<HealthWorkerUpdateManyMutationInput, HealthWorkerUncheckedUpdateManyWithoutFacilityInput>
  }

  export type HealthWorkerScalarWhereInput = {
    AND?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
    OR?: HealthWorkerScalarWhereInput[]
    NOT?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
    id?: IntFilter<"HealthWorker"> | number
    facility_id?: StringFilter<"HealthWorker"> | string
    name?: StringFilter<"HealthWorker"> | string
    worker_type?: StringFilter<"HealthWorker"> | string
    allocated_amount?: DecimalFilter<"HealthWorker"> | Decimal | DecimalJsLike | number | string
    contact_number?: StringNullableFilter<"HealthWorker"> | string | null
    email?: StringNullableFilter<"HealthWorker"> | string | null
    is_active?: BoolFilter<"HealthWorker"> | boolean
    created_at?: DateTimeFilter<"HealthWorker"> | Date | string
    updated_at?: DateTimeFilter<"HealthWorker"> | Date | string
  }

  export type MonthlyHealthDataUpsertWithWhereUniqueWithoutFacilityInput = {
    where: MonthlyHealthDataWhereUniqueInput
    update: XOR<MonthlyHealthDataUpdateWithoutFacilityInput, MonthlyHealthDataUncheckedUpdateWithoutFacilityInput>
    create: XOR<MonthlyHealthDataCreateWithoutFacilityInput, MonthlyHealthDataUncheckedCreateWithoutFacilityInput>
  }

  export type MonthlyHealthDataUpdateWithWhereUniqueWithoutFacilityInput = {
    where: MonthlyHealthDataWhereUniqueInput
    data: XOR<MonthlyHealthDataUpdateWithoutFacilityInput, MonthlyHealthDataUncheckedUpdateWithoutFacilityInput>
  }

  export type MonthlyHealthDataUpdateManyWithWhereWithoutFacilityInput = {
    where: MonthlyHealthDataScalarWhereInput
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyWithoutFacilityInput>
  }

  export type PerformanceCalculationUpsertWithWhereUniqueWithoutFacilityInput = {
    where: PerformanceCalculationWhereUniqueInput
    update: XOR<PerformanceCalculationUpdateWithoutFacilityInput, PerformanceCalculationUncheckedUpdateWithoutFacilityInput>
    create: XOR<PerformanceCalculationCreateWithoutFacilityInput, PerformanceCalculationUncheckedCreateWithoutFacilityInput>
  }

  export type PerformanceCalculationUpdateWithWhereUniqueWithoutFacilityInput = {
    where: PerformanceCalculationWhereUniqueInput
    data: XOR<PerformanceCalculationUpdateWithoutFacilityInput, PerformanceCalculationUncheckedUpdateWithoutFacilityInput>
  }

  export type PerformanceCalculationUpdateManyWithWhereWithoutFacilityInput = {
    where: PerformanceCalculationScalarWhereInput
    data: XOR<PerformanceCalculationUpdateManyMutationInput, PerformanceCalculationUncheckedUpdateManyWithoutFacilityInput>
  }

  export type PerformanceCalculationScalarWhereInput = {
    AND?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
    OR?: PerformanceCalculationScalarWhereInput[]
    NOT?: PerformanceCalculationScalarWhereInput | PerformanceCalculationScalarWhereInput[]
    id?: IntFilter<"PerformanceCalculation"> | number
    sub_centre_id?: IntNullableFilter<"PerformanceCalculation"> | number | null
    indicator_id?: IntFilter<"PerformanceCalculation"> | number
    report_month?: StringFilter<"PerformanceCalculation"> | string
    numerator?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    denominator?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    achievement?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    target_value?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: DecimalNullableFilter<"PerformanceCalculation"> | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFilter<"PerformanceCalculation"> | Date | string
    facility_id?: StringNullableFilter<"PerformanceCalculation"> | string | null
  }

  export type RemunerationCalculationUpsertWithWhereUniqueWithoutFacilityInput = {
    where: RemunerationCalculationWhereUniqueInput
    update: XOR<RemunerationCalculationUpdateWithoutFacilityInput, RemunerationCalculationUncheckedUpdateWithoutFacilityInput>
    create: XOR<RemunerationCalculationCreateWithoutFacilityInput, RemunerationCalculationUncheckedCreateWithoutFacilityInput>
  }

  export type RemunerationCalculationUpdateWithWhereUniqueWithoutFacilityInput = {
    where: RemunerationCalculationWhereUniqueInput
    data: XOR<RemunerationCalculationUpdateWithoutFacilityInput, RemunerationCalculationUncheckedUpdateWithoutFacilityInput>
  }

  export type RemunerationCalculationUpdateManyWithWhereWithoutFacilityInput = {
    where: RemunerationCalculationScalarWhereInput
    data: XOR<RemunerationCalculationUpdateManyMutationInput, RemunerationCalculationUncheckedUpdateManyWithoutFacilityInput>
  }

  export type RemunerationCalculationScalarWhereInput = {
    AND?: RemunerationCalculationScalarWhereInput | RemunerationCalculationScalarWhereInput[]
    OR?: RemunerationCalculationScalarWhereInput[]
    NOT?: RemunerationCalculationScalarWhereInput | RemunerationCalculationScalarWhereInput[]
    id?: IntFilter<"RemunerationCalculation"> | number
    facility_id?: StringFilter<"RemunerationCalculation"> | string
    report_month?: StringFilter<"RemunerationCalculation"> | string
    performance_percentage?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFilter<"RemunerationCalculation"> | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFilter<"RemunerationCalculation"> | number
    asha_workers_count?: IntFilter<"RemunerationCalculation"> | number
    calculated_at?: DateTimeFilter<"RemunerationCalculation"> | Date | string
  }

  export type sub_centreUpsertWithWhereUniqueWithoutFacilityInput = {
    where: sub_centreWhereUniqueInput
    update: XOR<sub_centreUpdateWithoutFacilityInput, sub_centreUncheckedUpdateWithoutFacilityInput>
    create: XOR<sub_centreCreateWithoutFacilityInput, sub_centreUncheckedCreateWithoutFacilityInput>
  }

  export type sub_centreUpdateWithWhereUniqueWithoutFacilityInput = {
    where: sub_centreWhereUniqueInput
    data: XOR<sub_centreUpdateWithoutFacilityInput, sub_centreUncheckedUpdateWithoutFacilityInput>
  }

  export type sub_centreUpdateManyWithWhereWithoutFacilityInput = {
    where: sub_centreScalarWhereInput
    data: XOR<sub_centreUpdateManyMutationInput, sub_centreUncheckedUpdateManyWithoutFacilityInput>
  }

  export type sub_centreScalarWhereInput = {
    AND?: sub_centreScalarWhereInput | sub_centreScalarWhereInput[]
    OR?: sub_centreScalarWhereInput[]
    NOT?: sub_centreScalarWhereInput | sub_centreScalarWhereInput[]
    id?: IntFilter<"sub_centre"> | number
    name?: StringFilter<"sub_centre"> | string
    created_at?: DateTimeFilter<"sub_centre"> | Date | string
    updated_at?: DateTimeFilter<"sub_centre"> | Date | string
    facility_id?: StringFilter<"sub_centre"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutFacilityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFacilityInput, UserUncheckedUpdateWithoutFacilityInput>
    create: XOR<UserCreateWithoutFacilityInput, UserUncheckedCreateWithoutFacilityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFacilityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFacilityInput, UserUncheckedUpdateWithoutFacilityInput>
  }

  export type UserUpdateManyWithWhereWithoutFacilityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFacilityInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    is_active?: BoolNullableFilter<"User"> | boolean | null
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    email?: StringNullableFilter<"User"> | string | null
    facility_id?: StringNullableFilter<"User"> | string | null
  }

  export type UserCreateWithoutApproved_dataInput = {
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    upload_sessions?: DataUploadSessionCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueCreateNestedManyWithoutUploaderInput
    uploaded_data?: MonthlyHealthDataCreateNestedManyWithoutUploaderInput
    facility?: FacilityCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutApproved_dataInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    facility_id?: string | null
    upload_sessions?: DataUploadSessionUncheckedCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutUploaderInput
    uploaded_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutApproved_dataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApproved_dataInput, UserUncheckedCreateWithoutApproved_dataInput>
  }

  export type DistrictCreateWithoutMonthly_dataInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    facilities?: FacilityCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateWithoutMonthly_dataInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictCreateOrConnectWithoutMonthly_dataInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutMonthly_dataInput, DistrictUncheckedCreateWithoutMonthly_dataInput>
  }

  export type FacilityCreateWithoutMonthly_dataInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutMonthly_dataInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutMonthly_dataInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutMonthly_dataInput, FacilityUncheckedCreateWithoutMonthly_dataInput>
  }

  export type IndicatorCreateWithoutMonthly_dataInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutMonthly_dataInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutMonthly_dataInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutMonthly_dataInput, IndicatorUncheckedCreateWithoutMonthly_dataInput>
  }

  export type sub_centreCreateWithoutMonthly_health_dataInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutSub_centreInput
    facility: FacilityCreateNestedOneWithoutSub_centresInput
  }

  export type sub_centreUncheckedCreateWithoutMonthly_health_dataInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    facility_id: string
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutSub_centreInput
  }

  export type sub_centreCreateOrConnectWithoutMonthly_health_dataInput = {
    where: sub_centreWhereUniqueInput
    create: XOR<sub_centreCreateWithoutMonthly_health_dataInput, sub_centreUncheckedCreateWithoutMonthly_health_dataInput>
  }

  export type UserCreateWithoutUploaded_dataInput = {
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    upload_sessions?: DataUploadSessionCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataCreateNestedManyWithoutApproverInput
    facility?: FacilityCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUploaded_dataInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    facility_id?: string | null
    upload_sessions?: DataUploadSessionUncheckedCreateNestedManyWithoutUploaderInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutUploaded_dataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploaded_dataInput, UserUncheckedCreateWithoutUploaded_dataInput>
  }

  export type UserUpsertWithoutApproved_dataInput = {
    update: XOR<UserUpdateWithoutApproved_dataInput, UserUncheckedUpdateWithoutApproved_dataInput>
    create: XOR<UserCreateWithoutApproved_dataInput, UserUncheckedCreateWithoutApproved_dataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApproved_dataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApproved_dataInput, UserUncheckedUpdateWithoutApproved_dataInput>
  }

  export type UserUpdateWithoutApproved_dataInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUpdateManyWithoutUploaderNestedInput
    uploaded_data?: MonthlyHealthDataUpdateManyWithoutUploaderNestedInput
    facility?: FacilityUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutApproved_dataInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUncheckedUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutUploaderNestedInput
    uploaded_data?: MonthlyHealthDataUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type DistrictUpsertWithoutMonthly_dataInput = {
    update: XOR<DistrictUpdateWithoutMonthly_dataInput, DistrictUncheckedUpdateWithoutMonthly_dataInput>
    create: XOR<DistrictCreateWithoutMonthly_dataInput, DistrictUncheckedCreateWithoutMonthly_dataInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutMonthly_dataInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutMonthly_dataInput, DistrictUncheckedUpdateWithoutMonthly_dataInput>
  }

  export type DistrictUpdateWithoutMonthly_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateWithoutMonthly_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type FacilityUpsertWithoutMonthly_dataInput = {
    update: XOR<FacilityUpdateWithoutMonthly_dataInput, FacilityUncheckedUpdateWithoutMonthly_dataInput>
    create: XOR<FacilityCreateWithoutMonthly_dataInput, FacilityUncheckedCreateWithoutMonthly_dataInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutMonthly_dataInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutMonthly_dataInput, FacilityUncheckedUpdateWithoutMonthly_dataInput>
  }

  export type FacilityUpdateWithoutMonthly_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutMonthly_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type IndicatorUpsertWithoutMonthly_dataInput = {
    update: XOR<IndicatorUpdateWithoutMonthly_dataInput, IndicatorUncheckedUpdateWithoutMonthly_dataInput>
    create: XOR<IndicatorCreateWithoutMonthly_dataInput, IndicatorUncheckedCreateWithoutMonthly_dataInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutMonthly_dataInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutMonthly_dataInput, IndicatorUncheckedUpdateWithoutMonthly_dataInput>
  }

  export type IndicatorUpdateWithoutMonthly_dataInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutMonthly_dataInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type sub_centreUpsertWithoutMonthly_health_dataInput = {
    update: XOR<sub_centreUpdateWithoutMonthly_health_dataInput, sub_centreUncheckedUpdateWithoutMonthly_health_dataInput>
    create: XOR<sub_centreCreateWithoutMonthly_health_dataInput, sub_centreUncheckedCreateWithoutMonthly_health_dataInput>
    where?: sub_centreWhereInput
  }

  export type sub_centreUpdateToOneWithWhereWithoutMonthly_health_dataInput = {
    where?: sub_centreWhereInput
    data: XOR<sub_centreUpdateWithoutMonthly_health_dataInput, sub_centreUncheckedUpdateWithoutMonthly_health_dataInput>
  }

  export type sub_centreUpdateWithoutMonthly_health_dataInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    performance_calculations?: PerformanceCalculationUpdateManyWithoutSub_centreNestedInput
    facility?: FacilityUpdateOneRequiredWithoutSub_centresNestedInput
  }

  export type sub_centreUncheckedUpdateWithoutMonthly_health_dataInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutSub_centreNestedInput
  }

  export type UserUpsertWithoutUploaded_dataInput = {
    update: XOR<UserUpdateWithoutUploaded_dataInput, UserUncheckedUpdateWithoutUploaded_dataInput>
    create: XOR<UserCreateWithoutUploaded_dataInput, UserUncheckedCreateWithoutUploaded_dataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploaded_dataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploaded_dataInput, UserUncheckedUpdateWithoutUploaded_dataInput>
  }

  export type UserUpdateWithoutUploaded_dataInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUpdateManyWithoutApproverNestedInput
    facility?: FacilityUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUploaded_dataInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUncheckedUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutUpload_sessionsInput = {
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    field_values?: FieldValueCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataCreateNestedManyWithoutUploaderInput
    facility?: FacilityCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpload_sessionsInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    facility_id?: string | null
    field_values?: FieldValueUncheckedCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutUpload_sessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpload_sessionsInput, UserUncheckedCreateWithoutUpload_sessionsInput>
  }

  export type UserUpsertWithoutUpload_sessionsInput = {
    update: XOR<UserUpdateWithoutUpload_sessionsInput, UserUncheckedUpdateWithoutUpload_sessionsInput>
    create: XOR<UserCreateWithoutUpload_sessionsInput, UserUncheckedCreateWithoutUpload_sessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpload_sessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpload_sessionsInput, UserUncheckedUpdateWithoutUpload_sessionsInput>
  }

  export type UserUpdateWithoutUpload_sessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    field_values?: FieldValueUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUpdateManyWithoutUploaderNestedInput
    facility?: FacilityUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpload_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
    field_values?: FieldValueUncheckedUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUncheckedUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type FacilityTargetCreateWithoutIndicatorInput = {
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutFacility_targetsInput
  }

  export type FacilityTargetUncheckedCreateWithoutIndicatorInput = {
    id?: number
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityTargetCreateOrConnectWithoutIndicatorInput = {
    where: FacilityTargetWhereUniqueInput
    create: XOR<FacilityTargetCreateWithoutIndicatorInput, FacilityTargetUncheckedCreateWithoutIndicatorInput>
  }

  export type FacilityTargetCreateManyIndicatorInputEnvelope = {
    data: FacilityTargetCreateManyIndicatorInput | FacilityTargetCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type FieldCreateWithoutDenominator_for_indicatorsInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFieldInput
    field_values?: FieldValueCreateNestedManyWithoutFieldInput
    numerator_for_indicators?: IndicatorCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUncheckedCreateWithoutDenominator_for_indicatorsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFieldInput
    numerator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldCreateOrConnectWithoutDenominator_for_indicatorsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutDenominator_for_indicatorsInput, FieldUncheckedCreateWithoutDenominator_for_indicatorsInput>
  }

  export type FieldCreateWithoutNumerator_for_indicatorsInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFieldInput
    field_values?: FieldValueCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorCreateNestedManyWithoutDenominator_fieldInput
    target_for_indicators?: IndicatorCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUncheckedCreateWithoutNumerator_for_indicatorsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput
    target_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldCreateOrConnectWithoutNumerator_for_indicatorsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutNumerator_for_indicatorsInput, FieldUncheckedCreateWithoutNumerator_for_indicatorsInput>
  }

  export type FieldCreateWithoutTarget_for_indicatorsInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFieldInput
    field_values?: FieldValueCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorCreateNestedManyWithoutNumerator_fieldInput
  }

  export type FieldUncheckedCreateWithoutTarget_for_indicatorsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput
  }

  export type FieldCreateOrConnectWithoutTarget_for_indicatorsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutTarget_for_indicatorsInput, FieldUncheckedCreateWithoutTarget_for_indicatorsInput>
  }

  export type IndicatorRemunerationCreateWithoutIndicatorInput = {
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_remuneration: FacilityTypeRemunerationCreateNestedOneWithoutIndicator_remunerationsInput
    remuneration_system?: RemunerationSystemCreateNestedOneWithoutIndicator_remunerationsInput
  }

  export type IndicatorRemunerationUncheckedCreateWithoutIndicatorInput = {
    id?: number
    facility_type_remuneration_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_system_id?: string | null
  }

  export type IndicatorRemunerationCreateOrConnectWithoutIndicatorInput = {
    where: IndicatorRemunerationWhereUniqueInput
    create: XOR<IndicatorRemunerationCreateWithoutIndicatorInput, IndicatorRemunerationUncheckedCreateWithoutIndicatorInput>
  }

  export type IndicatorRemunerationCreateManyIndicatorInputEnvelope = {
    data: IndicatorRemunerationCreateManyIndicatorInput | IndicatorRemunerationCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorWorkerAllocationCreateWithoutIndicatorInput = {
    id?: string
    worker_type: string
    allocated_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput = {
    id?: string
    worker_type: string
    allocated_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IndicatorWorkerAllocationCreateOrConnectWithoutIndicatorInput = {
    where: IndicatorWorkerAllocationWhereUniqueInput
    create: XOR<IndicatorWorkerAllocationCreateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput>
  }

  export type IndicatorWorkerAllocationCreateManyIndicatorInputEnvelope = {
    data: IndicatorWorkerAllocationCreateManyIndicatorInput | IndicatorWorkerAllocationCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type MonthlyHealthDataCreateWithoutIndicatorInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    approver?: UserCreateNestedOneWithoutApproved_dataInput
    district: DistrictCreateNestedOneWithoutMonthly_dataInput
    facility?: FacilityCreateNestedOneWithoutMonthly_dataInput
    sub_centre?: sub_centreCreateNestedOneWithoutMonthly_health_dataInput
    uploader: UserCreateNestedOneWithoutUploaded_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateWithoutIndicatorInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateOrConnectWithoutIndicatorInput = {
    where: MonthlyHealthDataWhereUniqueInput
    create: XOR<MonthlyHealthDataCreateWithoutIndicatorInput, MonthlyHealthDataUncheckedCreateWithoutIndicatorInput>
  }

  export type MonthlyHealthDataCreateManyIndicatorInputEnvelope = {
    data: MonthlyHealthDataCreateManyIndicatorInput | MonthlyHealthDataCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceCalculationCreateWithoutIndicatorInput = {
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility?: FacilityCreateNestedOneWithoutPerformance_calculationsInput
    sub_centre?: sub_centreCreateNestedOneWithoutPerformance_calculationsInput
  }

  export type PerformanceCalculationUncheckedCreateWithoutIndicatorInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility_id?: string | null
  }

  export type PerformanceCalculationCreateOrConnectWithoutIndicatorInput = {
    where: PerformanceCalculationWhereUniqueInput
    create: XOR<PerformanceCalculationCreateWithoutIndicatorInput, PerformanceCalculationUncheckedCreateWithoutIndicatorInput>
  }

  export type PerformanceCalculationCreateManyIndicatorInputEnvelope = {
    data: PerformanceCalculationCreateManyIndicatorInput | PerformanceCalculationCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type FacilityTargetUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: FacilityTargetWhereUniqueInput
    update: XOR<FacilityTargetUpdateWithoutIndicatorInput, FacilityTargetUncheckedUpdateWithoutIndicatorInput>
    create: XOR<FacilityTargetCreateWithoutIndicatorInput, FacilityTargetUncheckedCreateWithoutIndicatorInput>
  }

  export type FacilityTargetUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: FacilityTargetWhereUniqueInput
    data: XOR<FacilityTargetUpdateWithoutIndicatorInput, FacilityTargetUncheckedUpdateWithoutIndicatorInput>
  }

  export type FacilityTargetUpdateManyWithWhereWithoutIndicatorInput = {
    where: FacilityTargetScalarWhereInput
    data: XOR<FacilityTargetUpdateManyMutationInput, FacilityTargetUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type FieldUpsertWithoutDenominator_for_indicatorsInput = {
    update: XOR<FieldUpdateWithoutDenominator_for_indicatorsInput, FieldUncheckedUpdateWithoutDenominator_for_indicatorsInput>
    create: XOR<FieldCreateWithoutDenominator_for_indicatorsInput, FieldUncheckedCreateWithoutDenominator_for_indicatorsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutDenominator_for_indicatorsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutDenominator_for_indicatorsInput, FieldUncheckedUpdateWithoutDenominator_for_indicatorsInput>
  }

  export type FieldUpdateWithoutDenominator_for_indicatorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUpdateManyWithoutFieldNestedInput
    numerator_for_indicators?: IndicatorUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutDenominator_for_indicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFieldNestedInput
    numerator_for_indicators?: IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUpsertWithoutNumerator_for_indicatorsInput = {
    update: XOR<FieldUpdateWithoutNumerator_for_indicatorsInput, FieldUncheckedUpdateWithoutNumerator_for_indicatorsInput>
    create: XOR<FieldCreateWithoutNumerator_for_indicatorsInput, FieldUncheckedCreateWithoutNumerator_for_indicatorsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutNumerator_for_indicatorsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutNumerator_for_indicatorsInput, FieldUncheckedUpdateWithoutNumerator_for_indicatorsInput>
  }

  export type FieldUpdateWithoutNumerator_for_indicatorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUpdateManyWithoutDenominator_fieldNestedInput
    target_for_indicators?: IndicatorUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutNumerator_for_indicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput
    target_for_indicators?: IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUpsertWithoutTarget_for_indicatorsInput = {
    update: XOR<FieldUpdateWithoutTarget_for_indicatorsInput, FieldUncheckedUpdateWithoutTarget_for_indicatorsInput>
    create: XOR<FieldCreateWithoutTarget_for_indicatorsInput, FieldUncheckedCreateWithoutTarget_for_indicatorsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutTarget_for_indicatorsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutTarget_for_indicatorsInput, FieldUncheckedUpdateWithoutTarget_for_indicatorsInput>
  }

  export type FieldUpdateWithoutTarget_for_indicatorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUpdateManyWithoutNumerator_fieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutTarget_for_indicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput
  }

  export type IndicatorRemunerationUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: IndicatorRemunerationWhereUniqueInput
    update: XOR<IndicatorRemunerationUpdateWithoutIndicatorInput, IndicatorRemunerationUncheckedUpdateWithoutIndicatorInput>
    create: XOR<IndicatorRemunerationCreateWithoutIndicatorInput, IndicatorRemunerationUncheckedCreateWithoutIndicatorInput>
  }

  export type IndicatorRemunerationUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: IndicatorRemunerationWhereUniqueInput
    data: XOR<IndicatorRemunerationUpdateWithoutIndicatorInput, IndicatorRemunerationUncheckedUpdateWithoutIndicatorInput>
  }

  export type IndicatorRemunerationUpdateManyWithWhereWithoutIndicatorInput = {
    where: IndicatorRemunerationScalarWhereInput
    data: XOR<IndicatorRemunerationUpdateManyMutationInput, IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type IndicatorWorkerAllocationUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: IndicatorWorkerAllocationWhereUniqueInput
    update: XOR<IndicatorWorkerAllocationUpdateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedUpdateWithoutIndicatorInput>
    create: XOR<IndicatorWorkerAllocationCreateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedCreateWithoutIndicatorInput>
  }

  export type IndicatorWorkerAllocationUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: IndicatorWorkerAllocationWhereUniqueInput
    data: XOR<IndicatorWorkerAllocationUpdateWithoutIndicatorInput, IndicatorWorkerAllocationUncheckedUpdateWithoutIndicatorInput>
  }

  export type IndicatorWorkerAllocationUpdateManyWithWhereWithoutIndicatorInput = {
    where: IndicatorWorkerAllocationScalarWhereInput
    data: XOR<IndicatorWorkerAllocationUpdateManyMutationInput, IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type IndicatorWorkerAllocationScalarWhereInput = {
    AND?: IndicatorWorkerAllocationScalarWhereInput | IndicatorWorkerAllocationScalarWhereInput[]
    OR?: IndicatorWorkerAllocationScalarWhereInput[]
    NOT?: IndicatorWorkerAllocationScalarWhereInput | IndicatorWorkerAllocationScalarWhereInput[]
    id?: StringFilter<"IndicatorWorkerAllocation"> | string
    indicator_id?: IntFilter<"IndicatorWorkerAllocation"> | number
    worker_type?: StringFilter<"IndicatorWorkerAllocation"> | string
    allocated_amount?: IntFilter<"IndicatorWorkerAllocation"> | number
    created_at?: DateTimeFilter<"IndicatorWorkerAllocation"> | Date | string
    updated_at?: DateTimeFilter<"IndicatorWorkerAllocation"> | Date | string
  }

  export type MonthlyHealthDataUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: MonthlyHealthDataWhereUniqueInput
    update: XOR<MonthlyHealthDataUpdateWithoutIndicatorInput, MonthlyHealthDataUncheckedUpdateWithoutIndicatorInput>
    create: XOR<MonthlyHealthDataCreateWithoutIndicatorInput, MonthlyHealthDataUncheckedCreateWithoutIndicatorInput>
  }

  export type MonthlyHealthDataUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: MonthlyHealthDataWhereUniqueInput
    data: XOR<MonthlyHealthDataUpdateWithoutIndicatorInput, MonthlyHealthDataUncheckedUpdateWithoutIndicatorInput>
  }

  export type MonthlyHealthDataUpdateManyWithWhereWithoutIndicatorInput = {
    where: MonthlyHealthDataScalarWhereInput
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type PerformanceCalculationUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: PerformanceCalculationWhereUniqueInput
    update: XOR<PerformanceCalculationUpdateWithoutIndicatorInput, PerformanceCalculationUncheckedUpdateWithoutIndicatorInput>
    create: XOR<PerformanceCalculationCreateWithoutIndicatorInput, PerformanceCalculationUncheckedCreateWithoutIndicatorInput>
  }

  export type PerformanceCalculationUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: PerformanceCalculationWhereUniqueInput
    data: XOR<PerformanceCalculationUpdateWithoutIndicatorInput, PerformanceCalculationUncheckedUpdateWithoutIndicatorInput>
  }

  export type PerformanceCalculationUpdateManyWithWhereWithoutIndicatorInput = {
    where: PerformanceCalculationScalarWhereInput
    data: XOR<PerformanceCalculationUpdateManyMutationInput, PerformanceCalculationUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type FacilityFieldDefaultsCreateWithoutFieldInput = {
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutFacility_field_defaultsInput
  }

  export type FacilityFieldDefaultsUncheckedCreateWithoutFieldInput = {
    id?: number
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityFieldDefaultsCreateOrConnectWithoutFieldInput = {
    where: FacilityFieldDefaultsWhereUniqueInput
    create: XOR<FacilityFieldDefaultsCreateWithoutFieldInput, FacilityFieldDefaultsUncheckedCreateWithoutFieldInput>
  }

  export type FacilityFieldDefaultsCreateManyFieldInputEnvelope = {
    data: FacilityFieldDefaultsCreateManyFieldInput | FacilityFieldDefaultsCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type FacilityFieldMappingCreateWithoutFieldInput = {
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    facility_type: FacilityTypeCreateNestedOneWithoutField_mappingsInput
  }

  export type FacilityFieldMappingUncheckedCreateWithoutFieldInput = {
    id?: number
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
  }

  export type FacilityFieldMappingCreateOrConnectWithoutFieldInput = {
    where: FacilityFieldMappingWhereUniqueInput
    create: XOR<FacilityFieldMappingCreateWithoutFieldInput, FacilityFieldMappingUncheckedCreateWithoutFieldInput>
  }

  export type FacilityFieldMappingCreateManyFieldInputEnvelope = {
    data: FacilityFieldMappingCreateManyFieldInput | FacilityFieldMappingCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type FieldValueCreateWithoutFieldInput = {
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility?: FacilityCreateNestedOneWithoutField_valuesInput
    uploader: UserCreateNestedOneWithoutField_valuesInput
  }

  export type FieldValueUncheckedCreateWithoutFieldInput = {
    id?: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility_id?: string | null
  }

  export type FieldValueCreateOrConnectWithoutFieldInput = {
    where: FieldValueWhereUniqueInput
    create: XOR<FieldValueCreateWithoutFieldInput, FieldValueUncheckedCreateWithoutFieldInput>
  }

  export type FieldValueCreateManyFieldInputEnvelope = {
    data: FieldValueCreateManyFieldInput | FieldValueCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorCreateWithoutDenominator_fieldInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutDenominator_fieldInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutDenominator_fieldInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutDenominator_fieldInput, IndicatorUncheckedCreateWithoutDenominator_fieldInput>
  }

  export type IndicatorCreateManyDenominator_fieldInputEnvelope = {
    data: IndicatorCreateManyDenominator_fieldInput | IndicatorCreateManyDenominator_fieldInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorCreateWithoutNumerator_fieldInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutNumerator_fieldInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutNumerator_fieldInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutNumerator_fieldInput, IndicatorUncheckedCreateWithoutNumerator_fieldInput>
  }

  export type IndicatorCreateManyNumerator_fieldInputEnvelope = {
    data: IndicatorCreateManyNumerator_fieldInput | IndicatorCreateManyNumerator_fieldInput[]
    skipDuplicates?: boolean
  }

  export type IndicatorCreateWithoutTarget_fieldInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutTarget_fieldInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutTarget_fieldInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutTarget_fieldInput, IndicatorUncheckedCreateWithoutTarget_fieldInput>
  }

  export type IndicatorCreateManyTarget_fieldInputEnvelope = {
    data: IndicatorCreateManyTarget_fieldInput | IndicatorCreateManyTarget_fieldInput[]
    skipDuplicates?: boolean
  }

  export type FacilityFieldDefaultsUpsertWithWhereUniqueWithoutFieldInput = {
    where: FacilityFieldDefaultsWhereUniqueInput
    update: XOR<FacilityFieldDefaultsUpdateWithoutFieldInput, FacilityFieldDefaultsUncheckedUpdateWithoutFieldInput>
    create: XOR<FacilityFieldDefaultsCreateWithoutFieldInput, FacilityFieldDefaultsUncheckedCreateWithoutFieldInput>
  }

  export type FacilityFieldDefaultsUpdateWithWhereUniqueWithoutFieldInput = {
    where: FacilityFieldDefaultsWhereUniqueInput
    data: XOR<FacilityFieldDefaultsUpdateWithoutFieldInput, FacilityFieldDefaultsUncheckedUpdateWithoutFieldInput>
  }

  export type FacilityFieldDefaultsUpdateManyWithWhereWithoutFieldInput = {
    where: FacilityFieldDefaultsScalarWhereInput
    data: XOR<FacilityFieldDefaultsUpdateManyMutationInput, FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldInput>
  }

  export type FacilityFieldMappingUpsertWithWhereUniqueWithoutFieldInput = {
    where: FacilityFieldMappingWhereUniqueInput
    update: XOR<FacilityFieldMappingUpdateWithoutFieldInput, FacilityFieldMappingUncheckedUpdateWithoutFieldInput>
    create: XOR<FacilityFieldMappingCreateWithoutFieldInput, FacilityFieldMappingUncheckedCreateWithoutFieldInput>
  }

  export type FacilityFieldMappingUpdateWithWhereUniqueWithoutFieldInput = {
    where: FacilityFieldMappingWhereUniqueInput
    data: XOR<FacilityFieldMappingUpdateWithoutFieldInput, FacilityFieldMappingUncheckedUpdateWithoutFieldInput>
  }

  export type FacilityFieldMappingUpdateManyWithWhereWithoutFieldInput = {
    where: FacilityFieldMappingScalarWhereInput
    data: XOR<FacilityFieldMappingUpdateManyMutationInput, FacilityFieldMappingUncheckedUpdateManyWithoutFieldInput>
  }

  export type FieldValueUpsertWithWhereUniqueWithoutFieldInput = {
    where: FieldValueWhereUniqueInput
    update: XOR<FieldValueUpdateWithoutFieldInput, FieldValueUncheckedUpdateWithoutFieldInput>
    create: XOR<FieldValueCreateWithoutFieldInput, FieldValueUncheckedCreateWithoutFieldInput>
  }

  export type FieldValueUpdateWithWhereUniqueWithoutFieldInput = {
    where: FieldValueWhereUniqueInput
    data: XOR<FieldValueUpdateWithoutFieldInput, FieldValueUncheckedUpdateWithoutFieldInput>
  }

  export type FieldValueUpdateManyWithWhereWithoutFieldInput = {
    where: FieldValueScalarWhereInput
    data: XOR<FieldValueUpdateManyMutationInput, FieldValueUncheckedUpdateManyWithoutFieldInput>
  }

  export type IndicatorUpsertWithWhereUniqueWithoutDenominator_fieldInput = {
    where: IndicatorWhereUniqueInput
    update: XOR<IndicatorUpdateWithoutDenominator_fieldInput, IndicatorUncheckedUpdateWithoutDenominator_fieldInput>
    create: XOR<IndicatorCreateWithoutDenominator_fieldInput, IndicatorUncheckedCreateWithoutDenominator_fieldInput>
  }

  export type IndicatorUpdateWithWhereUniqueWithoutDenominator_fieldInput = {
    where: IndicatorWhereUniqueInput
    data: XOR<IndicatorUpdateWithoutDenominator_fieldInput, IndicatorUncheckedUpdateWithoutDenominator_fieldInput>
  }

  export type IndicatorUpdateManyWithWhereWithoutDenominator_fieldInput = {
    where: IndicatorScalarWhereInput
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyWithoutDenominator_fieldInput>
  }

  export type IndicatorScalarWhereInput = {
    AND?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
    OR?: IndicatorScalarWhereInput[]
    NOT?: IndicatorScalarWhereInput | IndicatorScalarWhereInput[]
    id?: IntFilter<"Indicator"> | number
    name?: StringFilter<"Indicator"> | string
    description?: StringNullableFilter<"Indicator"> | string | null
    type?: StringFilter<"Indicator"> | string
    structure?: JsonNullableFilter<"Indicator">
    created_at?: DateTimeFilter<"Indicator"> | Date | string
    updated_at?: DateTimeFilter<"Indicator"> | Date | string
    code?: StringFilter<"Indicator"> | string
    applicable_facility_types?: JsonNullableFilter<"Indicator">
    conditions?: StringNullableFilter<"Indicator"> | string | null
    denominator_field_id?: IntNullableFilter<"Indicator"> | number | null
    denominator_label?: StringNullableFilter<"Indicator"> | string | null
    formula_config?: JsonNullableFilter<"Indicator">
    numerator_field_id?: IntNullableFilter<"Indicator"> | number | null
    numerator_label?: StringNullableFilter<"Indicator"> | string | null
    target_formula?: StringNullableFilter<"Indicator"> | string | null
    target_type?: EnumTargetTypeFilter<"Indicator"> | $Enums.TargetType
    target_value?: StringNullableFilter<"Indicator"> | string | null
    target_field_id?: IntNullableFilter<"Indicator"> | number | null
    source_of_verification?: StringNullableFilter<"Indicator"> | string | null
  }

  export type IndicatorUpsertWithWhereUniqueWithoutNumerator_fieldInput = {
    where: IndicatorWhereUniqueInput
    update: XOR<IndicatorUpdateWithoutNumerator_fieldInput, IndicatorUncheckedUpdateWithoutNumerator_fieldInput>
    create: XOR<IndicatorCreateWithoutNumerator_fieldInput, IndicatorUncheckedCreateWithoutNumerator_fieldInput>
  }

  export type IndicatorUpdateWithWhereUniqueWithoutNumerator_fieldInput = {
    where: IndicatorWhereUniqueInput
    data: XOR<IndicatorUpdateWithoutNumerator_fieldInput, IndicatorUncheckedUpdateWithoutNumerator_fieldInput>
  }

  export type IndicatorUpdateManyWithWhereWithoutNumerator_fieldInput = {
    where: IndicatorScalarWhereInput
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyWithoutNumerator_fieldInput>
  }

  export type IndicatorUpsertWithWhereUniqueWithoutTarget_fieldInput = {
    where: IndicatorWhereUniqueInput
    update: XOR<IndicatorUpdateWithoutTarget_fieldInput, IndicatorUncheckedUpdateWithoutTarget_fieldInput>
    create: XOR<IndicatorCreateWithoutTarget_fieldInput, IndicatorUncheckedCreateWithoutTarget_fieldInput>
  }

  export type IndicatorUpdateWithWhereUniqueWithoutTarget_fieldInput = {
    where: IndicatorWhereUniqueInput
    data: XOR<IndicatorUpdateWithoutTarget_fieldInput, IndicatorUncheckedUpdateWithoutTarget_fieldInput>
  }

  export type IndicatorUpdateManyWithWhereWithoutTarget_fieldInput = {
    where: IndicatorScalarWhereInput
    data: XOR<IndicatorUpdateManyMutationInput, IndicatorUncheckedUpdateManyWithoutTarget_fieldInput>
  }

  export type FacilityCreateWithoutField_valuesInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutField_valuesInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutField_valuesInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutField_valuesInput, FacilityUncheckedCreateWithoutField_valuesInput>
  }

  export type FieldCreateWithoutField_valuesInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUncheckedCreateWithoutField_valuesInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput
    facility_field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldCreateOrConnectWithoutField_valuesInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutField_valuesInput, FieldUncheckedCreateWithoutField_valuesInput>
  }

  export type UserCreateWithoutField_valuesInput = {
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    upload_sessions?: DataUploadSessionCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataCreateNestedManyWithoutUploaderInput
    facility?: FacilityCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutField_valuesInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
    facility_id?: string | null
    upload_sessions?: DataUploadSessionUncheckedCreateNestedManyWithoutUploaderInput
    approved_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutApproverInput
    uploaded_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutField_valuesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutField_valuesInput, UserUncheckedCreateWithoutField_valuesInput>
  }

  export type FacilityUpsertWithoutField_valuesInput = {
    update: XOR<FacilityUpdateWithoutField_valuesInput, FacilityUncheckedUpdateWithoutField_valuesInput>
    create: XOR<FacilityCreateWithoutField_valuesInput, FacilityUncheckedCreateWithoutField_valuesInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutField_valuesInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutField_valuesInput, FacilityUncheckedUpdateWithoutField_valuesInput>
  }

  export type FacilityUpdateWithoutField_valuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutField_valuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FieldUpsertWithoutField_valuesInput = {
    update: XOR<FieldUpdateWithoutField_valuesInput, FieldUncheckedUpdateWithoutField_valuesInput>
    create: XOR<FieldCreateWithoutField_valuesInput, FieldUncheckedCreateWithoutField_valuesInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutField_valuesInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutField_valuesInput, FieldUncheckedUpdateWithoutField_valuesInput>
  }

  export type FieldUpdateWithoutField_valuesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutField_valuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput
    facility_field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput
  }

  export type UserUpsertWithoutField_valuesInput = {
    update: XOR<UserUpdateWithoutField_valuesInput, UserUncheckedUpdateWithoutField_valuesInput>
    create: XOR<UserCreateWithoutField_valuesInput, UserUncheckedCreateWithoutField_valuesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutField_valuesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutField_valuesInput, UserUncheckedUpdateWithoutField_valuesInput>
  }

  export type UserUpdateWithoutField_valuesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUpdateManyWithoutUploaderNestedInput
    facility?: FacilityUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutField_valuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUncheckedUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUncheckedUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type FacilityCreateWithoutFacility_field_defaultsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutFacility_field_defaultsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutFacility_field_defaultsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutFacility_field_defaultsInput, FacilityUncheckedCreateWithoutFacility_field_defaultsInput>
  }

  export type FieldCreateWithoutFacility_field_defaultsInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFieldInput
    field_values?: FieldValueCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUncheckedCreateWithoutFacility_field_defaultsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFieldInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldCreateOrConnectWithoutFacility_field_defaultsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFacility_field_defaultsInput, FieldUncheckedCreateWithoutFacility_field_defaultsInput>
  }

  export type FacilityUpsertWithoutFacility_field_defaultsInput = {
    update: XOR<FacilityUpdateWithoutFacility_field_defaultsInput, FacilityUncheckedUpdateWithoutFacility_field_defaultsInput>
    create: XOR<FacilityCreateWithoutFacility_field_defaultsInput, FacilityUncheckedCreateWithoutFacility_field_defaultsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutFacility_field_defaultsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutFacility_field_defaultsInput, FacilityUncheckedUpdateWithoutFacility_field_defaultsInput>
  }

  export type FacilityUpdateWithoutFacility_field_defaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutFacility_field_defaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FieldUpsertWithoutFacility_field_defaultsInput = {
    update: XOR<FieldUpdateWithoutFacility_field_defaultsInput, FieldUncheckedUpdateWithoutFacility_field_defaultsInput>
    create: XOR<FieldCreateWithoutFacility_field_defaultsInput, FieldUncheckedCreateWithoutFacility_field_defaultsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFacility_field_defaultsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFacility_field_defaultsInput, FieldUncheckedUpdateWithoutFacility_field_defaultsInput>
  }

  export type FieldUpdateWithoutFacility_field_defaultsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_mappings?: FacilityFieldMappingUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFacility_field_defaultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FacilityTypeCreateWithoutField_mappingsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationCreateNestedOneWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeUncheckedCreateWithoutField_mappingsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationUncheckedCreateNestedOneWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigUncheckedCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeCreateOrConnectWithoutField_mappingsInput = {
    where: FacilityTypeWhereUniqueInput
    create: XOR<FacilityTypeCreateWithoutField_mappingsInput, FacilityTypeUncheckedCreateWithoutField_mappingsInput>
  }

  export type FieldCreateWithoutFacility_field_mappingsInput = {
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFieldInput
    field_values?: FieldValueCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldUncheckedCreateWithoutFacility_field_mappingsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    calculation_formula?: string | null
    default_value?: string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type: $Enums.FieldType
    is_active?: boolean
    sort_order?: number
    user_type: $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFieldInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFieldInput
    denominator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutDenominator_fieldInput
    numerator_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutNumerator_fieldInput
    target_for_indicators?: IndicatorUncheckedCreateNestedManyWithoutTarget_fieldInput
  }

  export type FieldCreateOrConnectWithoutFacility_field_mappingsInput = {
    where: FieldWhereUniqueInput
    create: XOR<FieldCreateWithoutFacility_field_mappingsInput, FieldUncheckedCreateWithoutFacility_field_mappingsInput>
  }

  export type FacilityTypeUpsertWithoutField_mappingsInput = {
    update: XOR<FacilityTypeUpdateWithoutField_mappingsInput, FacilityTypeUncheckedUpdateWithoutField_mappingsInput>
    create: XOR<FacilityTypeCreateWithoutField_mappingsInput, FacilityTypeUncheckedCreateWithoutField_mappingsInput>
    where?: FacilityTypeWhereInput
  }

  export type FacilityTypeUpdateToOneWithWhereWithoutField_mappingsInput = {
    where?: FacilityTypeWhereInput
    data: XOR<FacilityTypeUpdateWithoutField_mappingsInput, FacilityTypeUncheckedUpdateWithoutField_mappingsInput>
  }

  export type FacilityTypeUpdateWithoutField_mappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUpdateOneWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUpdateManyWithoutFacility_typeNestedInput
  }

  export type FacilityTypeUncheckedUpdateWithoutField_mappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUncheckedUpdateOneWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeNestedInput
  }

  export type FieldUpsertWithoutFacility_field_mappingsInput = {
    update: XOR<FieldUpdateWithoutFacility_field_mappingsInput, FieldUncheckedUpdateWithoutFacility_field_mappingsInput>
    create: XOR<FieldCreateWithoutFacility_field_mappingsInput, FieldUncheckedCreateWithoutFacility_field_mappingsInput>
    where?: FieldWhereInput
  }

  export type FieldUpdateToOneWithWhereWithoutFacility_field_mappingsInput = {
    where?: FieldWhereInput
    data: XOR<FieldUpdateWithoutFacility_field_mappingsInput, FieldUncheckedUpdateWithoutFacility_field_mappingsInput>
  }

  export type FieldUpdateWithoutFacility_field_mappingsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUpdateManyWithoutTarget_fieldNestedInput
  }

  export type FieldUncheckedUpdateWithoutFacility_field_mappingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_formula?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    facility_type_targets?: NullableJsonNullValueInput | InputJsonValue
    field_type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    is_active?: BoolFieldUpdateOperationsInput | boolean
    sort_order?: IntFieldUpdateOperationsInput | number
    user_type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    validation_rules?: NullableJsonNullValueInput | InputJsonValue
    field_category?: EnumFieldCategoryFieldUpdateOperationsInput | $Enums.FieldCategory
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFieldNestedInput
    denominator_for_indicators?: IndicatorUncheckedUpdateManyWithoutDenominator_fieldNestedInput
    numerator_for_indicators?: IndicatorUncheckedUpdateManyWithoutNumerator_fieldNestedInput
    target_for_indicators?: IndicatorUncheckedUpdateManyWithoutTarget_fieldNestedInput
  }

  export type MonthlyHealthDataCreateWithoutSub_centreInput = {
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    approver?: UserCreateNestedOneWithoutApproved_dataInput
    district: DistrictCreateNestedOneWithoutMonthly_dataInput
    facility?: FacilityCreateNestedOneWithoutMonthly_dataInput
    indicator?: IndicatorCreateNestedOneWithoutMonthly_dataInput
    uploader: UserCreateNestedOneWithoutUploaded_dataInput
  }

  export type MonthlyHealthDataUncheckedCreateWithoutSub_centreInput = {
    id?: number
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateOrConnectWithoutSub_centreInput = {
    where: MonthlyHealthDataWhereUniqueInput
    create: XOR<MonthlyHealthDataCreateWithoutSub_centreInput, MonthlyHealthDataUncheckedCreateWithoutSub_centreInput>
  }

  export type MonthlyHealthDataCreateManySub_centreInputEnvelope = {
    data: MonthlyHealthDataCreateManySub_centreInput | MonthlyHealthDataCreateManySub_centreInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceCalculationCreateWithoutSub_centreInput = {
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility?: FacilityCreateNestedOneWithoutPerformance_calculationsInput
    indicator: IndicatorCreateNestedOneWithoutPerformance_calculationsInput
  }

  export type PerformanceCalculationUncheckedCreateWithoutSub_centreInput = {
    id?: number
    indicator_id: number
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility_id?: string | null
  }

  export type PerformanceCalculationCreateOrConnectWithoutSub_centreInput = {
    where: PerformanceCalculationWhereUniqueInput
    create: XOR<PerformanceCalculationCreateWithoutSub_centreInput, PerformanceCalculationUncheckedCreateWithoutSub_centreInput>
  }

  export type PerformanceCalculationCreateManySub_centreInputEnvelope = {
    data: PerformanceCalculationCreateManySub_centreInput | PerformanceCalculationCreateManySub_centreInput[]
    skipDuplicates?: boolean
  }

  export type FacilityCreateWithoutSub_centresInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutSub_centresInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutSub_centresInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutSub_centresInput, FacilityUncheckedCreateWithoutSub_centresInput>
  }

  export type MonthlyHealthDataUpsertWithWhereUniqueWithoutSub_centreInput = {
    where: MonthlyHealthDataWhereUniqueInput
    update: XOR<MonthlyHealthDataUpdateWithoutSub_centreInput, MonthlyHealthDataUncheckedUpdateWithoutSub_centreInput>
    create: XOR<MonthlyHealthDataCreateWithoutSub_centreInput, MonthlyHealthDataUncheckedCreateWithoutSub_centreInput>
  }

  export type MonthlyHealthDataUpdateWithWhereUniqueWithoutSub_centreInput = {
    where: MonthlyHealthDataWhereUniqueInput
    data: XOR<MonthlyHealthDataUpdateWithoutSub_centreInput, MonthlyHealthDataUncheckedUpdateWithoutSub_centreInput>
  }

  export type MonthlyHealthDataUpdateManyWithWhereWithoutSub_centreInput = {
    where: MonthlyHealthDataScalarWhereInput
    data: XOR<MonthlyHealthDataUpdateManyMutationInput, MonthlyHealthDataUncheckedUpdateManyWithoutSub_centreInput>
  }

  export type PerformanceCalculationUpsertWithWhereUniqueWithoutSub_centreInput = {
    where: PerformanceCalculationWhereUniqueInput
    update: XOR<PerformanceCalculationUpdateWithoutSub_centreInput, PerformanceCalculationUncheckedUpdateWithoutSub_centreInput>
    create: XOR<PerformanceCalculationCreateWithoutSub_centreInput, PerformanceCalculationUncheckedCreateWithoutSub_centreInput>
  }

  export type PerformanceCalculationUpdateWithWhereUniqueWithoutSub_centreInput = {
    where: PerformanceCalculationWhereUniqueInput
    data: XOR<PerformanceCalculationUpdateWithoutSub_centreInput, PerformanceCalculationUncheckedUpdateWithoutSub_centreInput>
  }

  export type PerformanceCalculationUpdateManyWithWhereWithoutSub_centreInput = {
    where: PerformanceCalculationScalarWhereInput
    data: XOR<PerformanceCalculationUpdateManyMutationInput, PerformanceCalculationUncheckedUpdateManyWithoutSub_centreInput>
  }

  export type FacilityUpsertWithoutSub_centresInput = {
    update: XOR<FacilityUpdateWithoutSub_centresInput, FacilityUncheckedUpdateWithoutSub_centresInput>
    create: XOR<FacilityCreateWithoutSub_centresInput, FacilityUncheckedCreateWithoutSub_centresInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutSub_centresInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutSub_centresInput, FacilityUncheckedUpdateWithoutSub_centresInput>
  }

  export type FacilityUpdateWithoutSub_centresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutSub_centresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateWithoutHealth_workersInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutHealth_workersInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutHealth_workersInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutHealth_workersInput, FacilityUncheckedCreateWithoutHealth_workersInput>
  }

  export type WorkerRemunerationCreateWithoutHealth_workerInput = {
    report_month: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    performance_percentage: Decimal | DecimalJsLike | number | string
    calculated_amount: Decimal | DecimalJsLike | number | string
    calculated_at?: Date | string
  }

  export type WorkerRemunerationUncheckedCreateWithoutHealth_workerInput = {
    id?: number
    report_month: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    performance_percentage: Decimal | DecimalJsLike | number | string
    calculated_amount: Decimal | DecimalJsLike | number | string
    calculated_at?: Date | string
  }

  export type WorkerRemunerationCreateOrConnectWithoutHealth_workerInput = {
    where: WorkerRemunerationWhereUniqueInput
    create: XOR<WorkerRemunerationCreateWithoutHealth_workerInput, WorkerRemunerationUncheckedCreateWithoutHealth_workerInput>
  }

  export type WorkerRemunerationCreateManyHealth_workerInputEnvelope = {
    data: WorkerRemunerationCreateManyHealth_workerInput | WorkerRemunerationCreateManyHealth_workerInput[]
    skipDuplicates?: boolean
  }

  export type FacilityUpsertWithoutHealth_workersInput = {
    update: XOR<FacilityUpdateWithoutHealth_workersInput, FacilityUncheckedUpdateWithoutHealth_workersInput>
    create: XOR<FacilityCreateWithoutHealth_workersInput, FacilityUncheckedCreateWithoutHealth_workersInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutHealth_workersInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutHealth_workersInput, FacilityUncheckedUpdateWithoutHealth_workersInput>
  }

  export type FacilityUpdateWithoutHealth_workersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutHealth_workersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type WorkerRemunerationUpsertWithWhereUniqueWithoutHealth_workerInput = {
    where: WorkerRemunerationWhereUniqueInput
    update: XOR<WorkerRemunerationUpdateWithoutHealth_workerInput, WorkerRemunerationUncheckedUpdateWithoutHealth_workerInput>
    create: XOR<WorkerRemunerationCreateWithoutHealth_workerInput, WorkerRemunerationUncheckedCreateWithoutHealth_workerInput>
  }

  export type WorkerRemunerationUpdateWithWhereUniqueWithoutHealth_workerInput = {
    where: WorkerRemunerationWhereUniqueInput
    data: XOR<WorkerRemunerationUpdateWithoutHealth_workerInput, WorkerRemunerationUncheckedUpdateWithoutHealth_workerInput>
  }

  export type WorkerRemunerationUpdateManyWithWhereWithoutHealth_workerInput = {
    where: WorkerRemunerationScalarWhereInput
    data: XOR<WorkerRemunerationUpdateManyMutationInput, WorkerRemunerationUncheckedUpdateManyWithoutHealth_workerInput>
  }

  export type WorkerRemunerationScalarWhereInput = {
    AND?: WorkerRemunerationScalarWhereInput | WorkerRemunerationScalarWhereInput[]
    OR?: WorkerRemunerationScalarWhereInput[]
    NOT?: WorkerRemunerationScalarWhereInput | WorkerRemunerationScalarWhereInput[]
    id?: IntFilter<"WorkerRemuneration"> | number
    health_worker_id?: IntFilter<"WorkerRemuneration"> | number
    report_month?: StringFilter<"WorkerRemuneration"> | string
    allocated_amount?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFilter<"WorkerRemuneration"> | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFilter<"WorkerRemuneration"> | Date | string
  }

  export type FacilityCreateWithoutRemuneration_calculationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutRemuneration_calculationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutRemuneration_calculationsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutRemuneration_calculationsInput, FacilityUncheckedCreateWithoutRemuneration_calculationsInput>
  }

  export type FacilityUpsertWithoutRemuneration_calculationsInput = {
    update: XOR<FacilityUpdateWithoutRemuneration_calculationsInput, FacilityUncheckedUpdateWithoutRemuneration_calculationsInput>
    create: XOR<FacilityCreateWithoutRemuneration_calculationsInput, FacilityUncheckedCreateWithoutRemuneration_calculationsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutRemuneration_calculationsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutRemuneration_calculationsInput, FacilityUncheckedUpdateWithoutRemuneration_calculationsInput>
  }

  export type FacilityUpdateWithoutRemuneration_calculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutRemuneration_calculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type HealthWorkerCreateWithoutRemuneration_calculationsInput = {
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutHealth_workersInput
  }

  export type HealthWorkerUncheckedCreateWithoutRemuneration_calculationsInput = {
    id?: number
    facility_id: string
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type HealthWorkerCreateOrConnectWithoutRemuneration_calculationsInput = {
    where: HealthWorkerWhereUniqueInput
    create: XOR<HealthWorkerCreateWithoutRemuneration_calculationsInput, HealthWorkerUncheckedCreateWithoutRemuneration_calculationsInput>
  }

  export type HealthWorkerUpsertWithoutRemuneration_calculationsInput = {
    update: XOR<HealthWorkerUpdateWithoutRemuneration_calculationsInput, HealthWorkerUncheckedUpdateWithoutRemuneration_calculationsInput>
    create: XOR<HealthWorkerCreateWithoutRemuneration_calculationsInput, HealthWorkerUncheckedCreateWithoutRemuneration_calculationsInput>
    where?: HealthWorkerWhereInput
  }

  export type HealthWorkerUpdateToOneWithWhereWithoutRemuneration_calculationsInput = {
    where?: HealthWorkerWhereInput
    data: XOR<HealthWorkerUpdateWithoutRemuneration_calculationsInput, HealthWorkerUncheckedUpdateWithoutRemuneration_calculationsInput>
  }

  export type HealthWorkerUpdateWithoutRemuneration_calculationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutHealth_workersNestedInput
  }

  export type HealthWorkerUncheckedUpdateWithoutRemuneration_calculationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput = {
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility: FacilityCreateNestedOneWithoutWorker_allocationsInput
  }

  export type FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput = {
    id?: number
    facility_id: string
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityWorkerAllocationCreateOrConnectWithoutWorker_allocation_configInput = {
    where: FacilityWorkerAllocationWhereUniqueInput
    create: XOR<FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput>
  }

  export type FacilityWorkerAllocationCreateManyWorker_allocation_configInputEnvelope = {
    data: FacilityWorkerAllocationCreateManyWorker_allocation_configInput | FacilityWorkerAllocationCreateManyWorker_allocation_configInput[]
    skipDuplicates?: boolean
  }

  export type FacilityTypeCreateWithoutWorker_allocationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityCreateNestedManyWithoutFacility_typeInput
    field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationCreateNestedOneWithoutFacility_typeInput
  }

  export type FacilityTypeUncheckedCreateWithoutWorker_allocationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutFacility_typeInput
    field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFacility_typeInput
    remunerations?: FacilityTypeRemunerationUncheckedCreateNestedOneWithoutFacility_typeInput
  }

  export type FacilityTypeCreateOrConnectWithoutWorker_allocationsInput = {
    where: FacilityTypeWhereUniqueInput
    create: XOR<FacilityTypeCreateWithoutWorker_allocationsInput, FacilityTypeUncheckedCreateWithoutWorker_allocationsInput>
  }

  export type FacilityWorkerAllocationUpsertWithWhereUniqueWithoutWorker_allocation_configInput = {
    where: FacilityWorkerAllocationWhereUniqueInput
    update: XOR<FacilityWorkerAllocationUpdateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedUpdateWithoutWorker_allocation_configInput>
    create: XOR<FacilityWorkerAllocationCreateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedCreateWithoutWorker_allocation_configInput>
  }

  export type FacilityWorkerAllocationUpdateWithWhereUniqueWithoutWorker_allocation_configInput = {
    where: FacilityWorkerAllocationWhereUniqueInput
    data: XOR<FacilityWorkerAllocationUpdateWithoutWorker_allocation_configInput, FacilityWorkerAllocationUncheckedUpdateWithoutWorker_allocation_configInput>
  }

  export type FacilityWorkerAllocationUpdateManyWithWhereWithoutWorker_allocation_configInput = {
    where: FacilityWorkerAllocationScalarWhereInput
    data: XOR<FacilityWorkerAllocationUpdateManyMutationInput, FacilityWorkerAllocationUncheckedUpdateManyWithoutWorker_allocation_configInput>
  }

  export type FacilityTypeUpsertWithoutWorker_allocationsInput = {
    update: XOR<FacilityTypeUpdateWithoutWorker_allocationsInput, FacilityTypeUncheckedUpdateWithoutWorker_allocationsInput>
    create: XOR<FacilityTypeCreateWithoutWorker_allocationsInput, FacilityTypeUncheckedCreateWithoutWorker_allocationsInput>
    where?: FacilityTypeWhereInput
  }

  export type FacilityTypeUpdateToOneWithWhereWithoutWorker_allocationsInput = {
    where?: FacilityTypeWhereInput
    data: XOR<FacilityTypeUpdateWithoutWorker_allocationsInput, FacilityTypeUncheckedUpdateWithoutWorker_allocationsInput>
  }

  export type FacilityTypeUpdateWithoutWorker_allocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutFacility_typeNestedInput
    field_mappings?: FacilityFieldMappingUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUpdateOneWithoutFacility_typeNestedInput
  }

  export type FacilityTypeUncheckedUpdateWithoutWorker_allocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutFacility_typeNestedInput
    field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeNestedInput
    remunerations?: FacilityTypeRemunerationUncheckedUpdateOneWithoutFacility_typeNestedInput
  }

  export type FacilityCreateWithoutWorker_allocationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutWorker_allocationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutWorker_allocationsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutWorker_allocationsInput, FacilityUncheckedCreateWithoutWorker_allocationsInput>
  }

  export type WorkerAllocationConfigCreateWithoutFacility_allocationsInput = {
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_type: FacilityTypeCreateNestedOneWithoutWorker_allocationsInput
  }

  export type WorkerAllocationConfigUncheckedCreateWithoutFacility_allocationsInput = {
    id?: number
    facility_type_id: string
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkerAllocationConfigCreateOrConnectWithoutFacility_allocationsInput = {
    where: WorkerAllocationConfigWhereUniqueInput
    create: XOR<WorkerAllocationConfigCreateWithoutFacility_allocationsInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_allocationsInput>
  }

  export type FacilityUpsertWithoutWorker_allocationsInput = {
    update: XOR<FacilityUpdateWithoutWorker_allocationsInput, FacilityUncheckedUpdateWithoutWorker_allocationsInput>
    create: XOR<FacilityCreateWithoutWorker_allocationsInput, FacilityUncheckedCreateWithoutWorker_allocationsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutWorker_allocationsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutWorker_allocationsInput, FacilityUncheckedUpdateWithoutWorker_allocationsInput>
  }

  export type FacilityUpdateWithoutWorker_allocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutWorker_allocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type WorkerAllocationConfigUpsertWithoutFacility_allocationsInput = {
    update: XOR<WorkerAllocationConfigUpdateWithoutFacility_allocationsInput, WorkerAllocationConfigUncheckedUpdateWithoutFacility_allocationsInput>
    create: XOR<WorkerAllocationConfigCreateWithoutFacility_allocationsInput, WorkerAllocationConfigUncheckedCreateWithoutFacility_allocationsInput>
    where?: WorkerAllocationConfigWhereInput
  }

  export type WorkerAllocationConfigUpdateToOneWithWhereWithoutFacility_allocationsInput = {
    where?: WorkerAllocationConfigWhereInput
    data: XOR<WorkerAllocationConfigUpdateWithoutFacility_allocationsInput, WorkerAllocationConfigUncheckedUpdateWithoutFacility_allocationsInput>
  }

  export type WorkerAllocationConfigUpdateWithoutFacility_allocationsInput = {
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type?: FacilityTypeUpdateOneRequiredWithoutWorker_allocationsNestedInput
  }

  export type WorkerAllocationConfigUncheckedUpdateWithoutFacility_allocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTypeCreateWithoutRemunerationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityCreateNestedManyWithoutFacility_typeInput
    field_mappings?: FacilityFieldMappingCreateNestedManyWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeUncheckedCreateWithoutRemunerationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    facilities?: FacilityUncheckedCreateNestedManyWithoutFacility_typeInput
    field_mappings?: FacilityFieldMappingUncheckedCreateNestedManyWithoutFacility_typeInput
    worker_allocations?: WorkerAllocationConfigUncheckedCreateNestedManyWithoutFacility_typeInput
  }

  export type FacilityTypeCreateOrConnectWithoutRemunerationsInput = {
    where: FacilityTypeWhereUniqueInput
    create: XOR<FacilityTypeCreateWithoutRemunerationsInput, FacilityTypeUncheckedCreateWithoutRemunerationsInput>
  }

  export type IndicatorRemunerationCreateWithoutFacility_type_remunerationInput = {
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    indicator: IndicatorCreateNestedOneWithoutRemunerationsInput
    remuneration_system?: RemunerationSystemCreateNestedOneWithoutIndicator_remunerationsInput
  }

  export type IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput = {
    id?: number
    indicator_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_system_id?: string | null
  }

  export type IndicatorRemunerationCreateOrConnectWithoutFacility_type_remunerationInput = {
    where: IndicatorRemunerationWhereUniqueInput
    create: XOR<IndicatorRemunerationCreateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput>
  }

  export type IndicatorRemunerationCreateManyFacility_type_remunerationInputEnvelope = {
    data: IndicatorRemunerationCreateManyFacility_type_remunerationInput | IndicatorRemunerationCreateManyFacility_type_remunerationInput[]
    skipDuplicates?: boolean
  }

  export type FacilityTypeUpsertWithoutRemunerationsInput = {
    update: XOR<FacilityTypeUpdateWithoutRemunerationsInput, FacilityTypeUncheckedUpdateWithoutRemunerationsInput>
    create: XOR<FacilityTypeCreateWithoutRemunerationsInput, FacilityTypeUncheckedCreateWithoutRemunerationsInput>
    where?: FacilityTypeWhereInput
  }

  export type FacilityTypeUpdateToOneWithWhereWithoutRemunerationsInput = {
    where?: FacilityTypeWhereInput
    data: XOR<FacilityTypeUpdateWithoutRemunerationsInput, FacilityTypeUncheckedUpdateWithoutRemunerationsInput>
  }

  export type FacilityTypeUpdateWithoutRemunerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUpdateManyWithoutFacility_typeNestedInput
    field_mappings?: FacilityFieldMappingUpdateManyWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUpdateManyWithoutFacility_typeNestedInput
  }

  export type FacilityTypeUncheckedUpdateWithoutRemunerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facilities?: FacilityUncheckedUpdateManyWithoutFacility_typeNestedInput
    field_mappings?: FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeNestedInput
    worker_allocations?: WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeNestedInput
  }

  export type IndicatorRemunerationUpsertWithWhereUniqueWithoutFacility_type_remunerationInput = {
    where: IndicatorRemunerationWhereUniqueInput
    update: XOR<IndicatorRemunerationUpdateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedUpdateWithoutFacility_type_remunerationInput>
    create: XOR<IndicatorRemunerationCreateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedCreateWithoutFacility_type_remunerationInput>
  }

  export type IndicatorRemunerationUpdateWithWhereUniqueWithoutFacility_type_remunerationInput = {
    where: IndicatorRemunerationWhereUniqueInput
    data: XOR<IndicatorRemunerationUpdateWithoutFacility_type_remunerationInput, IndicatorRemunerationUncheckedUpdateWithoutFacility_type_remunerationInput>
  }

  export type IndicatorRemunerationUpdateManyWithWhereWithoutFacility_type_remunerationInput = {
    where: IndicatorRemunerationScalarWhereInput
    data: XOR<IndicatorRemunerationUpdateManyMutationInput, IndicatorRemunerationUncheckedUpdateManyWithoutFacility_type_remunerationInput>
  }

  export type FacilityTypeRemunerationCreateWithoutIndicator_remunerationsInput = {
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type: FacilityTypeCreateNestedOneWithoutRemunerationsInput
  }

  export type FacilityTypeRemunerationUncheckedCreateWithoutIndicator_remunerationsInput = {
    id?: number
    total_amount: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
  }

  export type FacilityTypeRemunerationCreateOrConnectWithoutIndicator_remunerationsInput = {
    where: FacilityTypeRemunerationWhereUniqueInput
    create: XOR<FacilityTypeRemunerationCreateWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUncheckedCreateWithoutIndicator_remunerationsInput>
  }

  export type IndicatorCreateWithoutRemunerationsInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutRemunerationsInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutRemunerationsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutRemunerationsInput, IndicatorUncheckedCreateWithoutRemunerationsInput>
  }

  export type RemunerationSystemCreateWithoutIndicator_remunerationsInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RemunerationSystemUncheckedCreateWithoutIndicator_remunerationsInput = {
    id?: string
    name: string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RemunerationSystemCreateOrConnectWithoutIndicator_remunerationsInput = {
    where: RemunerationSystemWhereUniqueInput
    create: XOR<RemunerationSystemCreateWithoutIndicator_remunerationsInput, RemunerationSystemUncheckedCreateWithoutIndicator_remunerationsInput>
  }

  export type FacilityTypeRemunerationUpsertWithoutIndicator_remunerationsInput = {
    update: XOR<FacilityTypeRemunerationUpdateWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUncheckedUpdateWithoutIndicator_remunerationsInput>
    create: XOR<FacilityTypeRemunerationCreateWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUncheckedCreateWithoutIndicator_remunerationsInput>
    where?: FacilityTypeRemunerationWhereInput
  }

  export type FacilityTypeRemunerationUpdateToOneWithWhereWithoutIndicator_remunerationsInput = {
    where?: FacilityTypeRemunerationWhereInput
    data: XOR<FacilityTypeRemunerationUpdateWithoutIndicator_remunerationsInput, FacilityTypeRemunerationUncheckedUpdateWithoutIndicator_remunerationsInput>
  }

  export type FacilityTypeRemunerationUpdateWithoutIndicator_remunerationsInput = {
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type?: FacilityTypeUpdateOneRequiredWithoutRemunerationsNestedInput
  }

  export type FacilityTypeRemunerationUncheckedUpdateWithoutIndicator_remunerationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorUpsertWithoutRemunerationsInput = {
    update: XOR<IndicatorUpdateWithoutRemunerationsInput, IndicatorUncheckedUpdateWithoutRemunerationsInput>
    create: XOR<IndicatorCreateWithoutRemunerationsInput, IndicatorUncheckedCreateWithoutRemunerationsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutRemunerationsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutRemunerationsInput, IndicatorUncheckedUpdateWithoutRemunerationsInput>
  }

  export type IndicatorUpdateWithoutRemunerationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutRemunerationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type RemunerationSystemUpsertWithoutIndicator_remunerationsInput = {
    update: XOR<RemunerationSystemUpdateWithoutIndicator_remunerationsInput, RemunerationSystemUncheckedUpdateWithoutIndicator_remunerationsInput>
    create: XOR<RemunerationSystemCreateWithoutIndicator_remunerationsInput, RemunerationSystemUncheckedCreateWithoutIndicator_remunerationsInput>
    where?: RemunerationSystemWhereInput
  }

  export type RemunerationSystemUpdateToOneWithWhereWithoutIndicator_remunerationsInput = {
    where?: RemunerationSystemWhereInput
    data: XOR<RemunerationSystemUpdateWithoutIndicator_remunerationsInput, RemunerationSystemUncheckedUpdateWithoutIndicator_remunerationsInput>
  }

  export type RemunerationSystemUpdateWithoutIndicator_remunerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationSystemUncheckedUpdateWithoutIndicator_remunerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateWithoutPerformance_calculationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutPerformance_calculationsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutPerformance_calculationsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutPerformance_calculationsInput, FacilityUncheckedCreateWithoutPerformance_calculationsInput>
  }

  export type IndicatorCreateWithoutPerformance_calculationsInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutPerformance_calculationsInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutPerformance_calculationsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutPerformance_calculationsInput, IndicatorUncheckedCreateWithoutPerformance_calculationsInput>
  }

  export type sub_centreCreateWithoutPerformance_calculationsInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    monthly_health_data?: MonthlyHealthDataCreateNestedManyWithoutSub_centreInput
    facility: FacilityCreateNestedOneWithoutSub_centresInput
  }

  export type sub_centreUncheckedCreateWithoutPerformance_calculationsInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    facility_id: string
    monthly_health_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutSub_centreInput
  }

  export type sub_centreCreateOrConnectWithoutPerformance_calculationsInput = {
    where: sub_centreWhereUniqueInput
    create: XOR<sub_centreCreateWithoutPerformance_calculationsInput, sub_centreUncheckedCreateWithoutPerformance_calculationsInput>
  }

  export type FacilityUpsertWithoutPerformance_calculationsInput = {
    update: XOR<FacilityUpdateWithoutPerformance_calculationsInput, FacilityUncheckedUpdateWithoutPerformance_calculationsInput>
    create: XOR<FacilityCreateWithoutPerformance_calculationsInput, FacilityUncheckedCreateWithoutPerformance_calculationsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutPerformance_calculationsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutPerformance_calculationsInput, FacilityUncheckedUpdateWithoutPerformance_calculationsInput>
  }

  export type FacilityUpdateWithoutPerformance_calculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutPerformance_calculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type IndicatorUpsertWithoutPerformance_calculationsInput = {
    update: XOR<IndicatorUpdateWithoutPerformance_calculationsInput, IndicatorUncheckedUpdateWithoutPerformance_calculationsInput>
    create: XOR<IndicatorCreateWithoutPerformance_calculationsInput, IndicatorUncheckedCreateWithoutPerformance_calculationsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutPerformance_calculationsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutPerformance_calculationsInput, IndicatorUncheckedUpdateWithoutPerformance_calculationsInput>
  }

  export type IndicatorUpdateWithoutPerformance_calculationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutPerformance_calculationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type sub_centreUpsertWithoutPerformance_calculationsInput = {
    update: XOR<sub_centreUpdateWithoutPerformance_calculationsInput, sub_centreUncheckedUpdateWithoutPerformance_calculationsInput>
    create: XOR<sub_centreCreateWithoutPerformance_calculationsInput, sub_centreUncheckedCreateWithoutPerformance_calculationsInput>
    where?: sub_centreWhereInput
  }

  export type sub_centreUpdateToOneWithWhereWithoutPerformance_calculationsInput = {
    where?: sub_centreWhereInput
    data: XOR<sub_centreUpdateWithoutPerformance_calculationsInput, sub_centreUncheckedUpdateWithoutPerformance_calculationsInput>
  }

  export type sub_centreUpdateWithoutPerformance_calculationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_health_data?: MonthlyHealthDataUpdateManyWithoutSub_centreNestedInput
    facility?: FacilityUpdateOneRequiredWithoutSub_centresNestedInput
  }

  export type sub_centreUncheckedUpdateWithoutPerformance_calculationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
    monthly_health_data?: MonthlyHealthDataUncheckedUpdateManyWithoutSub_centreNestedInput
  }

  export type FacilityCreateWithoutFacility_targetsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    is_active?: boolean
    updated_at?: Date | string
    district: DistrictCreateNestedOneWithoutFacilitiesInput
    facility_type: FacilityTypeCreateNestedOneWithoutFacilitiesInput
    facility_field_defaults?: FacilityFieldDefaultsCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreCreateNestedManyWithoutFacilityInput
    users?: UserCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutFacility_targetsInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedCreateNestedManyWithoutFacilityInput
    worker_allocations?: FacilityWorkerAllocationUncheckedCreateNestedManyWithoutFacilityInput
    field_values?: FieldValueUncheckedCreateNestedManyWithoutFacilityInput
    health_workers?: HealthWorkerUncheckedCreateNestedManyWithoutFacilityInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutFacilityInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutFacilityInput
    remuneration_calculations?: RemunerationCalculationUncheckedCreateNestedManyWithoutFacilityInput
    sub_centres?: sub_centreUncheckedCreateNestedManyWithoutFacilityInput
    users?: UserUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutFacility_targetsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutFacility_targetsInput, FacilityUncheckedCreateWithoutFacility_targetsInput>
  }

  export type IndicatorCreateWithoutFacility_targetsInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutFacility_targetsInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutFacility_targetsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutFacility_targetsInput, IndicatorUncheckedCreateWithoutFacility_targetsInput>
  }

  export type FacilityUpsertWithoutFacility_targetsInput = {
    update: XOR<FacilityUpdateWithoutFacility_targetsInput, FacilityUncheckedUpdateWithoutFacility_targetsInput>
    create: XOR<FacilityCreateWithoutFacility_targetsInput, FacilityUncheckedCreateWithoutFacility_targetsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutFacility_targetsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutFacility_targetsInput, FacilityUncheckedUpdateWithoutFacility_targetsInput>
  }

  export type FacilityUpdateWithoutFacility_targetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutFacility_targetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type IndicatorUpsertWithoutFacility_targetsInput = {
    update: XOR<IndicatorUpdateWithoutFacility_targetsInput, IndicatorUncheckedUpdateWithoutFacility_targetsInput>
    create: XOR<IndicatorCreateWithoutFacility_targetsInput, IndicatorUncheckedCreateWithoutFacility_targetsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutFacility_targetsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutFacility_targetsInput, IndicatorUncheckedUpdateWithoutFacility_targetsInput>
  }

  export type IndicatorUpdateWithoutFacility_targetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutFacility_targetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorCreateWithoutWorker_allocationsInput = {
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetCreateNestedManyWithoutIndicatorInput
    denominator_field?: FieldCreateNestedOneWithoutDenominator_for_indicatorsInput
    numerator_field?: FieldCreateNestedOneWithoutNumerator_for_indicatorsInput
    target_field?: FieldCreateNestedOneWithoutTarget_for_indicatorsInput
    remunerations?: IndicatorRemunerationCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorUncheckedCreateWithoutWorker_allocationsInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
    facility_targets?: FacilityTargetUncheckedCreateNestedManyWithoutIndicatorInput
    remunerations?: IndicatorRemunerationUncheckedCreateNestedManyWithoutIndicatorInput
    monthly_data?: MonthlyHealthDataUncheckedCreateNestedManyWithoutIndicatorInput
    performance_calculations?: PerformanceCalculationUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type IndicatorCreateOrConnectWithoutWorker_allocationsInput = {
    where: IndicatorWhereUniqueInput
    create: XOR<IndicatorCreateWithoutWorker_allocationsInput, IndicatorUncheckedCreateWithoutWorker_allocationsInput>
  }

  export type IndicatorUpsertWithoutWorker_allocationsInput = {
    update: XOR<IndicatorUpdateWithoutWorker_allocationsInput, IndicatorUncheckedUpdateWithoutWorker_allocationsInput>
    create: XOR<IndicatorCreateWithoutWorker_allocationsInput, IndicatorUncheckedCreateWithoutWorker_allocationsInput>
    where?: IndicatorWhereInput
  }

  export type IndicatorUpdateToOneWithWhereWithoutWorker_allocationsInput = {
    where?: IndicatorWhereInput
    data: XOR<IndicatorUpdateWithoutWorker_allocationsInput, IndicatorUncheckedUpdateWithoutWorker_allocationsInput>
  }

  export type IndicatorUpdateWithoutWorker_allocationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutWorker_allocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type DataUploadSessionCreateManyUploaderInput = {
    id?: number
    file_name: string
    report_month: string
    total_records: number
    success_count?: number
    error_count?: number
    status?: $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    completed_at?: Date | string | null
    file_path?: string | null
  }

  export type FieldValueCreateManyUploaderInput = {
    id?: number
    field_id: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateManyApproverInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type MonthlyHealthDataCreateManyUploaderInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type DataUploadSessionUpdateWithoutUploaderInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataUploadSessionUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataUploadSessionUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    report_month?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    success_count?: IntFieldUpdateOperationsInput | number
    error_count?: IntFieldUpdateOperationsInput | number
    status?: EnumUploadStatusFieldUpdateOperationsInput | $Enums.UploadStatus
    upload_summary?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldValueUpdateWithoutUploaderInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutField_valuesNestedInput
    field?: FieldUpdateOneRequiredWithoutField_valuesNestedInput
  }

  export type FieldValueUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldValueUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUpdateWithoutApproverInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    district?: DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput
    facility?: FacilityUpdateOneWithoutMonthly_dataNestedInput
    indicator?: IndicatorUpdateOneWithoutMonthly_dataNestedInput
    sub_centre?: sub_centreUpdateOneWithoutMonthly_health_dataNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploaded_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUpdateWithoutUploaderInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approver?: UserUpdateOneWithoutApproved_dataNestedInput
    district?: DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput
    facility?: FacilityUpdateOneWithoutMonthly_dataNestedInput
    indicator?: IndicatorUpdateOneWithoutMonthly_dataNestedInput
    sub_centre?: sub_centreUpdateOneWithoutMonthly_health_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityCreateManyDistrictInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    facility_type_id: string
    is_active?: boolean
    updated_at?: Date | string
  }

  export type MonthlyHealthDataCreateManyDistrictInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    facility_id?: string | null
  }

  export type FacilityUpdateWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type?: FacilityTypeUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutDistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyHealthDataUpdateWithoutDistrictInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approver?: UserUpdateOneWithoutApproved_dataNestedInput
    facility?: FacilityUpdateOneWithoutMonthly_dataNestedInput
    indicator?: IndicatorUpdateOneWithoutMonthly_dataNestedInput
    sub_centre?: sub_centreUpdateOneWithoutMonthly_health_dataNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploaded_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorRemunerationCreateManyRemuneration_systemInput = {
    id?: number
    facility_type_remuneration_id: number
    indicator_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IndicatorRemunerationUpdateWithoutRemuneration_systemInput = {
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_remuneration?: FacilityTypeRemunerationUpdateOneRequiredWithoutIndicator_remunerationsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutRemunerationsNestedInput
  }

  export type IndicatorRemunerationUncheckedUpdateWithoutRemuneration_systemInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_remuneration_id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorRemunerationUncheckedUpdateManyWithoutRemuneration_systemInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_remuneration_id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateManyFacility_typeInput = {
    id?: string
    name: string
    created_at?: Date | string
    description?: string | null
    display_name: string
    district_id: string
    is_active?: boolean
    updated_at?: Date | string
  }

  export type FacilityFieldMappingCreateManyFacility_typeInput = {
    id?: number
    field_id: number
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WorkerAllocationConfigCreateManyFacility_typeInput = {
    id?: number
    worker_type: string
    worker_role: string
    max_count?: number
    allocated_amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityUpdateWithoutFacility_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    district?: DistrictUpdateOneRequiredWithoutFacilitiesNestedInput
    facility_field_defaults?: FacilityFieldDefaultsUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUpdateManyWithoutFacilityNestedInput
    users?: UserUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutFacility_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_field_defaults?: FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityNestedInput
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutFacilityNestedInput
    worker_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutFacilityNestedInput
    health_workers?: HealthWorkerUncheckedUpdateManyWithoutFacilityNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutFacilityNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    remuneration_calculations?: RemunerationCalculationUncheckedUpdateManyWithoutFacilityNestedInput
    sub_centres?: sub_centreUncheckedUpdateManyWithoutFacilityNestedInput
    users?: UserUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateManyWithoutFacility_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    display_name?: StringFieldUpdateOperationsInput | string
    district_id?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityFieldMappingUpdateWithoutFacility_typeInput = {
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFacility_field_mappingsNestedInput
  }

  export type FacilityFieldMappingUncheckedUpdateWithoutFacility_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityFieldMappingUncheckedUpdateManyWithoutFacility_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerAllocationConfigUpdateWithoutFacility_typeInput = {
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_allocations?: FacilityWorkerAllocationUpdateManyWithoutWorker_allocation_configNestedInput
  }

  export type WorkerAllocationConfigUncheckedUpdateWithoutFacility_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_allocations?: FacilityWorkerAllocationUncheckedUpdateManyWithoutWorker_allocation_configNestedInput
  }

  export type WorkerAllocationConfigUncheckedUpdateManyWithoutFacility_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    worker_type?: StringFieldUpdateOperationsInput | string
    worker_role?: StringFieldUpdateOperationsInput | string
    max_count?: IntFieldUpdateOperationsInput | number
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityFieldDefaultsCreateManyFacilityInput = {
    id?: number
    field_id: number
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityTargetCreateManyFacilityInput = {
    id?: number
    indicator_id: number
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityWorkerAllocationCreateManyFacilityInput = {
    id?: number
    worker_allocation_config_id: number
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FieldValueCreateManyFacilityInput = {
    id?: number
    field_id: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
  }

  export type HealthWorkerCreateManyFacilityInput = {
    id?: number
    name: string
    worker_type: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    contact_number?: string | null
    email?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MonthlyHealthDataCreateManyFacilityInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
  }

  export type PerformanceCalculationCreateManyFacilityInput = {
    id?: number
    sub_centre_id?: number | null
    indicator_id: number
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
  }

  export type RemunerationCalculationCreateManyFacilityInput = {
    id?: number
    report_month: string
    performance_percentage: Decimal | DecimalJsLike | number | string
    facility_remuneration: Decimal | DecimalJsLike | number | string
    total_worker_remuneration: Decimal | DecimalJsLike | number | string
    total_remuneration: Decimal | DecimalJsLike | number | string
    health_workers_count?: number
    asha_workers_count?: number
    calculated_at?: Date | string
  }

  export type sub_centreCreateManyFacilityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type UserCreateManyFacilityInput = {
    id?: number
    username: string
    password_hash: string
    role?: $Enums.UserRole
    is_active?: boolean | null
    last_login?: Date | string | null
    created_at?: Date | string | null
    email?: string | null
  }

  export type FacilityFieldDefaultsUpdateWithoutFacilityInput = {
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: FieldUpdateOneRequiredWithoutFacility_field_defaultsNestedInput
  }

  export type FacilityFieldDefaultsUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityFieldDefaultsUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTargetUpdateWithoutFacilityInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutFacility_targetsNestedInput
  }

  export type FacilityTargetUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityTargetUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationUpdateWithoutFacilityInput = {
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    worker_allocation_config?: WorkerAllocationConfigUpdateOneRequiredWithoutFacility_allocationsNestedInput
  }

  export type FacilityWorkerAllocationUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    worker_allocation_config_id?: IntFieldUpdateOperationsInput | number
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    worker_allocation_config_id?: IntFieldUpdateOperationsInput | number
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FieldValueUpdateWithoutFacilityInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    field?: FieldUpdateOneRequiredWithoutField_valuesNestedInput
    uploader?: UserUpdateOneRequiredWithoutField_valuesNestedInput
  }

  export type FieldValueUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldValueUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HealthWorkerUpdateWithoutFacilityInput = {
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_calculations?: WorkerRemunerationUpdateManyWithoutHealth_workerNestedInput
  }

  export type HealthWorkerUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_calculations?: WorkerRemunerationUncheckedUpdateManyWithoutHealth_workerNestedInput
  }

  export type HealthWorkerUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyHealthDataUpdateWithoutFacilityInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approver?: UserUpdateOneWithoutApproved_dataNestedInput
    district?: DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput
    indicator?: IndicatorUpdateOneWithoutMonthly_dataNestedInput
    sub_centre?: sub_centreUpdateOneWithoutMonthly_health_dataNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploaded_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceCalculationUpdateWithoutFacilityInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutPerformance_calculationsNestedInput
    sub_centre?: sub_centreUpdateOneWithoutPerformance_calculationsNestedInput
  }

  export type PerformanceCalculationUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceCalculationUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationCalculationUpdateWithoutFacilityInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationCalculationUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemunerationCalculationUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    facility_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_worker_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_remuneration?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    health_workers_count?: IntFieldUpdateOperationsInput | number
    asha_workers_count?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sub_centreUpdateWithoutFacilityInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_health_data?: MonthlyHealthDataUpdateManyWithoutSub_centreNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutSub_centreNestedInput
  }

  export type sub_centreUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_health_data?: MonthlyHealthDataUncheckedUpdateManyWithoutSub_centreNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutSub_centreNestedInput
  }

  export type sub_centreUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutFacilityInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    upload_sessions?: DataUploadSessionUncheckedUpdateManyWithoutUploaderNestedInput
    field_values?: FieldValueUncheckedUpdateManyWithoutUploaderNestedInput
    approved_data?: MonthlyHealthDataUncheckedUpdateManyWithoutApproverNestedInput
    uploaded_data?: MonthlyHealthDataUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFacilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityTargetCreateManyIndicatorInput = {
    id?: number
    report_month: string
    target_value: Decimal | DecimalJsLike | number | string
    numerator_label: string
    denominator_label: string
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type IndicatorRemunerationCreateManyIndicatorInput = {
    id?: number
    facility_type_remuneration_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_system_id?: string | null
  }

  export type IndicatorWorkerAllocationCreateManyIndicatorInput = {
    id?: string
    worker_type: string
    allocated_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MonthlyHealthDataCreateManyIndicatorInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    district_id: string
    facility_id?: string | null
  }

  export type PerformanceCalculationCreateManyIndicatorInput = {
    id?: number
    sub_centre_id?: number | null
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility_id?: string | null
  }

  export type FacilityTargetUpdateWithoutIndicatorInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutFacility_targetsNestedInput
  }

  export type FacilityTargetUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityTargetUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    target_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    numerator_label?: StringFieldUpdateOperationsInput | string
    denominator_label?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type IndicatorRemunerationUpdateWithoutIndicatorInput = {
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_remuneration?: FacilityTypeRemunerationUpdateOneRequiredWithoutIndicator_remunerationsNestedInput
    remuneration_system?: RemunerationSystemUpdateOneWithoutIndicator_remunerationsNestedInput
  }

  export type IndicatorRemunerationUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_remuneration_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_system_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_type_remuneration_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_system_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorWorkerAllocationUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorWorkerAllocationUncheckedUpdateWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    worker_type?: StringFieldUpdateOperationsInput | string
    allocated_amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyHealthDataUpdateWithoutIndicatorInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approver?: UserUpdateOneWithoutApproved_dataNestedInput
    district?: DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput
    facility?: FacilityUpdateOneWithoutMonthly_dataNestedInput
    sub_centre?: sub_centreUpdateOneWithoutMonthly_health_dataNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploaded_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceCalculationUpdateWithoutIndicatorInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneWithoutPerformance_calculationsNestedInput
    sub_centre?: sub_centreUpdateOneWithoutPerformance_calculationsNestedInput
  }

  export type PerformanceCalculationUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceCalculationUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_centre_id?: NullableIntFieldUpdateOperationsInput | number | null
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacilityFieldDefaultsCreateManyFieldInput = {
    id?: number
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    facility_id: string
  }

  export type FacilityFieldMappingCreateManyFieldInput = {
    id?: number
    is_required?: boolean
    display_order?: number
    created_at?: Date | string
    updated_at?: Date | string
    facility_type_id: string
  }

  export type FieldValueCreateManyFieldInput = {
    id?: number
    report_month: string
    string_value?: string | null
    numeric_value?: Decimal | DecimalJsLike | number | string | null
    boolean_value?: boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by: number
    remarks?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    is_override?: boolean
    override_reason?: string | null
    facility_id?: string | null
  }

  export type IndicatorCreateManyDenominator_fieldInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
  }

  export type IndicatorCreateManyNumerator_fieldInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    target_field_id?: number | null
    source_of_verification?: string | null
  }

  export type IndicatorCreateManyTarget_fieldInput = {
    id?: number
    name: string
    description?: string | null
    type: string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    code: string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: string | null
    denominator_field_id?: number | null
    denominator_label?: string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: number | null
    numerator_label?: string | null
    target_formula?: string | null
    target_type?: $Enums.TargetType
    target_value?: string | null
    source_of_verification?: string | null
  }

  export type FacilityFieldDefaultsUpdateWithoutFieldInput = {
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutFacility_field_defaultsNestedInput
  }

  export type FacilityFieldDefaultsUncheckedUpdateWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityFieldDefaultsUncheckedUpdateManyWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityFieldMappingUpdateWithoutFieldInput = {
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type?: FacilityTypeUpdateOneRequiredWithoutField_mappingsNestedInput
  }

  export type FacilityFieldMappingUncheckedUpdateWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityFieldMappingUncheckedUpdateManyWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_required?: BoolFieldUpdateOperationsInput | boolean
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_type_id?: StringFieldUpdateOperationsInput | string
  }

  export type FieldValueUpdateWithoutFieldInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility?: FacilityUpdateOneWithoutField_valuesNestedInput
    uploader?: UserUpdateOneRequiredWithoutField_valuesNestedInput
  }

  export type FieldValueUncheckedUpdateWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FieldValueUncheckedUpdateManyWithoutFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    string_value?: NullableStringFieldUpdateOperationsInput | string | null
    numeric_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boolean_value?: NullableBoolFieldUpdateOperationsInput | boolean | null
    json_value?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_override?: BoolFieldUpdateOperationsInput | boolean
    override_reason?: NullableStringFieldUpdateOperationsInput | string | null
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorUpdateWithoutDenominator_fieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutDenominator_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateManyWithoutDenominator_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorUpdateWithoutNumerator_fieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    target_field?: FieldUpdateOneWithoutTarget_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutNumerator_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateManyWithoutNumerator_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    target_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorUpdateWithoutTarget_fieldInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUpdateManyWithoutIndicatorNestedInput
    denominator_field?: FieldUpdateOneWithoutDenominator_for_indicatorsNestedInput
    numerator_field?: FieldUpdateOneWithoutNumerator_for_indicatorsNestedInput
    remunerations?: IndicatorRemunerationUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateWithoutTarget_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
    facility_targets?: FacilityTargetUncheckedUpdateManyWithoutIndicatorNestedInput
    remunerations?: IndicatorRemunerationUncheckedUpdateManyWithoutIndicatorNestedInput
    worker_allocations?: IndicatorWorkerAllocationUncheckedUpdateManyWithoutIndicatorNestedInput
    monthly_data?: MonthlyHealthDataUncheckedUpdateManyWithoutIndicatorNestedInput
    performance_calculations?: PerformanceCalculationUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type IndicatorUncheckedUpdateManyWithoutTarget_fieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    structure?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    applicable_facility_types?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    denominator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    denominator_label?: NullableStringFieldUpdateOperationsInput | string | null
    formula_config?: NullableJsonNullValueInput | InputJsonValue
    numerator_field_id?: NullableIntFieldUpdateOperationsInput | number | null
    numerator_label?: NullableStringFieldUpdateOperationsInput | string | null
    target_formula?: NullableStringFieldUpdateOperationsInput | string | null
    target_type?: EnumTargetTypeFieldUpdateOperationsInput | $Enums.TargetType
    target_value?: NullableStringFieldUpdateOperationsInput | string | null
    source_of_verification?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataCreateManySub_centreInput = {
    id?: number
    report_month: string
    value?: Decimal | DecimalJsLike | number | string | null
    data_quality?: $Enums.DataQuality
    remarks?: string | null
    uploaded_by: number
    approved_by?: number | null
    approved_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    achievement?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    numerator?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    indicator_id?: number | null
    district_id: string
    facility_id?: string | null
  }

  export type PerformanceCalculationCreateManySub_centreInput = {
    id?: number
    indicator_id: number
    report_month: string
    numerator?: Decimal | DecimalJsLike | number | string | null
    denominator?: Decimal | DecimalJsLike | number | string | null
    achievement?: Decimal | DecimalJsLike | number | string | null
    target_value?: Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: Decimal | DecimalJsLike | number | string | null
    calculated_at?: Date | string
    facility_id?: string | null
  }

  export type MonthlyHealthDataUpdateWithoutSub_centreInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approver?: UserUpdateOneWithoutApproved_dataNestedInput
    district?: DistrictUpdateOneRequiredWithoutMonthly_dataNestedInput
    facility?: FacilityUpdateOneWithoutMonthly_dataNestedInput
    indicator?: IndicatorUpdateOneWithoutMonthly_dataNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploaded_dataNestedInput
  }

  export type MonthlyHealthDataUncheckedUpdateWithoutSub_centreInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MonthlyHealthDataUncheckedUpdateManyWithoutSub_centreInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data_quality?: EnumDataQualityFieldUpdateOperationsInput | $Enums.DataQuality
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    uploaded_by?: IntFieldUpdateOperationsInput | number
    approved_by?: NullableIntFieldUpdateOperationsInput | number | null
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indicator_id?: NullableIntFieldUpdateOperationsInput | number | null
    district_id?: StringFieldUpdateOperationsInput | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceCalculationUpdateWithoutSub_centreInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneWithoutPerformance_calculationsNestedInput
    indicator?: IndicatorUpdateOneRequiredWithoutPerformance_calculationsNestedInput
  }

  export type PerformanceCalculationUncheckedUpdateWithoutSub_centreInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PerformanceCalculationUncheckedUpdateManyWithoutSub_centreInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    numerator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    denominator?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    achievement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    target_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remuneration_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkerRemunerationCreateManyHealth_workerInput = {
    id?: number
    report_month: string
    allocated_amount: Decimal | DecimalJsLike | number | string
    performance_percentage: Decimal | DecimalJsLike | number | string
    calculated_amount: Decimal | DecimalJsLike | number | string
    calculated_at?: Date | string
  }

  export type WorkerRemunerationUpdateWithoutHealth_workerInput = {
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerRemunerationUncheckedUpdateWithoutHealth_workerInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerRemunerationUncheckedUpdateManyWithoutHealth_workerInput = {
    id?: IntFieldUpdateOperationsInput | number
    report_month?: StringFieldUpdateOperationsInput | string
    allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationCreateManyWorker_allocation_configInput = {
    id?: number
    facility_id: string
    worker_count?: number
    total_allocated_amount: Decimal | DecimalJsLike | number | string
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FacilityWorkerAllocationUpdateWithoutWorker_allocation_configInput = {
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutWorker_allocationsNestedInput
  }

  export type FacilityWorkerAllocationUncheckedUpdateWithoutWorker_allocation_configInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityWorkerAllocationUncheckedUpdateManyWithoutWorker_allocation_configInput = {
    id?: IntFieldUpdateOperationsInput | number
    facility_id?: StringFieldUpdateOperationsInput | string
    worker_count?: IntFieldUpdateOperationsInput | number
    total_allocated_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicatorRemunerationCreateManyFacility_type_remunerationInput = {
    id?: number
    indicator_id: number
    base_amount: Decimal | DecimalJsLike | number | string
    conditional_amount?: Decimal | DecimalJsLike | number | string | null
    condition_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    remuneration_system_id?: string | null
  }

  export type IndicatorRemunerationUpdateWithoutFacility_type_remunerationInput = {
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: IndicatorUpdateOneRequiredWithoutRemunerationsNestedInput
    remuneration_system?: RemunerationSystemUpdateOneWithoutIndicator_remunerationsNestedInput
  }

  export type IndicatorRemunerationUncheckedUpdateWithoutFacility_type_remunerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_system_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicatorRemunerationUncheckedUpdateManyWithoutFacility_type_remunerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicator_id?: IntFieldUpdateOperationsInput | number
    base_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    conditional_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    remuneration_system_id?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}